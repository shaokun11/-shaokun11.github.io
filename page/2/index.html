<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="记录自己对相关技术的点点滴滴和一些思考，希望能够帮助来到这里的你，如果你喜欢我的文章，可以加个微信共同探讨">
<meta name="keywords" content="eos,eth,tron,区块链">
<meta property="og:type" content="website">
<meta property="og:title" content="hello shaokun">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="hello shaokun">
<meta property="og:description" content="记录自己对相关技术的点点滴滴和一些思考，希望能够帮助来到这里的你，如果你喜欢我的文章，可以加个微信共同探讨">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="hello shaokun">
<meta name="twitter:description" content="记录自己对相关技术的点点滴滴和一些思考，希望能够帮助来到这里的你，如果你喜欢我的文章，可以加个微信共同探讨">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>hello shaokun</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">hello shaokun</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">code is law</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/26/eos中inline action的理解6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/26/eos中inline action的理解6/" itemprop="url">eos的dispatcher的使用(3 完结)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-26T15:08:04+08:00">
                2019-01-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>经过前面两篇文章的练习,相信各位同学都已经对自定义dispatcher已经有了自己的看法了,那么今天我们继续跟着官方的教程走,把接下来的知识点完整一下</p>
<h4 id="自定义dispatcher-方式3"><a href="#自定义dispatcher-方式3" class="headerlink" title="自定义dispatcher 方式3"></a>自定义dispatcher 方式3</h4><ul>
<li>这种方式官方说了,不能用于eosio-cpp生成abi,所以我也不详细去探究了,有兴趣的同学可以自己研究一下.官方最后总结这是最为灵活的一种方式呢</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp&apos;s ABI generator.</span><br><span class="line">此调度程序将大多数安全逻辑和控件放在操作处理程序中，但是，不能使用eosio-cpp的ABI生成器。</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123; </span><br><span class="line">  switch(action) &#123;</span><br><span class="line">      case name(&quot;upsert&quot;).value: return upsert(receiver, code);</span><br><span class="line">      case name(&quot;notify&quot;).value: return notify(receiver, code);</span><br><span class="line">      case name(&quot;erase&quot;).value: return erase(receiver, code);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">To handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely code). Having access to code inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence &quot;Fully Flexible.&quot;</span><br><span class="line">为了处理这些请求，我们将调度程序中的安全逻辑移动到操作中。这可以提供更多控制，但可能会引入冗余，特别是对于大型合同。最后，它完成了与上述模式相同的所有点，同时允许更多信息进入范围（即代码）。在某些情况下，访问操作中的代码可能很有用。这种模式在调度程序和操作中提供了最大的灵活性，因此“完全灵活”。</span><br></pre></td></tr></table></figure>
<h4 id="自定义dispatcher-方式4"><a href="#自定义dispatcher-方式4" class="headerlink" title="自定义dispatcher 方式4"></a>自定义dispatcher 方式4</h4><ul>
<li>官方说,上面自定义apply函数的时候,如果action少还是可以接受的,如果很多呢?就编程了体力劳动了,而且有可能出现漏洞.这显然和我们程序猿的做法不一致,所以官方最后给我们推荐了新的方法,功能类似,且减少体力劳动,不得不说还是很贴心的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \</span><br><span class="line">extern &quot;C&quot; &#123; \</span><br><span class="line">   void apply( uint64_t receiver, uint64_t code, uint64_t action ) &#123; \</span><br><span class="line">      if( code == receiver ) &#123; \</span><br><span class="line">         switch( action ) &#123; \</span><br><span class="line">            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \</span><br><span class="line">         &#125; \</span><br><span class="line">         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \</span><br><span class="line">      &#125; \</span><br><span class="line">   &#125; \</span><br><span class="line">&#125; \</span><br></pre></td></tr></table></figure>
<ul>
<li>就是这么简单,虽然简单,但是我们还是得看看有什么魔法(以下内容为官方的介绍)</li>
</ul>
<ol>
<li>一定要使用这个 code == receiver的判断,而这个可以自动允许eosio.token进行transfer的方法呢</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Checks if code==receiverand that the action is not transfer. If this condition is omitted, you may introduce a vulnerability into your contract. It allows the action through if the code is eosio.token and the action is transfer. This check prevents another contract with a transfer function from exploiting your contract.</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">2. 合约的实例化,可以看出和之前的apply方法是一样的,之前是在apply函数中实例化,这里直接传入一个实例</span><br></pre></td></tr></table></figure>
<p>Instantiates the TYPE (this would be your standard C++11 class)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">3. 说内部调用了execute_action方法,和我们之前的设计一样</span><br></pre></td></tr></table></figure></p>
<p>Use the EOSIO_DISPATCH_HELPER macro, which inserts a case for each MEMBER into your switch. Inside this case, it calls execute_action using a pattern very similar to the one demonstrated in the Flexible/Compatible Dispatcher defined above.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 直接替换就可以了.不用做任何改变</span><br></pre></td></tr></table></figure></p>
<p>You can then use this macro the same way you would with the provided EOSIO_DISPATCH macro.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 既然这样,这里多了一个EOSIO_DISPATCH_HELPER的宏,我们还是得去源码看看它究竟做了什么我们才能放心呢</span><br><span class="line">* 这里出现了一个小的惊喜,由于我目前的源码都是在eos去找,我居然没有找到EOSIO_DISPATCH_HELPER这个宏,这就尴尬了,转而我转向cdt的源码,总算找到了这个宏</span><br></pre></td></tr></table></figure></p>
<p>// Helper macro for EOSIO_DISPATCH</p>
<p>#define EOSIO_DISPATCH_HELPER( TYPE,  MEMBERS ) \<br>   BOOST_PP_SEQ_FOR_EACH( EOSIO_DISPATCH_INTERNAL, TYPE, MEMBERS )</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// Helper macro for EOSIO_DISPATCH_INTERNAL</p>
<p>#define EOSIO_DISPATCH_INTERNAL( r, OP, elem ) \<br>   case eosio::name( BOOST_PP_STRINGIZE(elem) ).value: \<br>      eosio::execute_action( eosio::name(receiver), eosio::name(code), &amp;OP::elem ); \<br>      break;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>#define EOSIO_DISPATCH( TYPE, MEMBERS ) \<br>extern “C” { \<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \<br>      if( code == receiver ) { \<br>         switch( action ) { \<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \<br>         } \<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \<br>      } \<br>   } \<br>} \<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 这里一下子三个宏了,我们关心的EOSIO_DISPATCH其实内部也是调用了EOSIO_DISPATCH_HELPER,所以这第三种方式定义的宏我觉得没有必要了哈,</span><br><span class="line">* 哎,官方的文档貌似又落后了,不过已经习以为常了呢.</span><br><span class="line"></span><br><span class="line">####  Security, Security, Security...</span><br></pre></td></tr></table></figure></p>
<p>Your contract’s first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 安全第一,所以应该小心使用apply函数,所以官方最后建议还是直接使用EOSIO_DISPATCHER就可以了,至于原因则如下</span><br></pre></td></tr></table></figure></p>
<p>For simple contracts that only execute internal public actions, the EOSIO_DISPATCH is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 猜想</span><br><span class="line">* 既然使用cdt中的EOSIO_DISPATCH就能够达到需求了,那我们该如何实现前面课程的监听呢?</span><br><span class="line">* 通过查看EOSIO_DISPATCHER的判断,这里是不允许code为eosio.token的的操作的记录的,既然这样那我们改造一下EOSIO_DISPATCHER如下所示</span><br></pre></td></tr></table></figure></p>
<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \<br>extern “C” { \<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \<br>         switch( action ) { \<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \<br>         } \<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \<br>      } \<br>   } \<br>} \<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 那么最终结果和上篇文章的内容是一样的,只是我们也没有自己实现apply函数了,而是借助于helper这个宏帮助我们完成</span><br></pre></td></tr></table></figure></p>
<p>#include &lt;eosiolib/eosio.hpp&gt;</p>
<p>#include &lt;eosiolib/print.hpp&gt;</p>
<p>using namespace eosio;</p>
<p>class [[eosio::contract]] addressbook : public eosio::contract {</p>
<p>public:<br>  using contract::contract;</p>
<p>  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}</const></p>
<p>  [[eosio::action]]<br>  void upsert(name user, std::string first_name, std::string last_name) {<br>    require_auth(user);<br>    address_index addresses(_code, _code.value);<br>    auto iterator = addresses.find(user.value);<br>    if( iterator == addresses.end() )<br>    {<br>      addresses.emplace(user, <a href="auto&amp; row">&amp;</a> {<br>       row.key = user;<br>       row.first_name = first_name;<br>       row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully emplaced record to addressbook”);<br>    }<br>    else {<br>      std::string changes;<br>      addresses.modify(iterator, user, <a href="auto&amp; row">&amp;</a> {<br>        row.key = user;<br>        row.first_name = first_name;<br>        row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully modified record to addressbook”);<br>    }<br>  }</p>
<p>  [[eosio::action]]<br>  void erase(name user) {<br>    require_auth(user);</p>
<pre><code>address_index addresses(_self, _code.value);

auto iterator = addresses.find(user.value);
eosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);
addresses.erase(iterator);
send_summary(user, &quot; successfully erased record from addressbook&quot;);
</code></pre><p>  }</p>
<p>  void transfer(uint64_t receiver, uint64_t code){<br>    send_summary(name(code), “eosio.token transfer”);<br>  }</p>
<p>private:<br>  struct [[eosio::table]] person {<br>    name key;<br>    std::string first_name;<br>    std::string last_name;<br>    uint64_t primary_key() const { return key.value; }<br>  };</p>
<p>  void send_summary(name user, std::string message) {<br>    action(<br>      permission_level{get_self(),”active”_n},<br>      get_self(),<br>      “notify”_n,<br>      std::make_tuple(user, name{user}.to_string() + message)<br>    ).send();<br>  };</p>
<p>  typedef eosio::multi_index&lt;”people”_n, person&gt; address_index;<br>};</p>
<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \<br>extern “C” { \<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \<br>         switch( action ) { \<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \<br>         } \<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \<br>      } \<br>   } \<br>} \</p>
<p>EOSIO_DISPATCH_CUSTOM( addressbook, (upsert)(erase)(transfer) )<br><code>`</code></p>
<h4 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h4><ul>
<li>通过我们自定义的dispatcher,我们已经实现了和上篇文章同样的功能,且不用自己实现apply函数,极大的简化了操作</li>
<li>当然,目前的方式我们允许的是eosio.token执行transfer操作,那么我们也可以仿照实现其他特殊合约的记录,比如说eosio.system(用来操作cpu,ram)的或者其他我们自定义的合约</li>
</ul>
<p><img src="/img_eos1/eos_gif_1.gif" alt="shaokun"></p>
<p><a href="https://github.com/shaokun11/eosabout/tree/eos-dispatcher-03" target="_blank" rel="noopener">本课源码</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>上一篇最后一个问题,我们已经记录了当我们账户上eos的交易的数据,但是具体的数据我们还不知道呢?比如说转给谁?谁转的?转了多少?还有memo(这个也很重要的,有时候很多数据的有效性可以通过它来进行验证)</li>
<li>第二个问题,我们怎么在链上发我们的自己的代币呢?而且这个代币要符合eos代币的标准标准(这里为什么要抛出这个问题呢?因为我只在本地的环境按照教程走,发过行过代币,但是在测试网,我没有eosio.token的账号,我居然懵逼了,不知道怎么发了),过程很简单,但是留给各位同学自己也思考一下</li>
<li>三篇文章下来,可以看到跟着官网走,有好处,权威,也有坑,文档总是落后实际情况,那么我们能做点什么吗?我觉得能的,虽然语法变了,但是核心不变,所以我们掌握它的基础性内容,变来变去我们只需要去补一点它变化的内容就好了,如果你之前有基础,这应该就是手到擒来的事情了,只是,看我们还能否学得动哈^_^</li>
</ul>
<h4 id="啰嗦一句"><a href="#啰嗦一句" class="headerlink" title="啰嗦一句"></a>啰嗦一句</h4><ul>
<li>莫名其妙,就叫收拾东西走人了,具体原因都没有,寒冬的果实也落在了我的头上了…(ps:猜测是俺站错了队吧,整个团队一起走人了…)</li>
<li>换个方向想,何尝不是又给了我们人生中多一次选择的机会呢?</li>
<li>这应该是年前的最后一篇文章了,希望年后能够继续给大家分享一些dapp开发的知识,谢谢你的阅读</li>
</ul>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>email: <a href="mailto:&#115;&#107;&#117;&#x6e;&#110;&#x79;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#115;&#107;&#117;&#x6e;&#110;&#x79;&#64;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/19/eos中inline action的理解5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/19/eos中inline action的理解5/" itemprop="url">eos的dispatcher的使用(2)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-19T20:25:13+08:00">
                2019-01-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>希望阅读本篇文章的同学去看一下上一篇文章,不然思路断了接不上就有点麻烦了    </p>
</blockquote>
<h4 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h4><ul>
<li>话说以太坊的分叉计划又延期了,而此次的升级主要是针对底层的安全机制,所以可见写智能合约的最关键点还是安全第一吧,</li>
<li>eos一直被攻击,从未被停止.最近的eos因为一个derferred action的问题的漏洞又被黑客利用了,哎… 受伤的总是开发者</li>
<li>大家写的合约还有一个点,就是安全.这里一个朋友已经开发了一款应用,也已经上线到主网,各种测试也做了,什么逻辑,压力,数据,前端页面的跳转等等… 然而当项目上线后,他找到我对我说,别人可以绕过前端代码直接调用的它的合约…  我只能说,这就是智能合约,你所写的合约是全世界的人(当然,如果你的项目很成功,那么黑客也是由兴趣来光顾的)都可以调用的,除非你做一些权限的验证.在eos上还好,可以通过升级合约来弥补,而且code还不用开源.但是在eth,code is law,code还要开源,所以各位同学想想这个合约安全的重要性.eos底层虽然还有bug,我们无法避免,但是我们还是应该对我们的应用层的逻辑进行严格的测试,这样开发的智能合约才经得住世界人民的考验,你说是不是呢?</li>
</ul>
<h4 id="自定义dispatcher-方式2"><a href="#自定义dispatcher-方式2" class="headerlink" title="自定义dispatcher 方式2"></a>自定义dispatcher 方式2</h4><blockquote>
<p>按照上篇文章的做法,那么我们实现了自己定义apply函数来取代EOSIO_DISPATCHER,但是实现的功能是一模一样的,那我们这样做的目的是什么呢?</p>
</blockquote>
<ul>
<li>那么接下来我们继续按照官方的教程走,通过另外一种方式来实现.</li>
<li>那么此种方式相对于上一中方式有什么区别呢?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This pattern provides more control over security at the expense of maintainability. Utilizing if...else if statements as opposed to a switch inherently provides more granularity.</span><br><span class="line">此模式以可维护性为代价提供了对安全性的更多控制。利用if ... else if语句而不是switch提供更精细的控制。</span><br></pre></td></tr></table></figure>
<p>好吧,既然看起来优点这么多,那么我们就看看是怎么样实现的吧</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">  void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class="line">    addressbook _addressbook(receiver);</span><br><span class="line">    if(code==receiver &amp;&amp; action==name(&quot;upsert&quot;).value) &#123;</span><br><span class="line">      execute_action(name(receiver), name(code), &amp;addressbook::upsert );</span><br><span class="line">    &#125;</span><br><span class="line">    else if(code==receiver &amp;&amp; action==name(&quot;notify&quot;).value) &#123;</span><br><span class="line">      execute_action(name(receiver), name(code), &amp;addressbook::notify );</span><br><span class="line">    &#125;</span><br><span class="line">    else if(code==receiver &amp;&amp; action==name(&quot;erase&quot;).value) &#123;</span><br><span class="line">      execute_action(name(receiver), name(code), &amp;addressbook::erase );</span><br><span class="line">    &#125;</span><br><span class="line">    else if(code==name(&quot;eosio.token&quot;).value &amp;&amp; action==name(&quot;transfer&quot;).value) &#123;</span><br><span class="line">      execute_action(name(receiver), name(code), &amp;addressbook::transfer );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>初看和上一篇文章简直是一模一样,就是把switch换成了if…else,看来官方真实说的大实话呢</li>
<li>不过,最后一个else多了一个判断,addressbook去调用transfer方法,可是我们没有啊,既然是这样,那我们就依样画葫芦,待会写一个吧</li>
<li>第二点,最后一个else判断变成了code == eosio.token,这就是我们上篇文章说的这个code的意义了.而eosio.token是系统的账号,当发生eos或者其他代币时才会调用这个方法呢,那么我猜测一下这个判断是当发生eosio.token执行transfer的时候,将会执行我们合约transfer方法</li>
</ul>
<h4 id="结果验证"><a href="#结果验证" class="headerlink" title="结果验证"></a>结果验证</h4><blockquote>
<p>按照上面说的,我们就按照我们得思路先写一个吧,那么就加一个transfer方法如下.</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void transfer(uint64_t receiver, uint64_t code)&#123;</span><br><span class="line">   send_summary(name(code), &quot;eosio.token transfer&quot;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>很简单,当发生transfer时,我们出发一个inline action来记录一下数据</li>
<li>那我们看下结果,结果报错了???? </li>
<li>why? 我们仅仅是转账啊,自己转出去或者别人转进来,现在都失败了</li>
</ul>
<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p><em>Authorization failure with inline action sent to self</em></p>
<ul>
<li>权限不允许给自己发送内联action?</li>
<li>这是什么情况?给自己发送内联action还要权限?</li>
<li>想想想… 对了,要让自己的合约调用其他合约需要给eosio.code发送权限,那我们接下来试试看看是不是这个原因呢</li>
</ul>
<p><img src="/img_eos1/eos_react9.gif" alt="shaokun"></p>
<h4 id="再次验证分析结果"><a href="#再次验证分析结果" class="headerlink" title="再次验证分析结果"></a>再次验证分析结果</h4><ul>
<li>使用owner权限,给eosio.code授予active权限</li>
<li>执行相互转账</li>
<li>查看是否能够出发我们自定义的内联action(经过上一步的操作,和我们之前的经验,它应该是调用了我们得inline action,不过还是得看事实说话呢)</li>
<li>去kylin,确实达到了我们的结果,无论转账转出或者转入,那么我们都发送了一个inline action<br><img src="/img_eos1/eos_react10.gif" alt="shaokun"></li>
</ul>
<p><a href="https://github.com/shaokun11/eosabout/tree/eos-dispatcher-02" target="_blank" rel="noopener">本课源码</a>  </p>
<ul>
<li>这里说一下这个源码,我已经编译好的abi和wasm文件,各位同学可以直接部署,如果要修改源码,就得自己编译了.不同的编译版本可能会有不同的eos语法,我这里用的是cdt1.3.2</li>
<li>还有,部署的时候,最好文件夹名字和主合约的名字一样,这样可以可以避免一些想不到的奇奇怪怪的错误.</li>
</ul>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li>关于上一篇文章开篇提到的类似以太坊中payable关键字的功能,我想各位同学应该知道怎么实现了吧</li>
<li>通过我们目前自己实现apply的方式,不用eosio.code授予权限,我们是可以拒绝或者转出eos的,当然这样的方式达到了目的,但是不够优雅</li>
<li>通过结果,我们发现了我们也可以在合约中检查监听到eos的转出和转入,那么我们是否可以通过此做出相应的动作呢?答案是可以的,具体怎么使用我们以后的文章再说</li>
<li>那么我们怎么优雅的实现拒绝账户eos的交易呢,我觉得最简单的方法就是调用eosio_assert(1==2);哈哈,^_^</li>
<li>问题又来了?如果我不调用inline action,那么是不是我不用授权给eosio.code就可以实现转账呢?答案是可以的,本篇文章主要是为了看到具体的转账结果,所以用了inline action,相当于也给大家复习一下这个权限吧.至于这个不使用inline action的,这个可以交由各位同学自己去实现了哈</li>
<li>问题又来了?那我要怎么拿取转账的信息呢?</li>
</ul>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#x73;&#x6b;&#117;&#110;&#x6e;&#x79;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x73;&#x6b;&#117;&#110;&#x6e;&#x79;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#x6f;&#109;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/12/eos中inline action的理解4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/12/eos中inline action的理解4/" itemprop="url">eos的dispatcher的使用(1)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-12T09:44:26+08:00">
                2019-01-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><blockquote>
<p>上一篇文章我还在埋怨eos中的智能合约怎么没有以太坊类似的关键字payable呢?看来只有时间才会回答我的这个问题哈.也怪我图样图森破了</p>
</blockquote>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ol>
<li>想想距离上次写文章已经过去了快2个月了,而且已经翻了一年了,回想一下去年都做了什么呢?忘了…. 那是什么让我停下了呢?<ul>
<li>工作,毕竟要靠这个混口饭吃,心累…</li>
<li>因为个人原因,周末都在往医院跑,</li>
<li>这个eos的知识点是我周末和下班浏览得到的一点知识,主要是现在我在百度也没有找到比较合适的eos智能合约开发教程,所以就把我的这一路走过来的知识点记录下来.我的工作主要也是做智能合约的开发,所以了解一下也是为了未来失业了多一点选择.而目前公司都是基于以太坊和波场的,所以重点我还是会放到公司的项目中来</li>
<li>至于其他的零碎时间都没有打开电脑了,只是补习了一些c++的知识,虽然我有java功底,但是对与没有常写c++的我来说,语法对我来说不是很难,难在如何动笔写,如何组织代码结构和写出c++的风格</li>
</ul>
</li>
<li>在之前的文章中,我们得智能合约能够跑起来,也能够产生各种交互了.这也得益于官方的文档不断的更新,而我也止步于这个地方了,而对于官方智能合约的最后一篇文章,dispatcher的使用我选择了跳过.</li>
<li>近段时间和几个加我微信好友的开发者一起探讨上面的坑的时候,又回去阅读了几遍官方的教程,再结合Google,那暂时把得到的一点知识分享给大家,希望能够对你有帮助.</li>
</ol>
<p><a href="https://developers.eos.io/eosio-home/docs/writing-a-custom-dispatcher" target="_blank" rel="noopener">custom dispatchers</a></p>
<h4 id="什么是EOSIO-DISPATCH"><a href="#什么是EOSIO-DISPATCH" class="headerlink" title="什么是EOSIO_DISPATCH"></a>什么是EOSIO_DISPATCH</h4><blockquote>
<p>本篇文章我们先跟着上面的链接,把dispatcher的基础信息弄明白,然后再谈其他的哈.而我也会根据自己的理解像大家解释一下,如果有不对的地方,希望各位同学帮我指正过来</p>
</blockquote>
<pre><code>EOSIO_DISPATCH( myclass, (upsert)(notify)(erase) )
</code></pre><p>相信这个大家都知道是c++的宏,帮组eos的合约分发action,那么这个宏的具体定义是什么呢?我们来到源码看看</p>
<p><a href="https://sourcegraph.com/github.com/EOSIO/eos/-/blob/contracts/eosiolib/dispatcher.hpp#L13:9-13:17" target="_blank" rel="noopener">dispatcher.cpp </a> (这里的eos源码还是EOSIO_ABI,在cdt1.3后改为了EOS_DISPATCHER,只是宏名字改了,内容不变)</p>
<pre><code>/** 
 * Convenient macro to create contract apply handler
 * To be able to use this macro, the contract needs to be derived from eosio::contract
 * 
 * @brief Convenient macro to create contract apply handler 
 * @param TYPE - The class name of the contract
 * @param MEMBERS - The sequence of available actions supported by this contract
 * 
 * Example:
 * @code
 * EOSIO_ABI( eosio::bios, (setpriv)(setalimits)(setglimits)(setprods)(reqauth) )
 * @endcode
 */
#define EOSIO_ABI( TYPE, MEMBERS ) \
extern &quot;C&quot; { \
   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \
      auto self = receiver; \
      if( action == N(onerror)) { \
         /* onerror is only valid if it is for the &quot;eosio&quot; code account and authorized by &quot;eosio&quot;&apos;s &quot;active permission */ \
         eosio_assert(code == N(eosio), &quot;onerror action&apos;s are only valid from the \&quot;eosio\&quot; system account&quot;); \
      } \
      if( code == self || action == N(onerror) ) { \
         TYPE thiscontract( self ); \
         switch( action ) { \
            EOSIO_API( TYPE, MEMBERS ) \
         } \
         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \
      } \
   } \
} \
</code></pre><p>看到了这个宏的具体实现,应该说这个函数在比较古老的版本,需要自己实现的,后面eos为了简化开发者的工作,才定义了这个宏.后面很多的宏比如说ACTION, CONTRACT也都是如此.这个宏的具体用法请看上面的注释,结果就是我们现在写合约的使用方式了.这个dispatcher.cpp建议大家可以深入了解一下,对后面的智能合约开发或者出现的bug都会有更加深一步的看法</p>
<p>这里还有一个关键点就是,我们的智能合约如果要能够使用,必须提供一个apply的函数,而上面的宏就是帮助我们实现的这个apply函数.那么疑问来了,我是不是自己实现一个apply函数,不用上面的宏,也可以完成这个工作呢?<br>答案是可以的</p>
<h4 id="自定义dispatcher-方式1"><a href="#自定义dispatcher-方式1" class="headerlink" title="自定义dispatcher 方式1"></a>自定义dispatcher 方式1</h4><blockquote>
<p>这里同样跟着官方的教程走</p>
</blockquote>
<pre><code>extern &quot;C&quot; {
    void apply(uint64_t receiver, uint64_t code, uint64_t action) {
        auto self = receiver;
        if( code == self ) {
          addressbook _addressbook(name(receiver));
          switch(action) {
            case name(&quot;upsert&quot;).value: 
              execute_action(name(receiver), name(code), &amp;addressbook::upsert); 
              break;
            case name(&quot;notify&quot;).value: 
              execute_action(name(receiver), name(code), &amp;addressbook::notify); 
              break;
            case name(&quot;erase&quot;).value: 
              execute_action(name(receiver), name(code), &amp;addressbook::erase); 
              break;
          }
        }
    }
};
</code></pre><p>1.</p>
<ul>
<li>可以看到apply函数接收三个参数,第一个receiver,合约的拥有者,</li>
<li>第二个参数code,调用合约的发起人(这个参数我理解为通过什么方式调用的,如果直接通过调用本合约的,这个参数就是self,而如果通过其他智能合约比如说eosio.token,这个code就是eosio.token,或者其他合约的拥有者)</li>
<li>第三个,执行合约的action,也就是合约的函数名,这个合约被标识为action</li>
</ul>
<ol start="2">
<li>if中判断如果合约的调用者是直接调用此合约的,即不是通过其他合约调用本合约的</li>
<li>实例化addressbook这个类,(这里有点疑惑的是,这个_addressbook在这里代表的是类,而addressbook才是对象,没有明白这是为什么,在c++ 中实例化一个类不是 T t 这种形式吗?),这个实例化比较古老了,只接受了一个参数,在cdt1.3要接受三个参数,请注意</li>
<li>一个switch结构,根据对应的action的名字分发对应的动作</li>
<li><p>使用eosio::execute_action执行对应的action</p>
<ul>
<li><p>这里大家又看到了一个新的东西了,不要怕,我们看看是什么</p>
<pre><code>   /**
 * @defgroup dispatcher Dispatcher API
 * @brief Defines functions to dispatch action to proper action handler inside a contract
 * @ingroup contractdev
 */

/**
 * @defgroup dispatchercpp Dispatcher C++ API
 * @brief Defines C++ functions to dispatch action to proper action handler inside a contract
 * @ingroup dispatcher
 * @{
 */

/**
 * Unpack the received action and execute the correponding action handler
 * 
 * @brief Unpack the received action and execute the correponding action handler
 * @tparam T - The contract class that has the correponding action handler, this contract should be derived from eosio::contract
 * @tparam Q - The namespace of the action handler function 
 * @tparam Args - The arguments that the action handler accepts, i.e. members of the action
 * @param obj - The contract object that has the correponding action handler
 * @param func - The action handler
 * @return true  
 */
template&lt;typename T, typename Q, typename... Args&gt;
bool execute_action( T* obj, void (Q::*func)(Args...)  ) {
...
}
</code></pre></li>
<li><p>这里我把具体实现删掉了,只留下了注释和方法签名,可以看到是一个模板函数,那我们就看看他的作用是什么了</p>
<pre><code>Unpack the received action and execute the correponding action handler
解压缩收到的操作并执行相应的操作处理程序
</code></pre></li>
<li>再结合上面的具体的参数的用法,就知道了原来又是一个dispatcher的帮助函数,帮我们去分发对应的action,只是传递的方式变了.</li>
<li>很好,现在我们已经抛弃了系统提供的EOSIO_DISPATCH而自己实现了这个apply函数,至于能不能用呢?那我们接下来试试了</li>
</ul>
</li>
</ol>
<h4 id="自定义dispatcher-方式1-结果展示"><a href="#自定义dispatcher-方式1-结果展示" class="headerlink" title="自定义dispatcher 方式1 结果展示"></a>自定义dispatcher 方式1 结果展示</h4><blockquote>
<p>本次我们直接copy的官方的addressbook的源码,然后使用自己实现apply函数<br>精简一些不必要的参数,实现功能为主<br>上面我说过,由于版本的原因,目前的版本我们需要在实例化addressbook的时候传入三个参数</p>
</blockquote>
<pre><code>addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));
</code></pre><blockquote>
<p>最终改造了的代码如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;eosiolib/eosio.hpp&gt;</span><br><span class="line">#include &lt;eosiolib/print.hpp&gt;</span><br><span class="line"></span><br><span class="line">using namespace eosio;</span><br><span class="line"></span><br><span class="line">class [[eosio::contract]] addressbook : public eosio::contract &#123;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">  using contract::contract;</span><br><span class="line">  </span><br><span class="line">  addressbook(name receiver, name code,  datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  void upsert(name user, std::string first_name, std::string last_name) &#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line">    address_index addresses(_code, _code.value);</span><br><span class="line">    auto iterator = addresses.find(user.value);</span><br><span class="line">    if( iterator == addresses.end() )</span><br><span class="line">    &#123;</span><br><span class="line">      addresses.emplace(user, [&amp;]( auto&amp; row ) &#123;</span><br><span class="line">       row.key = user;</span><br><span class="line">       row.first_name = first_name;</span><br><span class="line">       row.last_name = last_name;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, &quot; successfully emplaced record to addressbook&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      std::string changes;</span><br><span class="line">      addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;</span><br><span class="line">        row.key = user;</span><br><span class="line">        row.first_name = first_name;</span><br><span class="line">        row.last_name = last_name;</span><br><span class="line">      &#125;);</span><br><span class="line">      send_summary(user, &quot; successfully modified record to addressbook&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  void erase(name user) &#123;</span><br><span class="line">    require_auth(user);</span><br><span class="line"></span><br><span class="line">    address_index addresses(_self, _code.value);</span><br><span class="line"></span><br><span class="line">    auto iterator = addresses.find(user.value);</span><br><span class="line">    eosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);</span><br><span class="line">    addresses.erase(iterator);</span><br><span class="line">    send_summary(user, &quot; successfully erased record from addressbook&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [[eosio::action]]</span><br><span class="line">  void notify(name user, std::string msg) &#123;</span><br><span class="line">    require_auth(get_self());</span><br><span class="line">    require_recipient(user);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">  struct [[eosio::table]] person &#123;</span><br><span class="line">    name key;</span><br><span class="line">    std::string first_name;</span><br><span class="line">    std::string last_name;</span><br><span class="line">    uint64_t primary_key() const &#123; return key.value; &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  void send_summary(name user, std::string message) &#123;</span><br><span class="line">    action(</span><br><span class="line">      permission_level&#123;get_self(),&quot;active&quot;_n&#125;,</span><br><span class="line">      get_self(),</span><br><span class="line">      &quot;notify&quot;_n,</span><br><span class="line">      std::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class="line">    ).send();</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  typedef eosio::multi_index&lt;&quot;people&quot;_n, person&gt; address_index;</span><br><span class="line">  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class="line">        auto self = receiver;</span><br><span class="line">        if( code == self ) &#123;</span><br><span class="line">          addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));</span><br><span class="line">          switch(action) &#123;</span><br><span class="line">            case name(&quot;upsert&quot;).value: </span><br><span class="line">              execute_action(name(receiver), name(code), &amp;addressbook::upsert); </span><br><span class="line">              break;</span><br><span class="line">            case name(&quot;notify&quot;).value: </span><br><span class="line">              execute_action(name(receiver), name(code), &amp;addressbook::notify); </span><br><span class="line">              break;</span><br><span class="line">            case name(&quot;erase&quot;).value: </span><br><span class="line">              execute_action(name(receiver), name(code), &amp;addressbook::erase); </span><br><span class="line">              break;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><ol>
<li>此次合约部署在kylin上的shaokun11114账号上可以看到我们也完美实现了数据增加和删除</li>
</ol>
<p><img src="/img_eos1/eos_react8.gif" alt="shaokun"></p>
<ol start="2">
<li>去kylin查看结果,可以看到我们得交易记录,其中的notify也可以看到,说明apply函数正常使用</li>
</ol>
<p><img src="/img_eos1/eos15.png" alt="shaokun"></p>
<p><a href="https://github.com/shaokun11/eosabout/tree/eos-dispatcher-01" target="_blank" rel="noopener">源码</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol>
<li>这就完了?当然没有,这篇文章只是简单的和大家一起走走官网的dispatcher,当然还没有走完,如果只是这样写了能够实现功能那和用eos提供的宏没什么区别了呢</li>
<li>我建议各位同学接触到错误不要慌,也不要急,各位可以先自己看看报错误的信息提示,可以把这个粘贴到Google上找一下答案,这样自己找寻到的答案记忆会深刻许多</li>
<li>接下来将我进一步跟着官网走,把剩下的一点点讲明白,而这才是dispatcher的真正用法呢.可以解决文章开头提到的payable的问题呢</li>
<li>谢谢大家的浏览,希望有发现错误的同学可以加上我微信帮我指出来,再次感谢.</li>
</ol>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#x73;&#x6b;&#117;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;" target="_blank" rel="noopener">&#x73;&#x6b;&#117;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#109;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/08/eos中inline action的理解3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/08/eos中inline action的理解3/" itemprop="url">eos中inline action的使用方式 (续)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-08T11:47:24+08:00">
                2018-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h4><p> 这里填一个一直以来对于我来说的一个坑,也在之前的文章的文章误导了大家关于这个event.   </p>
<ol>
<li>之前我说以太坊区块链会主动通知我们当有数据发生变化,这是经过几天的琢磨发现使用了web3.js库造成的错觉.</li>
<li>也正是由于这样,我没有在eos中找到类似的方法,所以去看看了web3.js的源码,发现它是才用轮询最新区块的内容而进行的事件的匹配然后产生的回调.  </li>
<li><p><a href="https://github.com/ethereum/web3.js/blob/develop/lib/web3/requestmanager.js" target="_blank" rel="noopener">requestmanager.js</a>,如果你感兴趣,可以看看这个文件就大概知道了,更加进一步,你可以发现一些更有趣并且非常熟悉的东西,那就是在<a href="https://github.com/ethereum/web3.js/blob/develop/lib/web3/methods/eth.js" target="_blank" rel="noopener">methods.js</a>这个文件中 </p>
</li>
<li><p>这是web3提供的方法,既然这样,那我们是不是不调用web3的方法也可以得到同样的效果呢?答案肯定是可以的.通过以上的两个文件,那我们用node也来写一个监听最新块的方法</p>
<pre><code>const axios = require(&apos;axios&apos;)
const obj = { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;eth_getBlockByNumber&quot;, &quot;params&quot;: [&quot;latest&quot;, true], &quot;id&quot;: 1 }

getBlockInfo()

function getBlockInfo() {
    axios.request(&apos;https://mainnet.infura.io/v3/e8947e207ac142519554d382200e663b&apos;, {
        method: &apos;post&apos;,
        header: {
            &apos;Content-type&apos;: &apos;application/json&apos;
        },
        data: JSON.stringify(obj)
    }).then(response =&gt; response.data).then(res =&gt; {
            console.log(res)
        })
}
</code></pre></li>
<li>上面的方式可以监听到最新一个块的所有交易信息,然后根据条件筛选即可达到我们要的目的了.这里注意两点:一是json-rpc的请求格式,二是json-rpc提供的endpoint,我这里使用的是infrua提供的.其实metamask也是使用的这个端点,所以使用web3的时候会让你提供provider,其实就是提供的这个端点</li>
</ol>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>填完坑后,给出个结论   </p>
</blockquote>
<blockquote>
<ul>
<li>区块链从来不会主动推送消息给各位同学的</li>
<li>所有的数据都是在区块里面的,只要在区块链发生的所有操作,均可以通过查询区块得到结果.</li>
<li>至于web3或者是其他库提供的监听的功能,实际上是封装了这个轮询的过程</li>
</ul>
</blockquote>
<blockquote>
<p>本篇文章还是属于inline action的范畴.就是如何在合约中进行eos的交易</p>
</blockquote>
<h4 id="在合约中交易eos"><a href="#在合约中交易eos" class="headerlink" title="在合约中交易eos"></a>在合约中交易eos</h4><ol>
<li><p>直接调用eosjs提供的api,这种方式比较简单,也不是我要说的重点(这里使用的是scatter官网提供的这个例子)</p>
<pre><code>const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };

    eos.transfer(account.name, &apos;helloworld&apos;, &apos;1.0000 EOS&apos;, &apos;memo&apos;, transactionOptions).then(trx =&gt; {
        // That&apos;s it!
        console.log(`Transaction ID: ${trx.transaction_id}`);
    }).catch(error =&gt; {
        console.error(error);
    });
</code></pre></li>
<li><p>这里有一种需求,就是在执行某个action的时候,需要预先支付一定费用的eos,当达到某种条件时候,再返回给调用者一定的量的eos.</p>
</li>
<li>根据需求我们写出了如下的代码,(注意asset这个类型,必须这样传入,关于它的更详细的用法得去看看api了哈;二是now()这个函数返回当前的时间戳,真实环境中这都是固定的,不能用来产生随机数).</li>
<li>还记得之前的权限操作吗? 如果要在合约中转账,必须给合约添加eosio.code的权限,我这个合约现在部署在shaokun11113中的,那么就要给shaokun11113添加eosio.code权限.</li>
<li>添加了权限之后,我们使用shaokun11112来调用这个合约,可以看到当shaokun11113向shaokun11112转账可以成功,但是shaokun11112向shaokun11113转账是没有权限的.</li>
<li>那么,我们在shaokun11112中给shaokun11113添加eosio.code的权限</li>
<li>添加权限后,可以看到一切转账成功了</li>
<li>那么就实现了在合约中进行transfer eos的操作</li>
</ol>
<pre><code>#include &lt;eosiolib/eosio.hpp&gt;
#include &lt;eosiolib/asset.hpp&gt;    
using namespace eosio;

class [[eosio::contract]] lucky : eosio::contract {

public:
    using contract::contract;
    lucky(name r,name c, datastream&lt;const char*&gt; ds):contract(r,c,ds){}

[[eosio::action]]
void play(name player, const asset&amp; quantity) {
    require_auth(player);
    if(now() % 2 == 1){
        action(
    permission_level{get_self(),&quot;active&quot;_n},  //所需要的权限结构
    &quot;eosio.token&quot;_n,                          // 调用的合约名称
    &quot;transfer&quot;_n,                              // 合约的方法
    std::make_tuple(get_self(),player, quantity, std::string(&quot;shao kun game&quot;)) // 传递的参数
        ).send();
    } else {
        action(
        permission_level{player,&quot;active&quot;_n},
        &quot;eosio.token&quot;_n,
        &quot;transfer&quot;_n,
        std::make_tuple(player,get_self(), quantity, std::string(&quot;shao kun game&quot;))
        ).send();
    }
};
};
EOSIO_DISPATCH(lucky,(play))
</code></pre><p><img src="/eosinline/inline3.gif" alt="shaokun"></p>
<h4 id="以太坊中eth使用合约进行交易"><a href="#以太坊中eth使用合约进行交易" class="headerlink" title="以太坊中eth使用合约进行交易"></a>以太坊中eth使用合约进行交易</h4><ul>
<li>在以太坊中,如果某个方法要接收eth,必须给这个方法加上payable的关键字即可,合约中可以通过msg.value获取到交易的金额.如果此方法不加上payable而调用时传递了金额,那么调用此方法会失败  </li>
<li><p>如果要在初始化的时候传入eth,必须给构造方法加上payable</p>
<pre><code>contract Test4 {

constructor() public payable {

}

function withPayable() public payable {
    if(now % 2 == 0 ){
        msg.sender.transfer(msg.value * 2);
    }
}

 function withoutPayable() public {

 }
}
</code></pre><p><img src="/eosinline/inline4.gif" alt="shaokun"></p>
</li>
</ul>
<h4 id="源码与总结"><a href="#源码与总结" class="headerlink" title="源码与总结"></a>源码与总结</h4><ul>
<li><a href="https://github.com/shaokun11/eosabout/tree/eos-transfer" target="_blank" rel="noopener">合约transfer</a></li>
<li>相对于eth来说,个人觉得eos中在合约中转账过于麻烦,这需要用户手动去给合约设置转账权限</li>
<li>如果哪位同学有更好的关于转账的方法,请告知一下,个人觉得在合约中进行转账还是很常见的需求</li>
<li>官方的eos dice合约现在已经移除了,但是可以在历史中找到<a href="https://github.com/EOSIO/eos/blob/v1.0.0/contracts/dice/dice.cpp" target="_blank" rel="noopener">eos dice</a> 有兴趣的同学可以研究一下</li>
</ul>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>email: <a href="mailto:&#x73;&#107;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x73;&#107;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/01/eos中inline action的理解2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/12/01/eos中inline action的理解2/" itemprop="url">eos中inline action的使用方式 (下)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-01T09:34:33+08:00">
                2018-12-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><ul>
<li>关于上一篇的inline action关于作为log的用法,我觉得这是其一,其二是可以action调用action,这样的话应该也算作action的第二种用法了吧  </li>
<li>本篇文章介绍inline action的第三种用户,外部合约的调用  </li>
<li>记住一点,这些调用都是在一个事务中进行的,所以可以放心大胆的使用</li>
<li>由于eos的体系,需要你完全明白eos中 account 和permission level这两个东东的作用,不然理解起来会有点困难</li>
</ul>
<h4 id="据说"><a href="#据说" class="headerlink" title="据说"></a>据说</h4><ul>
<li>听说BM又要离开eos了,我觉得无所谓了,毕竟eos是开源的,很多人维护的</li>
<li>eos1.5发布了,是不是又得跟上步伐呢?感觉学不动了</li>
<li><a href="https://mp.weixin.qq.com/s/IovpLgfvcWhu3L3tGbKiZg" target="_blank" rel="noopener">js4eos介绍</a>这工具可以简化一些工作,喜欢的同学可以试试<a href="https://github.com/itleaks/js4eos" target="_blank" rel="noopener">js4eos github</a> </li>
</ul>
<h4 id="eos中inline-action-结果展示与说明"><a href="#eos中inline-action-结果展示与说明" class="headerlink" title="eos中inline action 结果展示与说明"></a>eos中inline action 结果展示与说明</h4><ul>
<li>这里官方的例子合约(cpp文件)和账户名字是一样的,让我困扰了一会,这里给大家一个结论就好:一个账户就只能部署一个合约,而这个合约的名字就是get_self(),当你部署合约的时候,就是账号的名字了.在写line action的时候不要弄混了</li>
<li>使用shaokun11111部署合约 addressbook</li>
<li>使用shaokun11112部署合约 adcounter</li>
<li>在addressbook中使用inline action调用adcounter中的count方法</li>
<li>这样设置后,多个合约就可以相互调用了</li>
<li>关键点,如果要actor shaokun11111能够拥有调用其他合约的权限,必须给shaokun11111账号授予权限eosio.code,这是个系统的权限.</li>
</ul>
<pre><code>cleos -u https://api-kylin.eosasia.one:443 set account permission shaokun11111 active &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82&quot;,&quot;weight&quot;:1}],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;}}]}&apos; -p shaokun11111@owner
</code></pre><ul>
<li>关于permission的格式可以参考我以前的文章,注意这里使用的owner权限</li>
<li><code>EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82</code> 这个是原来创建账号的权限的public key,当然按照上面的写法,这样其实可以更改原来账号的active的权限,建议保持原来权限创建的形式就好</li>
<li>授权成功后,账号应该有如图中的显示</li>
<li><img src="/eospermission/per1.png" alt="shaokun"></li>
<li><img src="/eospermission/per3.gif" alt="shaokun"></li>
</ul>
<h4 id="eth中合约相互调用"><a href="#eth中合约相互调用" class="headerlink" title="eth中合约相互调用"></a>eth中合约相互调用</h4><blockquote>
<p>如果你理解了eos合约的相互调用,那么接下来eth中的合约相互调用你应该很好理解了<br>个人看来两者的机制大同小异,因为eth中是以address中作为id的,而eos中是以account做为id的</p>
</blockquote>
<ul>
<li>基于上篇文章的eth合约,我们稍加改造一下</li>
<li>新添加了一个合约 Test3,其中我们将Test2的合约地址用来实例化了Service</li>
<li>这个Service中需要包含Test2合约中你需要调用的方法的签名(这里关于是怎样找到的可以去看看官方文档,其实  <code>function notify(string _notification) external;</code> 就是这个函数的签名,包括方法名字和参数类型,返回值类型hash后 取了四个字节)</li>
<li>部署Test3合约,部署成功后再Test3合约中的callNotify调用Test2合约中的notify方法,可以看到Test合约中的内容生效了</li>
<li>这里有同学可能有疑问了,你这样的合约岂不是没有安全?拿到Test2合约地址,任何人新建一个合约就可以调用其合约的方法?是的,理论上是这样的.但是,凡事都有个但是哈.还记得我在之前的文章中关于eth中的权限如果验证吗?如果你看了那篇文章,那聪明的你一定知道该怎么做了哈  </li>
<li><img src="/eospermission/per4.gif" alt="shaokun"></li>
</ul>
<h4 id="源码献上"><a href="#源码献上" class="headerlink" title="源码献上"></a>源码献上</h4><blockquote>
<p><code>addressbook.cpp</code>,没什么说的,注意写法,变化的部分如果你认真阅读了应该知道变化在哪里</p>
</blockquote>
<pre><code>#include &lt;eosiolib/eosio.hpp&gt;
#include &lt;eosiolib/print.hpp&gt;

using namespace eosio;

class [[eosio::contract]] addressbook : public eosio::contract {
public:
    using contract::contract;
    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}

    [[eosio::action]]
    void upsert(name user, std::string first_name, uint64_t age){
        require_auth(user);
        address_index addresses(_code,_code.value);
        auto itr = addresses.find(user.value);
        if(itr == addresses.end()){
            addresses.emplace(user,[&amp;](auto&amp; row){
                row.key = user;
                row.first_name = first_name;
                row.age = age;
            });
            send_summary(user, &quot;emplace data&quot;);
            counter(user,&quot;emplace&quot;);
        } else {
            addresses.modify(itr, user, [&amp;](auto&amp; row){
                        row.first_name = first_name;
                        row.age = age;
            });
            send_summary(user, &quot;modify data&quot;);
            counter(user,&quot;modify&quot;);
        }
    }

    [[eosio::action]]
    void erase(name user){
        require_auth(user);
        address_index addresses(_self, _code.value);
        auto itr = addresses.find(user.value);
        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);
        addresses.erase(itr);
        // 调用inline action
        send_summary(user, &quot; erase data&quot;);
        counter(user,&quot;erase&quot;);
    }

    [[eosio::action]]
    void notify(name user, std::string){
        // inline action
        require_auth(get_self());
        require_recipient(user);
    }

private:
    struct [[eosio::table]] person {
        name key;
        std::string first_name;
        uint64_t age;

        auto primary_key() const {
            return key.value;
        };
    };
    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;

    // inline action的具体实现
    void send_summary(name user, std::string msg){
        action(
            permission_level{get_self(),&quot;active&quot;_n},
                get_self(),
                &quot;notify&quot;_n,
                std::make_tuple(user, name{user}.to_string() +msg)
            ).send();
    }
    void counter(name user, std::string type){
        action counter = action(
            permission_level{get_self(),&quot;active&quot;_n},// 执行这个inline aciton所需要的权限,即本合约调用
            &quot;shaokun11112&quot;_n,                       // 账号名称
            &quot;count&quot;_n,                              // action 名称
            std::make_tuple(user,type)              // 传递的参数
            );
        counter.send();
    }
};
EOSIO_DISPATCH(addressbook,(upsert)(erase))
</code></pre><blockquote>
<p><code>adcounter.cpp</code> 注意其中的权限验证部分,其他没什么好说的</p>
</blockquote>
<pre><code>#include &lt;eosiolib/eosio.hpp&gt;

using namespace eosio;

class [[eosio::contract]] adcounter: public eosio::contract {
public:
    using contract::contract;
    adcounter(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver,code,ds),
                                                                    counts(receiver,code.value){}

    void count(name user, std::string type) {
        // 设定这个方法的调用权限
        // 只有 shaokun11111 这个账号部署的合约有这个权限更改这个合约的内容
        require_auth(name(&quot;shaokun11111&quot;));
        auto itr = counts.find(user.value);
        if(itr == counts.end()){
            counts.emplace(&quot;shaokun11111&quot;_n, [&amp;](auto&amp; row){
                row.key = user;
                row.emplaced = type == &quot;emplace&quot; ? 1 : 0;
                row.modified = type == &quot;modify&quot; ? 1 : 0;
                row.erased = type == &quot;erase&quot; ? 1 : 0;
            });
        } else {
            counts.modify(itr,&quot;shaokun11111&quot;_n,[&amp;](auto&amp; row){
                if (type == &quot;emplace&quot;)
                {
                    row.emplaced += 1;
                }
                if (type == &quot;modify&quot;)
                {
                    row.modified += 1;
                }
                if (type == &quot;erase&quot;)
                {
                    row.erased += 1;
                }
            });
        }
    }
private:
    struct [[eosio::table]] counter
    {
        name key;
        uint64_t emplaced;
        uint64_t modified;
        uint64_t erased;

        uint64_t primary_key() const {return key.value;}
    };

    typedef eosio::multi_index&lt;&quot;counter&quot;_n,counter&gt; counter_index;
    counter_index counts;
};
EOSIO_DISPATCH(adcounter,(count));
</code></pre><p>前端代码就不展示了,因为所有的操作都是在addressbook这个合约中进行操作的,adcounter只是展示了合约中的记录<br><a href="https://github.com/shaokun11/eosabout/tree/eos-inline-action2" target="_blank" rel="noopener">本课源码</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>建议各位同学一定要仔细敲一遍,虽然例子简单,但是再复杂的内容也是由这些简单的例子所产生的</li>
<li>eos inline action的作用已经说完了.这样掌握之后,就可以写很多合约,壮大你的dapp了.inline action很重要的一点 是可以回滚交易,好好利用,发挥意想不到的作用</li>
<li>话说还有个deferred action,有时间再和大家分享一下这货是怎使用了</li>
<li>dapp的开发不仅仅是写合约,目前主要应用还是在web上.所以建议各位同学还是得了解一下js,node,webpack,react,css这些基础的概念和用法吧.不要多熟练,大概了解一下怎么用就好了</li>
<li>还有一点,哪位同学知道eos中有类似eth中的event的功能,即合约主动推送信息给我们,我觉得这很重要.我觉得eosjs应该提供类似的功能呢.知道的同学麻烦告知一声</li>
</ul>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#x73;&#107;&#x75;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x73;&#107;&#x75;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/25/eos中inline action的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/25/eos中inline action的理解/" itemprop="url">eos中inline action的使用方式 (上)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-25T20:03:05+08:00">
                2018-11-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>eos中有两种action,一种是本文要带大家理解使用的inline action,一种deffer action.<br>关于他们的差别我觉得主要一点就是前者一定是打包在同一个块中的,而且是事务操作.</p>
</blockquote>
<h4 id="surprise"><a href="#surprise" class="headerlink" title="surprise"></a>surprise</h4><blockquote>
<ul>
<li>jungle的测试网升级到2.0了,既然升级了,应该有不少的优化吧<a href="https://monitor.jungletestnet.io/" target="_blank" rel="noopener">jugnle2.0地址</a>  </li>
<li>由于在jungle测试网遇到很多坑,所以试了试另外一个测试网<a href="https://tools.cryptokylin.io/#/tools/create" target="_blank" rel="noopener">麒麟</a>,用起来很不错,不用带梯子,建议大家在国内使用这个网络</li>
<li>在kylin创建账号和获取测试币,直接在浏览器地址栏敲进去就可以了</li>
</ul>
</blockquote>
<pre><code>http://faucet.cryptokylin.io/create_account?new_account_name
http://faucet.cryptokylin.io/get_token?your_account_name
</code></pre><h4 id="action的结果展示"><a href="#action的结果展示" class="headerlink" title="action的结果展示"></a>action的结果展示</h4><blockquote>
<ul>
<li>结果和之前的todolist内容差不多,只是多了一些额外的输出内容,而且这也是官方的例子</li>
<li>那为什么还要记录呢?第一是我学习的过程,第二是看看具体的结果,第三是部署到测试网试试</li>
<li>这里我也一些疑问?这样是否会多消耗ram? 如果不消耗,可以作为一些log的使用还是不错的,如果消耗,个人感觉没什么用,毕竟输出的每一个文字都是ram呢</li>
<li>当然,它最主要的作用是可以调用其他的合约的内容,而同时保证在一个事务中,这个下篇文章给大家展示</li>
<li>以太坊中的event有点类似本问所展示的作用,它可以监听,而且这部分log不消耗gas</li>
<li>在交互中,也顺便展示了scatter中如何切换账号的操作</li>
</ul>
</blockquote>
<p><img src="/eosinline/inline1.gif" alt="inline"></p>
<h4 id="cpp源码展示"><a href="#cpp源码展示" class="headerlink" title="cpp源码展示"></a>cpp源码展示</h4><blockquote>
<p>没什么需要多说的,注意inline action的写法</p>
</blockquote>
<pre><code>#include &lt;eosiolib/eosio.hpp&gt;    
using namespace eosio;

class [[eosio::contract]] addressbook : public eosio::contract {
public:
    using contract::contract;
    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}

    [[eosio::action]]
    void upsert(name user, std::string first_name, uint64_t age){
        require_auth(user);
        address_index addresses(_code,_code.value);
        auto itr = addresses.find(user.value);
        if(itr == addresses.end()){
            addresses.emplace(user,[&amp;](auto&amp; row){
                row.key = user;
                row.first_name = first_name;
                row.age = age;
            });
            send_summary(user, &quot;emplace data&quot;);
        } else {
            addresses.modify(itr, user, [&amp;](auto&amp; row){
                        row.first_name = first_name;
                        row.age = age;
            });
            send_summary(user, &quot;modify data&quot;);
        }
    }

    [[eosio::action]]
    void erase(name user){
        require_auth(user);
        address_index addresses(_self, _code.value);
        auto itr = addresses.find(user.value);
        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);
        addresses.erase(itr);
        send_summary(user, &quot;erase data&quot;);
    }

    [[eosio::action]]
    void notify(name user, std::string){
        require_auth(get_self());
        require_recipient(user);
    }

private:
    struct [[eosio::table]] person {
        name key;
        std::string first_name;
        uint64_t age;

        auto primary_key() const {
            return key.value;
        };
    };
    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;

    void send_summary(name user, std::string msg){
        action(
            permission_level{get_self(),&quot;active&quot;_n},
                get_self(),
                &quot;notify&quot;_n,
                std::make_tuple(user, name{user}.to_string() +msg)
            ).send();
    }
};
EOSIO_DISPATCH(addressbook,(upsert)(erase))
</code></pre><h4 id="eth中的event的使用"><a href="#eth中的event的使用" class="headerlink" title="eth中的event的使用"></a>eth中的event的使用</h4><blockquote>
<ul>
<li>eth的event可以当做log使用,而且可以单独监听.这给了极大的方便了给任何一个人或则组织想知道某个合约函数的执行情况,我觉得这是一种非常好的机制.不知道eos中有没有类似的功能.</li>
<li>也就是说合约中的信息可以主动推送给我们</li>
<li>可以看到一个简单的node七八行代码就可以监听任何一个合约的所有事件的功能,前提你得拿到这个合约的地址和abi</li>
<li>这里涉及了较多的以太坊的知识,只是为了向大家展示一下这个功能,不知道eos中目前有不有类似的功能,感觉它这个inline action即本篇文章描述的这个功能有点点类似,但是不知道能不能主动推送给我们呢?   </li>
</ul>
</blockquote>
<p><img src="/eosinline/inline2.gif" alt="inline"></p>
<h4 id="scatter遇到的一个小问题"><a href="#scatter遇到的一个小问题" class="headerlink" title="scatter遇到的一个小问题"></a>scatter遇到的一个小问题</h4><blockquote>
<ul>
<li>这里遇到了一个很纠结的问题,就是scatter无法弹出来.</li>
<li>如果有遇到的同学,请重新安装scatter那两个lib,再次感谢某位朋友帮忙  </li>
</ul>
</blockquote>
<pre><code>yarn remove eosjs scatterjs-core scatterjs-plugin-eosjs
yarn add eosjs scatterjs-core scatterjs-plugin-eosjs
</code></pre><h4 id="源码献上"><a href="#源码献上" class="headerlink" title="源码献上"></a>源码献上</h4><blockquote>
<p>这里的源码包括本篇文章演示所有的合约和js文件,涉及到了eos和eth,各位同学可以选择性使用.</p>
</blockquote>
<p><a href="https://github.com/shaokun11/eosabout/tree/eos-inline-action" target="_blank" rel="noopener">inline action的使用</a></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote>
<ul>
<li>我为什么喜欢用测试网,而且总是要带梯子? 我觉得测试网与主网的环境操作一模一样,只是换了endpoint而已.如果在测试网能够按照设想运行,那么主网只需要改变一下下即可.而梯子对于我们这行的同学来说,应该是必备的.</li>
<li>而现在用麒麟,不用梯子了哈.这点很重要</li>
<li>由于eos的交易速度很快,所以用测试网来测试完全没有任何问题.</li>
<li>这篇文章只讲解的eos的inline action的一个功能,下篇文章将使用它的更加实用的功能,而不仅仅是一个log的功能哈</li>
<li>最近公司的项目很紧,所以能不能快速把新的知识点分享给大家还是未知数了呢,如果你也对dapp开发感兴趣,可以加个微信一起探讨 ^.^</li>
<li>声明一点,我目前只对dapp的开发有点经验,至于源码分析,个人能力达不到呢.</li>
<li>eth和eos虽然实现的机制不一样,但都是区块链啊.所以学习eos的时候,当我有些地方不怎么明白,我会再回去用eth的思想来思考一下这个eos的功能怎么用,目前看来,毕竟eos个人觉得比eth上手难度大很多呢</li>
</ul>
</blockquote>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#x73;&#107;&#x75;&#x6e;&#x6e;&#121;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;" target="_blank" rel="noopener">&#x73;&#107;&#x75;&#x6e;&#x6e;&#121;&#x40;&#49;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/17/eos 权限的理解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/17/eos 权限的理解/" itemprop="url">简单例子带你彻底的理解eos中的权限在dapp中如何使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-17T21:15:01+08:00">
                2018-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>相信各位同学看eos白皮书的权限看得很是头疼,而我能搜索到的例子基本上是官方的那个权限图再结合eos.token进行转账的权限介绍.如果不细心跟着走一遍,你是绝对不好理解这个权限怎么用的.由于我头脑比较笨,着实按照大佬的文章走了三四遍才大约摸索清楚,这里给自己做一个备忘录吧<br>而我站在大佬的肩膀上,结合实际的操作给大家聊聊这个权限如何使用吧.<br>这里主要参考的  </p>
<ul>
<li><a href="https://eosfans.io/topics/653" target="_blank" rel="noopener">EOS 权限管理之-权限的使用 (你绝对找不到的干货)</a>  <ul>
<li><a href="https://bihu.com/article/293974" target="_blank" rel="noopener">EOS开发系列目录</a> 松果的文章都是根据源码分析的,建议开发dapp的同学都认真读几遍吧,这样更能帮助理解eos到底是怎样运行的</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><ul>
<li><p>提前在测试网上申请两个账号,并领取测试币(不知道怎么做的可以翻看我前面的文章),我这里申请了两个.  </p>
</li>
<li><p>这次使用cleos操作,就不使用scatter操作了.原理一样.所以得把申请的这两个账号的私钥导入到cleos创建的钱包里面  </p>
<pre><code>shaokun11121
Private key: 5KFoeWx69fjPj7mTDbcD9JauYd9LLjikYTa9Qg7N5CVZTqZrzNG
Public key: EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1

shaokun11122
Private key: 5HrJQ9eepF6FuG47eSJprxoFQ6PWRkombbWEwxoSQr6FJ1wQPbg
Public key: EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV
</code></pre></li>
</ul>
<h4 id="以太坊权限的实现"><a href="#以太坊权限的实现" class="headerlink" title="以太坊权限的实现"></a>以太坊权限的实现</h4><blockquote>
<p>这里先给贴一段简单的以太坊的权限的管理吧,这个要自己来写,如果你有以太坊的经验,相信更加容易理解.<br>理一理:</p>
<ol>
<li>部署合约,部署完成后,owner就是部署者的地址</li>
<li>查看count的值,此时count为初始值1</li>
<li>执行add方法</li>
<li>查看count的值,此时count的值为2</li>
<li>切换address</li>
<li>执行add方法,报错,因为不是owner</li>
<li>查看count的值 还是为2</li>
<li>再次执行3,4步骤,此时count的值的值为3</li>
</ol>
</blockquote>
<p> <img src="/eospermission/per1.gif" alt="eos"></p>
<pre><code>pragma solidity ^0.4.24;

contract Ownable {
  address public owner;

  constructor() public {
    owner = msg.sender;
  }

  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }
}
contract leranper is Ownable {

    uint256 public count = 1;

    function add() external onlyOwner  {
       count += 1;
    }
}
</code></pre><h4 id="eos的权限的实现"><a href="#eos的权限的实现" class="headerlink" title="eos的权限的实现"></a>eos的权限的实现</h4><blockquote>
<p>eos的权限不需要写到合约中,底层已经帮我们实现了,我们只需要进行相应的设置即可,以下是设置权限的签名.至于设置的各个参数怎么设置,怎么用,可以看看官方文档吧</p>
</blockquote>
<pre><code>Usage: cleos set account permission [OPTIONS] account permission authority [parent]

Positionals:
  account TEXT                The account to set/delete a permission authority for (required)
  permission TEXT             The permission name to set/delete an authority for (required)
  authority TEXT              [delete] NULL, [create/update] public key, JSON string, or filename defining the authority (required)
  parent TEXT                 [create] The permission name of this parents permission (Defaults to: &quot;Active&quot;)
</code></pre><p>方法1:使用account设置  </p>
<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11122&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;
</code></pre><p>方法二:使用public key进行设置</p>
<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;permission&quot;:{&quot;key&quot;:&quot;EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;  
</code></pre><p>当然你可以把两种设置方式都用上,根据个人习惯设定就好,</p>
<blockquote>
<p>这里建议后面的permission这段,先使用ide写上正确的json格式.然后在<a href="http://www.bejson.com/" target="_blank" rel="noopener">json格式压缩</a>进行压缩成一行,这样可以避免不必要的麻烦</p>
</blockquote>
<pre><code>    {
    &quot;threshold&quot;: 1,
    &quot;keys&quot;: [],
    &quot;accounts&quot;: [
        {
            &quot;permission&quot;: {
                &quot;actor&quot;: &quot;kun2&quot;,
                &quot;permission&quot;: &quot;active&quot;
            },
            &quot;weight&quot;: 1
        }
    ]
}
</code></pre><h4 id="eos的权限的解读"><a href="#eos的权限的解读" class="headerlink" title="eos的权限的解读"></a>eos的权限的解读</h4><ul>
<li>当按照上述方式设置好后,可以通过此命令查看设置的权限,注意看这里permissions里多了一个add权限 这个权限的名字是 add,阀值是1 权限值 是1 ,父权限是active. </li>
<li>这样设置后,也就是说 只要是active shaokun11121的active的权限能够执行的操作,使用shaokun11122的密钥生成的账户的active权限均能做</li>
<li>一个私钥与一个公钥是一一对应,而这一对钥匙可以作为一个或者多个account中的权限级别</li>
<li><p>当然你也可以按照上述的方式多设置几个权限看看,它的形式就像Windows的目录展示的形式,很好辨认的</p>
<pre><code>cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121
</code></pre></li>
</ul>
<p>查看的结果  </p>
<pre><code>bogon:libraries shaokun$ cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121
created: 2018-11-17T12:46:30.000
permissions: 
     owner     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1
        active     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1
           add     1:    1 shaokun11122@active
memory: 
     quota:     260.1 KiB    used:     95.82 KiB  

net bandwidth: 
     staked:        100.0000 EOS           (total stake delegated from account to self)
     delegated:       0.0000 EOS           (total staked delegated to account from others)
     used:             5.534 KiB  
     available:        18.23 MiB  
     limit:            18.24 MiB  

cpu bandwidth:
     staked:        100.0000 EOS           (total stake delegated from account to self)
     delegated:       0.0000 EOS           (total staked delegated to account from others)
     used:             9.367 ms   
     available:        3.629 sec  
     limit:            3.639 sec  

EOS balances: 
     liquid:           80.1129 EOS
     staked:          200.0000 EOS
     unstaking:         0.0000 EOS
     total:           280.1129 EOS

producers:     &lt;not voted&gt;
</code></pre><h4 id="eos权限的使用"><a href="#eos权限的使用" class="headerlink" title="eos权限的使用"></a>eos权限的使用</h4><blockquote>
<p>上述方法给shaokun11121设置了一个add的权限,得添加到具体的action上才能体现出这个价值.目前能够搜到的文章都是加载 transfer这个操作上面的.为什么呢? 因为有了这个权,就可以不用登陆shaokun11121转账了,直接使用shaokun11122转账了.</p>
</blockquote>
<ul>
<li><p>权限签名 </p>
<pre><code>Positionals:
  account TEXT                The account to set/delete a permission authority for (required)
  code TEXT                   The account that owns the code for the action (required)
  type TEXT                   the type of the action (required)
  requirement TEXT            [delete] NULL, [set/update] The permission name require for executing the given action (required)
</code></pre></li>
<li><p>给shaokun11121 add action和add 权限关联起来,这样只要是shaokun111121的合约中有add action,那么使用shaokun11122的add权限均可以调用.根据我的测试,一个account目前只能部署一个智能合约,所以这个add方法是唯一的</p>
<pre><code>cleos -u http://jungle.cryptolions.io:18888  set action permission shaokun11121 shaokun11121 add add
</code></pre></li>
</ul>
<h4 id="eos权限合约的编写"><a href="#eos权限合约的编写" class="headerlink" title="eos权限合约的编写"></a>eos权限合约的编写</h4><blockquote>
<p>合约编写很简单,就是helloworld,注意其中的权限验证那一行,也就是说,只有自己的account 才能添加或者更新自己的这条信息</p>
</blockquote>
<pre><code>#include &lt;eosiolib/eosio.hpp&gt;

using namespace eosio;

class [[eosio::contract]] learnper2 : public contract {
  public:
    using contract::contract;
    learnper2(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )
                              :contract(reciever,code,ds),
                              _students(reciever,code.value){};

    [[eosio::action]]
    void add(name user, const std::string msg) {
      require_auth(user); // 权限额验证 
      auto itr = _students.find(user.value);
      if (itr == _students.end()){
        _students.emplace(get_self(),[&amp;](auto&amp; row){
          row.user = user;
          row.msg = msg;
        });
      } else {
        _students.modify(itr, get_self(), [&amp;](auto&amp; row){
          row.msg = msg;
        });
      }
    };


  private:
  struct [[eosio::table]] student 
  {
    name user;
    std::string msg = &quot;hello world&quot;;
    uint64_t primary_key() const {return user.value;};

  };
  typedef eosio::multi_index&lt;&quot;student&quot;_n, student&gt; student_index;
  student_index _students; 
};
EOSIO_DISPATCH( learnper2, (add))
</code></pre><h4 id="eos权限合约的编译-部署"><a href="#eos权限合约的编译-部署" class="headerlink" title="eos权限合约的编译,部署"></a>eos权限合约的编译,部署</h4><ul>
<li><p>编译:这里有个小插曲,放合约cpp文件的文件夹貌似必须命名和主合约的文件名一致,生成的abi里面没有内容,这着实也困扰了我一会</p>
<p>  eosio-cpp -abigen learnper2.cpp learnper2.wasm</p>
</li>
<li><p>这里部署合约一般需要购买ram  </p>
<pre><code>cleos -u http://jungle.cryptolions.io:18888  system buyram shaokun11121 shaokun11121 -k 256
</code></pre></li>
<li><p>部署:  </p>
<pre><code>cleos -u http://jungle.cryptolions.io:18888 set contract shaokun11121 ./learnper2/ -p shaokun11121@active
</code></pre></li>
</ul>
<h4 id="eos权限合约结果展示"><a href="#eos权限合约结果展示" class="headerlink" title="eos权限合约结果展示"></a>eos权限合约结果展示</h4><p><img src="/eospermission/per2.gif" alt="eos"></p>
<blockquote>
<p>这里说一下我的操作流程</p>
</blockquote>
<ul>
<li>调用合约的add action 插入一条信息(我这里之前插入信息,故此步未进行演示)  </li>
<li>首先查看了 shaokun11121的 account信息,可以看到添加了一条add的permission</li>
<li>再次查看了 shaokun11122的account信息,正常状态,只要你新建一个account都是这样的</li>
<li>查看了钱包里面的信息,这里显示的是shaokun11122的公钥(大家可以仔细对比一下)</li>
<li>查看链上table的数据</li>
<li><p>修改数据,我们仔细来分析这条命令  </p>
<blockquote>
<ol>
<li>这里使用的传入的user是shaokun11121</li>
<li>传入的permission是 shaokun111121的add这个permission,各位同学可以回想一下之前的合约,调用都是是用的active</li>
<li>钱包中并没有shaokun11121的私钥</li>
<li>钱包中占有shaokun11122的私钥  </li>
</ol>
</blockquote>
</li>
<li><p>再次展示数据,数据修改成功  </p>
<pre><code>cleos -u http://jungle.cryptolions.io:18888  push action shaokun11121 add &apos;{&quot;user&quot;:&quot;shaokun11121&quot;,&quot;msg&quot;:&quot;i am shaokun&quot;}&apos; -p shaokun11121@add
</code></pre></li>
</ul>
<h4 id="eos权限使用心得"><a href="#eos权限使用心得" class="headerlink" title="eos权限使用心得"></a>eos权限使用心得</h4><blockquote>
<ul>
<li>这里只是展示的单个权限的使用在dapp中怎么使用   </li>
<li>如果只看白皮书还是很难理解的,建议通过实际的操作,加深理解吧  </li>
</ul>
</blockquote>
<h4 id="eos权限的进一步思考"><a href="#eos权限的进一步思考" class="headerlink" title="eos权限的进一步思考"></a>eos权限的进一步思考</h4><blockquote>
<ul>
<li>以太坊和eos的多重权限的签名目前我还没遇到过在dapp中实际使用的例子,官方的例子就是基本上是转账需要多个人同意,那么在dapp中如何使用呢?</li>
<li>本课程只展示了阀值为1,权限值为1的active权限,那么如果按照官方例子,如果阈值为2,同时需要两个权限值都为1的账号的active权限来进行某个action的执行呢? </li>
<li>接上一条,如果需要的不是active权限,比如本课中的add权限呢?</li>
</ul>
</blockquote>
<p><a href="https://github.com/shaokun11/eos-permission" target="_blank" rel="noopener">本课源码</a></p>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#51;&#46;&#99;&#111;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/15/基于eos连接scatter开发dapp(下) 续/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/15/基于eos连接scatter开发dapp(下) 续/" itemprop="url">结合scatter 学习eos dapp开发，看这篇就够了（下）续</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-15T20:38:55+08:00">
                2018-11-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="eos智能合约开发-前言"><a href="#eos智能合约开发-前言" class="headerlink" title="eos智能合约开发 前言"></a>eos智能合约开发 前言</h4><p>[学习eos dapp开发，看这篇就够了（下)]<br>(<a href="https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)" target="_blank" rel="noopener">https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)</a>)</p>
<blockquote>
<p>因为有阅读上面这篇文章的同学没看到源码，而我又把之前的源码给删掉了。那我也只好按照我的教程重新写一遍了。本以为copy后就能用，而当时写的时候所使用的旧版的语法，所以改了改，功能不变。<br>本篇文章的代码是使用的cdt1.3.2编译的</p>
</blockquote>
<h4 id="eos智能合约开发-结果展示"><a href="#eos智能合约开发-结果展示" class="headerlink" title="eos智能合约开发 结果展示"></a>eos智能合约开发 结果展示</h4><blockquote>
<p>功能有添加todo,删除todo,和完成todo，具体看图  </p>
</blockquote>
<p><img src="/img_eos1/eos_react7.gif" alt="scatter"></p>
<h4 id="eos智能合约开发-源码展示"><a href="#eos智能合约开发-源码展示" class="headerlink" title="eos智能合约开发 源码展示"></a>eos智能合约开发 源码展示</h4><blockquote>
<p>这就是最简单的页面了，希望你阅读起来不会有任何问题，项目你直接clone下来可以直接运行的  </p>
</blockquote>
<p><a href="https://github.com/shaokun11/eos-todolist" target="_blank" rel="noopener">学习eos dapp开发，看这篇就够了（下）续 源码</a></p>
<p><code>App.js</code></p>
<pre><code>import React, { Component } from &apos;react&apos;;
import &apos;./App.css&apos;;
import ScatterJS from &apos;scatterjs-core&apos;;
import ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;
import Eos from &apos;eosjs&apos;;

ScatterJS.plugins( new ScatterEOS());


const network = {
    blockchain:&apos;eos&apos;,
    protocol:&apos;http&apos;,
    host:&apos;jungle.cryptolions.io&apos;,
    port:18888,
    chainId:&apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;
}

class App extends Component {

   state = {
       deleteId:1,
       rows:[],
       competedId:1,
       scatter:null
  }

    componentDidMount() {
        setTimeout(() =&gt; {
            this.init()
        }, 2000)
    }

    takeAction(action,params){
       console.log(action,params)
        const requiredFields = { accounts:[network] };
        this.state.scatter.getIdentity(requiredFields).then(() =&gt; {
            const account = this.state.scatter.identity.accounts.find(x =&gt; x.blockchain === &apos;eos&apos;);
            console.log(account)
            const eosOptions = { expireInSeconds:60 };
            const eos = this.state.scatter.eos(network,Eos,eosOptions);
            const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };
             eos.contract(&quot;shaokun11113&quot;).then(ins =&gt; {
                return ins[action](account.name, ...params, transactionOptions)
            }).then(res =&gt; {
                console.log(res);
            }).catch(error =&gt; {
                console.error(error);
            });

        }).catch(error =&gt; {
            console.error(&quot;tack action&quot;,error);
        });
    }

    init() {
        ScatterJS.scatter.connect(&apos;todolist&apos;).then(connected =&gt; {
            if(!connected) return false;

            const scatter = ScatterJS.scatter;
            this.setState({
                scatter
            });
            alert(&quot;scatter load success&quot;)
        }).then(err=&gt;{
          console.log(err)
        });
    }

    showTodo(){
        this.state.scatter.eos(network,Eos).getTableRows({code: &quot;shaokun11113&quot;, scope: &quot;shaokun11113&quot;,table: &quot;tood&quot;, json: true})
        .then(res=&gt;{
            this.setState({
                rows:res.rows
            })
        })
    }

    render() {
    return (
        &lt;div&gt;

            &lt;div&gt;
                &lt;button onClick={() =&gt; {
                    const num = Math.floor(Math.random() * 100000);
                    this.takeAction(&quot;create&quot;,[num,&quot;this is number &quot;+num])
                }}&gt;create todo&lt;/button&gt;
                &lt;button onClick={() =&gt; this.takeAction(&quot;destroy&quot;,[this.state.deleteId])}&gt;destroy todo&lt;/button&gt;
                &lt;input type=&quot;text&quot; onChange={e =&gt; {
                    this.setState({
                        deleteId: Number.parseInt(e.target.value)
                    })
                }}/&gt;

                &lt;button onClick={() =&gt; this.takeAction(&quot;complete&quot;,[this.state.competedId])}&gt;complete todo&lt;/button&gt;
                &lt;input type=&quot;text&quot; onChange={e =&gt; {
                    this.setState({
                        competedId: Number.parseInt(e.target.value)
                    })
                }}/&gt;
                &lt;button onClick={() =&gt; this.showTodo()}&gt;show todo&lt;/button&gt;
            &lt;/div&gt;
            &lt;div&gt;
                &lt;p&gt;below is data&lt;/p&gt;
                &lt;ul&gt;
                    {
                        this.state.rows.map((todo, index) =&gt; {
                            return &lt;li key={index}&gt;
                                &lt;p&gt;id : {todo.id}&lt;/p&gt;
                                &lt;p&gt;description : {todo.description}&lt;/p&gt;
                                &lt;p&gt;completed : {todo.completed}&lt;/p&gt;
                            &lt;/li&gt;
                        })
                    }
                &lt;/ul&gt;
            &lt;/div&gt;
        &lt;/div&gt;
    );
  }
}

export default App;
</code></pre><p><code>todolist.cpp</code></p>
<pre><code>include &lt;eosiolib/eosio.hpp&gt;  

using namespace std;

class [[eosio::contract]] todolist : public eosio::contract {  
  public:

  todolist(eosio::name reciever, eosio::name code, eosio::datastream&lt;const char*&gt; ds)
                                                        :contract(reciever,code,ds),
                                                         todos(reciever,code.value){};   


  [[eosio::action]]   
  void create(eosio::name author, const uint32_t id, const string&amp; description) {
    todos.emplace(author, [&amp;](auto &amp;new_todo) {
        new_todo.id = id;
        new_todo.description = description;
        new_todo.completed = 0;
    });
   }

  [[eosio::action]]
  void complete(eosio::name author,const uint32_t id)
  {  
      eosio::require_auth(author);

      auto itr = todos.find(id);
      // 是否用find()方法，去查找这条方法对应的实例
      eosio_assert(itr != todos.end(), &quot;todo does not exit&quot;);
    // 这里 如果找不到，todos.end() 会返回 null
      todos.modify(itr,author,[&amp;](auto &amp;t) {
          t.completed = 1;
      });
  }

  [[eosio::action]]
  void destroy(eosio::name author, const uint32_t id){    
     eosio::require_auth(author);
      auto itr = todos.find(id);
      if(itr != todos.end()){
         todos.erase(itr);
      }
  }

  private:
  struct [[eosio::table]] todo {
      uint64_t id;
      string description;
      uint64_t completed;

      uint64_t primary_key() const {
          return id;
      }
  };

  typedef eosio::multi_index&lt;&quot;tood&quot;_n, todo&gt; todo_index;
  todo_index todos;
};

EOSIO_DISPATCH(todolist, (create)(complete)(destroy))
</code></pre><blockquote>
<ul>
<li>这里有一点要说明，貌似一个账号只能部署一个智能合约，希望这个结论是正确的</li>
<li>上面的todo这个table，由于我的笔误，生成表名的时候写成了 tood,哈哈</li>
<li>合约比较简单了，交互也比较简单，细心点，仔细点，相信你也可以步入eos dapp开发的大门了</li>
</ul>
</blockquote>
<h4 id="eos智能合约开发-总结"><a href="#eos智能合约开发-总结" class="headerlink" title="eos智能合约开发 总结"></a>eos智能合约开发 总结</h4><blockquote>
<ul>
<li>请一定耐心的看完文章，中间漏了一点也会造成失败  </li>
<li>最开始的文章截图使用的分辨率较高，图片显示较大，如若对你阅读造成阅读困难，可以适当缩小页面进行阅读</li>
</ul>
</blockquote>
<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/11/eos dapp开发 官方教程学习7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/11/eos dapp开发 官方教程学习7/" itemprop="url">eos dapp开发学习 第五课</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-11T19:30:46+08:00">
                2018-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<ul>
<li>这次将更新完官方所有的教程，但是不会一一讲解了，因为我也没怎么看懂这个算法，因为这个算法不是我要完成这篇文章的重点，所以感兴趣的同学可以自行探索  </li>
<li>上一篇文章虽然完成了数据上链和读取，但是由于我的大意，有些数据得做调整，具体的可以参考本篇的代码    </li>
<li>更改了前端的显示结构，更加清晰</li>
<li>说说我遇到的坑，以免你犯同样的错误 </li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>坑1==&gt; <code>void playcard(account_name username, uint8_t player_card_idx);</code> 这是官方的方式，当我调用方法正确传参的时候，会出现 <em>player_card_idx</em>这个参数错误，我采取的办法是重命名为 index可解决，至于原因我猜测是大于12个字符了，而且 _ 应该不允许使用  </li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>自己挖的坑1 ==&gt; 困扰了我1天，该打。<br>按照上篇文章的代码，当执行开始的游戏，我的手里牌仅会产生一张，结果是我在定义dict_card的时候，使用copy的方式，所有的类型全部是empty造成  </li>
<li>自己挖的坑2 ==&gt; 困扰了我2天，该打。<br>当我写了endgame的方法，怎么执行都不报错，但是数据就是无法更改进able，后面发现没有加入abi_dispatch中。这是个大坑，简直坑死我了  </li>
<li>自己挖的坑3 ==&gt; 这个是eos issues中看到的<br>当更新合约时，出现这种错误，请使用绝对路径即可<br><img src="/img_eos1/eos12.png" alt="eos"></li>
</ul>
</blockquote>
</blockquote>
<h4 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h4><blockquote>
<p>这里仅做简单展示，想具体玩可以使用去官网玩<br>登录-&gt;开始游戏-&gt;选择手里牌和ai进行对比，进行血量的计算-&gt;再进行下一轮选牌对比，直至谁的life先到达0则为输<br>可以使用endgame 结束这场游戏</p>
</blockquote>
<p><img src="/img_eos1/eos_react6.gif" alt="eos"></p>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>这里只贴了我很仔细写了代码，剩下的代码 计算ai选牌，分数计算是copy官方的</p>
<pre><code>void cardgame::login(eosio::name user)
{
    eosio::require_auth(user);
    auto itr = _users.find(user.value);
    if(itr == _users.end()){
        _users.emplace(get_self(),[&amp;](auto&amp;  row){
                row.name = user;
            });
    } 
    // 否则登录成功
}

void cardgame::startgame(eosio::name user) {
    eosio::require_auth(user);
    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);
    _users.modify(itr, get_self(), [&amp;](auto&amp; row){
        game game_data;
        for(uint8_t i = 0; i &lt; 4; i++){
            draw_card(game_data.deck_player, game_data.hand_player);
            draw_card(game_data.deck_ai, game_data.hand_ai);
        }
        row.game_data = game_data;
    });
}

void cardgame::endgame(eosio::name user) {
    eosio::require_auth(user);
    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);
    _users.modify(itr, get_self(), [&amp;](auto&amp; row){
        row.game_data = game();
    });
}
</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>根据eos官方的elemental battle的dapp开发教程到这里我就简单的结束了，如果你按照第一篇文章来写，应该能够走得到最后，完成编写。</li>
<li>eosio.cdt又更新到1.4了，估计有新的变化，当你按照别人的教程写合约时，请注意版本</li>
<li>上面演示时，可以看到使用eosjs进行与链上的交互很慢，而且有时还会报错，这是因为我的这边的梯子不是很好的原因，所以请不要担心</li>
<li>对于我个人来说，我觉得写合约这块:<ol>
<li>先了解一下其基本的术语，比如account，action，permission</li>
<li>就是增删改查 multi_index，记住这个数据储存的特殊性</li>
<li>知道系统提供的一些特殊的变量和方法，比如“name”_n 和现在的get_self()</li>
<li>合约中一些地方权限的验证，这非常重要。</li>
<li>养成良好的代码风格。</li>
<li>当能够编写基本的合约后，应该思考一下代码的结构，</li>
<li>编写dapp的思想,不能按照传统的应用的模式来编写。而应该根据区块链的特性来编写应用，就例如现在在区块链上运行，储存数据都是需要有费用的。</li>
<li>目前来说，区块链上的由于其特性，相对公平，不容易作假，因为所有的交易历史均可以查询，但前提是你的<strong>智能合约</strong>足够足够安全，而合约毕竟是用代码写的，难免有bug,所以只有多写，多看，多总结了</li>
</ol>
</li>
<li>目前eos的教程有很多版本，语法上面都有改变，即使是目前官方的demo，也有很多歌版本。所以你认准你编译合约的版本，不然你会越写越烦。我这个系列经历了eoiocpp eosio.cdt1.2 eosio1.3.2等等，写着也非常不顺，不过好歹也写完了。  </li>
</ul>
<p><a href="https://github.com/shaokun11/eoslearning/tree/eos-dve5" target="_blank" rel="noopener">第五课源码</a></p>
<h4 id="接下来的计划"><a href="#接下来的计划" class="headerlink" title="接下来的计划"></a>接下来的计划</h4><blockquote>
<p>目前我的文章基本上都是比较简单的demo或者概念性的文章，这样看多了也没有意思，我写着也觉得没有意思了。所以接下来准备找一些具有代表性的基于以太坊，波场和eos合约与大家分享了。</p>
</blockquote>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#115;&#107;&#x75;&#x6e;&#110;&#x79;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#115;&#107;&#x75;&#x6e;&#110;&#x79;&#64;&#49;&#x36;&#x33;&#x2e;&#99;&#111;&#x6d;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/11/09/eos dapp开发 官方教程学习6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="shaokun">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hello shaokun">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/09/eos dapp开发 官方教程学习6/" itemprop="url">eos dapp开发学习 第四课 续</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-09T21:48:45+08:00">
                2018-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>很幸运，总算把新版本的eos和cdt装上了，踩过了很多坑，说多了都是泪。 </p>
<ul>
<li>首先，目前本地我的环境eos1.4 eosio.cdt1.3.2 所以你按照接下来的教程走，那么请核对你的版本</li>
<li>坑1 ==&gt; 如果在原来的账号上部署过类似的table的合约，再次更新合约如果在table中增加修改了字段，能够部署，但是不能够得到得到table的内容和执行action，建议用新的账号进行部署解决</li>
<li>坑2 ==&gt; <a href="https://developers.eos.io/eosio-home/docs/your-first-contract" target="_blank" rel="noopener">helloworld</a>很流畅，一路走下去完美。<a href="https://developers.eos.io/eosio-home/docs/data-persistence" target="_blank" rel="noopener">table数据储存</a>这里不知道知道是我的操作不对还是怎么回事，跟着官网的教程，abi和wasm都能够正常生成，这里合约能够部署上去。但是来了，无法get table，也无法push action。</li>
<li>坑3 ==&gt; 语法变了哈，这里强调一下，支持vector，enume，map 和任何自定义的类型哈，剩下的这个就大家自行琢磨了</li>
<li>坑4 ==&gt; 目前来看，尽量把合code在一个cpp中，不然有想不到的意外等着的哈</li>
</ul>
</blockquote>
<h4 id="合约代码"><a href="#合约代码" class="headerlink" title="合约代码"></a>合约代码</h4><p><code>cardgame.hpp</code></p>
<pre><code>#pragma once
#include &lt;eosiolib/eosio.hpp&gt;
using namespace std;

class [[eosio::contract]]cardgame : public eosio::contract {
  public:
    cardgame(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )
                                :contract(reciever,code,ds),
                                _users(reciever,code.value),
                                _seed(reciever,code.value){};

    [[eosio::action]] void login(eosio::name user);
    [[eosio::action]] void startgame(eosio::name user);
    [[eosio::action]] void playcard(eosio::name user,uint8_t player_card_index);

  private:
    enum game_status:int8_t
    {
      ONGOING = 0,      // 游戏正在进行中
      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利
      PLAYER_LOST = -1 // 游戏结束， 完结失败
    };
    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌
    {
      EMPTY = 0,    // 不存在的卡片
      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张
      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张
      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张
      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 
      VOID = 5      // 平局属性       共计力为0 总共1张
    };

    struct card
    {
      uint8_t type;   // 卡片类型
      uint8_t attack_point; // 卡片的攻击力
    };

    const  map&lt;uint8_t,card&gt; card_dict = {
        {0 , {EMPTY , 0}},
        {1 , {EMPTY , 1}},
        {2 , {EMPTY , 1}},
        {3 , {EMPTY , 2}},
        {4 , {EMPTY , 2}},
        {5 , {EMPTY , 3}},
        {6 , {EMPTY , 1}},
        {7 , {EMPTY , 1}},
        {8 , {EMPTY , 2}},
        {9 , {EMPTY , 2}},
        {10 , {EMPTY , 3}},
        {11 , {EMPTY , 1}},
        {12 , {EMPTY , 1}},
        {13 , {EMPTY , 2}},
        {14 , {EMPTY , 2}},
        {15 , {EMPTY , 3}},
        {16 , {EMPTY , 3}},
        {17 , {EMPTY , 0}},
    };
    struct game
    {
     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行
     int8_t life_player = 5;    // 游戏玩家 5条生命
     int8_t ai_player = 5;      // 游戏玩家 5条生命
     vector&lt;uint8_t&gt;  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id
     vector&lt;uint8_t&gt; deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id
     vector&lt;uint8_t&gt; hand_player = {0,0,0,0}; // 玩家的手里牌
     vector&lt;uint8_t&gt; hand_ai = {0,0,0,0};     // ai的手里牌
     uint8_t selected_card_player = 0;          // 从待选牌中选中的牌
     uint8_t selected_card_ai = 0;              // 从待选牌中选中的牌
    };


      struct [[eosio::table]] userinfo
      {
          eosio::name  name;            
          uint16_t win_count = 0;        
          uint16_t lost_count = 0;
      game game_data;         

          auto primary_key() const {return name.value;}  
      };

    struct [[eosio::table]] seed 
    {
      uint64_t key = 1;
      uint32_t seed_value = 1;

      auto primary_key() const {return key;};
    };

      typedef eosio::multi_index&lt;&quot;userinfo&quot;_n,userinfo&gt; user_index;
    typedef eosio::multi_index&lt;&quot;seed&quot;_n,seed&gt; seed_index;
    user_index _users; //声明表的实例
    seed_index _seed;

  int random(const int range);
  void draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand);
};
</code></pre><p><code>cardgame.cpp</code></p>
<pre><code>#include &quot;cardgame.hpp&quot;

void cardgame::login(eosio::name user)
{
    _users.emplace(get_self(),[&amp;](auto&amp;  u){
            u.name = user;
    });
}

void cardgame::startgame(eosio::name user) {
    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);
    _users.modify(itr,get_self(),[&amp;](auto&amp; _to_modify_user){
        game game_data;
        for(uint8_t i = 0; i &lt; 4; i++){
            draw_card(game_data.deck_player,game_data.hand_player);
            draw_card(game_data.deck_ai,game_data.hand_ai);
        }
        _to_modify_user.game_data = game_data;
    });
}

void cardgame::playcard(eosio::name user, uint8_t player_card_index){
    eosio::require_auth(user);
    eosio_assert(player_card_index &lt; 4,&quot;invalid hand index&quot;);// 手上牌最多四张
    // 通过user找到数据表中数据
    auto&amp; player = _users.get(user.value,&quot;User not exist&quot;);
    eosio_assert(player.game_data.status == ONGOING,&quot;game have ended&quot;);
    eosio_assert(player.game_data.selected_card_player == 0,&quot;the player have selected car in this turn&quot;);
    // 修改数据表
    _users.modify(player,get_self(),[&amp;](auto&amp; _to_modify_user){
        game&amp; game_data = _to_modify_user.game_data;
        // 设定选中的卡片id
        game_data.selected_card_player = game_data.hand_player[player_card_index];
        // 将手中卡片对应位置置位empty
        game_data.hand_player[player_card_index] = 0;
    });
};
int cardgame::random(const int range) {
    auto seed_itr = _seed.begin();
    if (seed_itr  == _seed.end()){    // 如果没有随机数据，就用默认值初始化
        seed_itr = _seed.emplace(get_self(),[&amp;](auto&amp; s){
            s = seed{};
        });
    };
    int prime = 65535;
    int new_seed_value = (seed_itr-&gt;seed_value + now()) % prime;
    _seed.modify(seed_itr,get_self(),[&amp;](auto&amp; s){
            s.seed_value = new_seed_value;
    });
    // 随机范围  0 ~ range
    int random_res = new_seed_value % range;
    return random_res;
};
void cardgame::draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand) {
      int deck_card_idx = random(deck.size());
      int first_empty_slot = -1;
      for (int i = 0; i &lt;= hand.size(); i++) {
          auto id = hand[i];
          if (card_dict.at(id).type == EMPTY) {
              first_empty_slot = i;
              break;
          }
        }
      eosio_assert(first_empty_slot != -1, &quot;No empty slot in the player&apos;s hand&quot;);
      hand[first_empty_slot] = deck[deck_card_idx];
      deck.erase(deck.begin() + deck_card_idx);
 };
EOSIO_DISPATCH(cardgame,(login)(startgame)(playcard))
</code></pre><ul>
<li>由于上面的坑，用shaokun11113是无法正确的，所以我用了shaokun11114进行部署  </li>
<li>终于能够写数据到链上了<img src="/img_eos1/eos11.png" alt="eos">   </li>
<li><a href="https://github.com/shaokun11/eoslearning/tree/eos-dve4-update" target="_blank" rel="noopener">更新的合约源码</a>，这次就没有更新前端的mock数据了，相信聪明的你一定知道怎样调整过来</li>
</ul>
<h4 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  </p>
<p>email: <a href="mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#x36;&#51;&#46;&#99;&#111;&#109;</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">shaokun</p>
              <p class="site-description motion-element" itemprop="description">记录自己对相关技术的点点滴滴和一些思考，希望能够帮助来到这里的你，如果你喜欢我的文章，可以加个微信共同探讨</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">shaokun</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
 <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 访问总量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
