{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/common/wx.png","path":"common/wx.png","modified":1,"renderable":0},{"_id":"source/common/wx_pay.png","path":"common/wx_pay.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos11.png","path":"img_eos1/eos11.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos14.png","path":"img_eos1/eos14.png","modified":1,"renderable":0},{"_id":"source/bancor/bancor.png","path":"bancor/bancor.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos13.png","path":"img_eos1/eos13.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos3.png","path":"img_eos1/eos3.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos7.png","path":"img_eos1/eos7.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos8.png","path":"img_eos1/eos8.png","modified":1,"renderable":0},{"_id":"source/eospermission/per1.png","path":"eospermission/per1.png","modified":1,"renderable":0},{"_id":"source/images/contract1.png","path":"images/contract1.png","modified":1,"renderable":0},{"_id":"source/images/contract14.png","path":"images/contract14.png","modified":1,"renderable":0},{"_id":"source/images/contract16.png","path":"images/contract16.png","modified":1,"renderable":0},{"_id":"source/images/contract3.png","path":"images/contract3.png","modified":1,"renderable":0},{"_id":"source/images/contract2.png","path":"images/contract2.png","modified":1,"renderable":0},{"_id":"source/images/contract4.png","path":"images/contract4.png","modified":1,"renderable":0},{"_id":"source/images/scatter11.png","path":"images/scatter11.png","modified":1,"renderable":0},{"_id":"source/images/scatter12.png","path":"images/scatter12.png","modified":1,"renderable":0},{"_id":"source/images/scatter17.png","path":"images/scatter17.png","modified":1,"renderable":0},{"_id":"source/images/scatter3.png","path":"images/scatter3.png","modified":1,"renderable":0},{"_id":"source/images/scatter5.png","path":"images/scatter5.png","modified":1,"renderable":0},{"_id":"source/images/scatter6.png","path":"images/scatter6.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos12.png","path":"img_eos1/eos12.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos15.png","path":"img_eos1/eos15.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos4.png","path":"img_eos1/eos4.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos5.png","path":"img_eos1/eos5.png","modified":1,"renderable":0},{"_id":"source/images/contract10.png","path":"images/contract10.png","modified":1,"renderable":0},{"_id":"source/images/contract13.png","path":"images/contract13.png","modified":1,"renderable":0},{"_id":"source/images/contract15.png","path":"images/contract15.png","modified":1,"renderable":0},{"_id":"source/images/contract17.png","path":"images/contract17.png","modified":1,"renderable":0},{"_id":"source/images/contract9.png","path":"images/contract9.png","modified":1,"renderable":0},{"_id":"source/images/eosio2.png","path":"images/eosio2.png","modified":1,"renderable":0},{"_id":"source/images/scatter0.png","path":"images/scatter0.png","modified":1,"renderable":0},{"_id":"source/images/scatter1.png","path":"images/scatter1.png","modified":1,"renderable":0},{"_id":"source/images/scatter13.png","path":"images/scatter13.png","modified":1,"renderable":0},{"_id":"source/images/scatter14.png","path":"images/scatter14.png","modified":1,"renderable":0},{"_id":"source/images/scatter15.png","path":"images/scatter15.png","modified":1,"renderable":0},{"_id":"source/images/scatter16.png","path":"images/scatter16.png","modified":1,"renderable":0},{"_id":"source/images/scatter19.png","path":"images/scatter19.png","modified":1,"renderable":0},{"_id":"source/images/scatter20.png","path":"images/scatter20.png","modified":1,"renderable":0},{"_id":"source/images/scatter21.png","path":"images/scatter21.png","modified":1,"renderable":0},{"_id":"source/images/scatter22.png","path":"images/scatter22.png","modified":1,"renderable":0},{"_id":"source/images/scatter23.png","path":"images/scatter23.png","modified":1,"renderable":0},{"_id":"source/images/scatter4.png","path":"images/scatter4.png","modified":1,"renderable":0},{"_id":"source/images/scatter7.png","path":"images/scatter7.png","modified":1,"renderable":0},{"_id":"source/images/scatter9.png","path":"images/scatter9.png","modified":1,"renderable":0},{"_id":"source/img_eos1/eos10.png","path":"img_eos1/eos10.png","modified":1,"renderable":0},{"_id":"source/images/contract5.png","path":"images/contract5.png","modified":1,"renderable":0},{"_id":"source/images/jungle03.png","path":"images/jungle03.png","modified":1,"renderable":0},{"_id":"source/images/jungle2.png","path":"images/jungle2.png","modified":1,"renderable":0},{"_id":"source/images/jungle5.png","path":"images/jungle5.png","modified":1,"renderable":0},{"_id":"source/images/jungle6.png","path":"images/jungle6.png","modified":1,"renderable":0},{"_id":"source/images/scatter10.png","path":"images/scatter10.png","modified":1,"renderable":0},{"_id":"source/images/scatter18.png","path":"images/scatter18.png","modified":1,"renderable":0},{"_id":"source/images/scatter2.png","path":"images/scatter2.png","modified":1,"renderable":0},{"_id":"source/images/contract12.png","path":"images/contract12.png","modified":1,"renderable":0},{"_id":"source/images/scatter8.png","path":"images/scatter8.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"source/img_eos1/eos9.png","path":"img_eos1/eos9.png","modified":1,"renderable":0},{"_id":"source/bancor/bancor_whitepapaer.pdf","path":"bancor/bancor_whitepapaer.pdf","modified":1,"renderable":0},{"_id":"source/images/contract11.png","path":"images/contract11.png","modified":1,"renderable":0},{"_id":"source/images/contract6.png","path":"images/contract6.png","modified":1,"renderable":0},{"_id":"source/images/contract7.png","path":"images/contract7.png","modified":1,"renderable":0},{"_id":"source/images/contract8.png","path":"images/contract8.png","modified":1,"renderable":0},{"_id":"source/images/jungle8.png","path":"images/jungle8.png","modified":1,"renderable":0},{"_id":"source/images/jungle4.png","path":"images/jungle4.png","modified":1,"renderable":0},{"_id":"source/images/jungle7.png","path":"images/jungle7.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"source/img_eos1/eos6.png","path":"img_eos1/eos6.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"source/images/scatter00.png","path":"images/scatter00.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"source/eospermission/per1.gif","path":"eospermission/per1.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"source/img_eos1/eos2.png","path":"img_eos1/eos2.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/img_eos1/eos_react3.gif","path":"img_eos1/eos_react3.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"source/img_eos1/eos_react2.gif","path":"img_eos1/eos_react2.gif","modified":1,"renderable":0},{"_id":"source/eospermission/per3.gif","path":"eospermission/per3.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react7.gif","path":"img_eos1/eos_react7.gif","modified":1,"renderable":0},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"source/img_eos1/eos0.png","path":"img_eos1/eos0.png","modified":1,"renderable":0},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/img_eos1/eos1.png","path":"img_eos1/eos1.png","modified":1,"renderable":0},{"_id":"source/images/eos11.gif","path":"images/eos11.gif","modified":1,"renderable":0},{"_id":"source/eosinline/inline4.gif","path":"eosinline/inline4.gif","modified":1,"renderable":0},{"_id":"source/eospermission/per4.gif","path":"eospermission/per4.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react6.gif","path":"img_eos1/eos_react6.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react4.gif","path":"img_eos1/eos_react4.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react8.gif","path":"img_eos1/eos_react8.gif","modified":1,"renderable":0},{"_id":"source/eospermission/per2.gif","path":"eospermission/per2.gif","modified":1,"renderable":0},{"_id":"source/eosinline/inline2.gif","path":"eosinline/inline2.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_gif_1.gif","path":"img_eos1/eos_gif_1.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react.gif","path":"img_eos1/eos_react.gif","modified":1,"renderable":0},{"_id":"source/images/jungle1.png","path":"images/jungle1.png","modified":1,"renderable":0},{"_id":"source/eosinline/inline1.gif","path":"eosinline/inline1.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react10.gif","path":"img_eos1/eos_react10.gif","modified":1,"renderable":0},{"_id":"source/eosinline/inline3.gif","path":"eosinline/inline3.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react9.gif","path":"img_eos1/eos_react9.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_gif_3.gif","path":"img_eos1/eos_gif_3.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_gif_2.gif","path":"img_eos1/eos_gif_2.gif","modified":1,"renderable":0},{"_id":"source/img_eos1/eos_react5.gif","path":"img_eos1/eos_react5.gif","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"979f2c99fecfee88e96287277c181ffcfe76cbe1","modified":1550899465294},{"_id":"source/_posts/eos dapp开发 官方教程学习1.md","hash":"956c651b021065f88a12deadfbb1b6e85545a0d7","modified":1550495588305},{"_id":"source/_posts/ERC998接口的理解.md","hash":"6101be8d4c15002a6de043c5972385ca38c09a8f","modified":1550495588305},{"_id":"source/_posts/eos dapp开发 官方教程学习2.md","hash":"76cff5b9d794a9188345930308ce960a1c5f41b1","modified":1550495588305},{"_id":"source/_posts/eos dapp开发 官方教程学习3.md","hash":"3f52107fd6cec96b110221c3c3bab6cd20437474","modified":1550495588306},{"_id":"source/_posts/eos dapp开发 官方教程学习4.md","hash":"3d024dcb4c93229e7bedfdb98e4226877aa16368","modified":1550495588306},{"_id":"source/_posts/eos dapp开发 官方教程学习5.md","hash":"e18b454347608df57798e0150b8667b3f492ec01","modified":1550495588306},{"_id":"source/_posts/eos dapp开发 官方教程学习6.md","hash":"f2c0c568ec5c3e22a5f350c7d9330c9c91652797","modified":1550495588306},{"_id":"source/_posts/eos dapp开发 官方教程学习7.md","hash":"de374459ad72cc7c3dbb7debc11b036c54789224","modified":1550495588306},{"_id":"source/_posts/eos 权限的理解.md","hash":"73a3afce8c957a2d07ff4f0fb1731bad62886031","modified":1550495588307},{"_id":"source/_posts/eos中inline action的理解.md","hash":"3be6d88d384b9218b05d357bfab105f4f0a8acf7","modified":1550495588307},{"_id":"source/_posts/eos中inline action的理解3.md","hash":"c15fac78c36a66e23baa1370ca28c51a798cb277","modified":1550495588307},{"_id":"source/_posts/eos中inline action的理解2.md","hash":"ff7319311a8759d040b5da31b4fdd1e38740a281","modified":1550495588307},{"_id":"source/_posts/eosio.token transfer action正确的使用方式.md","hash":"2e51303e9110d3675f936b99f5ef5854bf021d4b","modified":1551446676821},{"_id":"source/_posts/eos中inline action的理解4.md","hash":"39aa898bb74e895e2c2cc2fa87217d6d6d28523e","modified":1550495588307},{"_id":"source/_posts/eos中inline action的理解5.md","hash":"8eb9229bc652a2eaab5b7049628383ae0a2d0b6f","modified":1550495588308},{"_id":"source/_posts/eos中inline action的理解6.md","hash":"5c6686d57bf56eea2671326244cd5caf493950a2","modified":1550495588308},{"_id":"source/_posts/关于bancor的理解.md","hash":"c285c587985620d4090a57371ea6ed964bc40cba","modified":1550495588308},{"_id":"source/_posts/基于eos连接scatter开发dapp(上)--补充 23.18.52.md","hash":"a9336972c28048b59f30a7ef95dde80d27f4e173","modified":1550495588309},{"_id":"source/_posts/基于eos连接scatter开发dapp(下) 续.md","hash":"d45a6149828c23960e6eeafd18e379ad6fae5b29","modified":1550495588309},{"_id":"source/_posts/基于eos连接scatter开发dapp.md","hash":"7c4930d24e0efba1020b556693fbb833eb4cd705","modified":1550495588331},{"_id":"source/_posts/基于eos连接scatter开发dapp(下).md","hash":"8ca19a3bcbfe16711c2181691156bac452e9fc9b","modified":1550495588309},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1550495589468},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1550495589469},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1550495589469},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1550495589470},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1550495589470},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1550495589470},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1550495589470},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1550495589470},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1550495589471},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1550495589471},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1550495589471},{"_id":"themes/next/README.md","hash":"898213e66d34a46c3cf8446bf693bd50db0d3269","modified":1550495589471},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1550495589472},{"_id":"themes/next/_config.yml","hash":"e18b95aa77e04d5e7b0f31ed55d9cc48062ca7b4","modified":1550495589471},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1550495589472},{"_id":"source/_posts/eos测试网发行token.md","hash":"e2f9cf74d21441aa1f6229a7fb10ea47da476f67","modified":1550906881295},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1550495589600},{"_id":"source/common/wx.png","hash":"631858e62c369194c581951d4f779feff8f75a12","modified":1550495588334},{"_id":"source/common/wx_pay.png","hash":"dfdf181324eedddae378ca9055eabfbb2c186b34","modified":1550495588334},{"_id":"source/img_eos1/eos11.png","hash":"882d373d9ca18407b618b59d3634277283e8120c","modified":1550495588507},{"_id":"source/img_eos1/.DS_Store","hash":"bd9fc7c902ad6ae40bc17a706f47015cb3b1292e","modified":1550899855767},{"_id":"source/img_eos1/eos14.png","hash":"cfbc91b89f6ff0c2f581bb4b7efcad66ec93013d","modified":1550495588524},{"_id":"source/bancor/bancor.png","hash":"634a01be0c87ac706af6182b598eb25d6f0447d8","modified":1550495588332},{"_id":"source/img_eos1/eos13.png","hash":"b5cf29dba5eabdb4c0ac4ff67c278b8350b00fe7","modified":1550495588515},{"_id":"source/img_eos1/eos3.png","hash":"eb7c8149ea39b30ed141ca45ae24994d92cb6a8d","modified":1550495588545},{"_id":"source/img_eos1/eos7.png","hash":"0082886da43a17d7b653e308e23dd9aad0b652e5","modified":1550495588549},{"_id":"source/img_eos1/eos8.png","hash":"9466f5e5c361c9481910dbc7864a6f741ddd425f","modified":1550495588550},{"_id":"source/eospermission/per1.png","hash":"31f2b56ad01aa97511e786e5612919b8da0e107a","modified":1550495588421},{"_id":"source/images/contract1.png","hash":"46333e5150be3add8eb00fdec68b691c43bd7b62","modified":1550495588452},{"_id":"source/images/contract14.png","hash":"6efccef5899732e2f8c82c4c050302a43e28f070","modified":1550495588455},{"_id":"source/images/contract16.png","hash":"11d6ab3ac266f9d20b48c29266ad1ee60332be7e","modified":1550495588456},{"_id":"source/images/contract3.png","hash":"0d96f6315267157dfd38f6208d0aaef72f307340","modified":1550495588457},{"_id":"source/images/contract2.png","hash":"eb289fdb8d650830fda73d2b695aa907cebb7cb6","modified":1550495588457},{"_id":"source/images/contract4.png","hash":"5e2290c5c60360e1349ca7eed686555234a94fe0","modified":1550495588457},{"_id":"source/images/scatter11.png","hash":"dc29ae75faf4f10262eb820dba20d49d16168071","modified":1550495588488},{"_id":"source/images/scatter12.png","hash":"20a33872c40d14e9fe416effa3d7d6d4191bb4f0","modified":1550495588488},{"_id":"source/images/scatter17.png","hash":"3bb9d123fe42a43c0eaae52a6ce9f609506d98a1","modified":1550495588492},{"_id":"source/images/scatter3.png","hash":"44d68711a499ff55f3386d2295d5a758b4ed257b","modified":1550495588499},{"_id":"source/images/scatter5.png","hash":"8d9d5635d1b70f9e422c3235da3b45c1fd037e26","modified":1550495588499},{"_id":"source/images/scatter6.png","hash":"a886d5add3655e7296681b004e6707c9b4d86df1","modified":1550495588500},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1550495589469},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1550495589600},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1550495589600},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"352093a1b210c72136687fd2eee649244cee402c","modified":1550495589469},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1550495589469},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1550495589470},{"_id":"source/img_eos1/eos12.png","hash":"e4492a72fc5d5630b40665426f7c1d05159264fa","modified":1550495588512},{"_id":"source/img_eos1/eos15.png","hash":"b9ee221de31be184b91b8cdbf0e8d1915309dcb5","modified":1550495588536},{"_id":"source/img_eos1/eos4.png","hash":"45700ba597fa3029fdcc78f4491bce263e7370bb","modified":1550495588546},{"_id":"source/img_eos1/eos5.png","hash":"abd058820d5f80c2d08e8c6824a0c5a41e7bd39e","modified":1550495588547},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1550495590217},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1550495590217},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1550495590217},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1550495589475},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1550495589580},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1550495589580},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1550495589589},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1550495589589},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1550495589599},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1550495589599},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1550495589599},{"_id":"source/images/contract10.png","hash":"968631c2bea7b031f31089f36d73296546165e5a","modified":1550495588452},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1550495589472},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1550495589472},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1550495589472},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1550495589473},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1550495589473},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1550495589473},{"_id":"source/images/contract13.png","hash":"7365b14f6abf4d8272c9611dd1491d32a706924b","modified":1550495588454},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1550495589473},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1550495589473},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1550495589474},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1550495589474},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1550495589474},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1550495589474},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1550495589474},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1550495589474},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1550495589475},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1550495589475},{"_id":"source/images/contract15.png","hash":"525f414944565b012cefa80e2d8f711f7dc45e79","modified":1550495588455},{"_id":"source/images/contract17.png","hash":"e77677f8c477689e5b9f6c768c197da7406f84f1","modified":1550495588456},{"_id":"source/images/contract9.png","hash":"7892622b7269de6375b41e4621230acd09e9b6b2","modified":1550495588462},{"_id":"source/images/eosio2.png","hash":"dbd8207d0b0628844cc800a6e6b6ef3bd7562f5d","modified":1550495588469},{"_id":"source/images/scatter0.png","hash":"0af4912882258e6db0156015e2e90dd4b3bb140f","modified":1550495588484},{"_id":"source/images/scatter1.png","hash":"90655eca64e14876e1144270ea53b5bd8aa407c1","modified":1550495588487},{"_id":"source/images/scatter13.png","hash":"a0284d7165e0b722a49a3a3377f40b742b1ced19","modified":1550495588489},{"_id":"source/images/scatter14.png","hash":"f3c61239c215007fd840fba4abb1c3dd17f48e18","modified":1550495588491},{"_id":"source/images/scatter15.png","hash":"d0eb576716a1af67da15b9b76ebef3de8c6f9307","modified":1550495588491},{"_id":"source/images/scatter16.png","hash":"0659b646eab84f644b6cd283ac2d3a85316bf468","modified":1550495588492},{"_id":"source/images/scatter19.png","hash":"3dccdccf9143a0e277cc8c5ecf90aee8d43110d0","modified":1550495588494},{"_id":"source/images/scatter20.png","hash":"7048e98f3976ebab7afaddfb0963a5698055249f","modified":1550495588496},{"_id":"source/images/scatter21.png","hash":"0dc9169a3972c305fee11a93a376ae7b29945d53","modified":1550495588496},{"_id":"source/images/scatter22.png","hash":"3c74185120c47d151dcf1f5c268f65c5b02e9a79","modified":1550495588497},{"_id":"source/images/scatter23.png","hash":"336b0ede1a5f3514b2b962c0bf57095b7d5a39d0","modified":1550495588498},{"_id":"source/images/scatter4.png","hash":"2bb29ad9348396eb29edf165d89777af5a2b28ff","modified":1550495588499},{"_id":"source/images/scatter7.png","hash":"dbc0a34db5d0149d2bff1bc47d2135963912dab6","modified":1550495588501},{"_id":"source/images/scatter9.png","hash":"220000746454d8634715bb1607a74eea76999b1e","modified":1550495588502},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589794},{"_id":"source/img_eos1/eos10.png","hash":"e5e6cc1f7a1b054e27bb7e9eccce3d9ccd28942e","modified":1550495588507},{"_id":"source/images/contract5.png","hash":"2ed679296412a144360df3122c2854e4ccc818ca","modified":1550495588458},{"_id":"source/images/jungle03.png","hash":"c2b193a4acc56d6640eed33390c5933163c52f29","modified":1550495588470},{"_id":"source/images/jungle2.png","hash":"d805391a509f8d2d594c129247bd8678926e724d","modified":1550495588476},{"_id":"source/images/jungle5.png","hash":"1e1cec6213d8b48558a8bce66a570e7c00e9bd25","modified":1550495588479},{"_id":"source/images/jungle6.png","hash":"5eb517a0e063271385e77c0e4f991e4d98c46b7f","modified":1550495588480},{"_id":"source/images/scatter10.png","hash":"8da41ecdeaaa405cf10541cd759389fefced5bf1","modified":1550495588488},{"_id":"source/images/scatter18.png","hash":"7f512b1e23db82e287263f4e2f4ad82cfae1b6e0","modified":1550495588493},{"_id":"source/images/scatter2.png","hash":"aa0f3c87bff8a708d02029ad31cacda5fd9866dd","modified":1550495588495},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1550495589612},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1550495589625},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1550495589635},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1550495589635},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1550495589635},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1550495589635},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1550495589635},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1550495589663},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1550495589663},{"_id":"source/images/contract12.png","hash":"172e38a4bb968875468abdb814d81cd592c18c91","modified":1550495588454},{"_id":"source/images/scatter8.png","hash":"a579dec3b651b8e5e5b5fc09e3a88692803564de","modified":1550495588501},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1550495589794},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1550495589795},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1550495589794},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1550495589795},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1550495589795},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1550495589795},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1550495589796},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1550495589796},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1550495589796},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1550495589795},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1550495589796},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1550495589796},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550495589856},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1550495589822},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1550495589869},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1550495589856},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1550495589874},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1550495589873},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1550495589906},{"_id":"source/img_eos1/eos9.png","hash":"0f8494f2a2d47ce278af89af49afca3b48e010c6","modified":1550495588552},{"_id":"source/bancor/bancor_whitepapaer.pdf","hash":"33a0e8d78ccef17adaba0d9df3446c5d466c36c9","modified":1550495588333},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1550495589475},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1550495589475},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1550495589475},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1550495589476},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1550495589476},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1550495589476},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1550495589476},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1550495589476},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1550495589477},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1550495589477},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1550495589477},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1550495589477},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1550495589478},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1550495589478},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1550495589478},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1550495589479},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1550495589479},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1550495589540},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1550495589555},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1550495589555},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1550495589555},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1550495589555},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1550495589555},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1550495589555},{"_id":"source/images/contract11.png","hash":"a972b4c37b1ab8c2d107448126113644154aaab4","modified":1550495588453},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1550495589556},{"_id":"source/images/contract6.png","hash":"a3f5169a33e5ef6ad5a0298e3ff311f44d7b9c8b","modified":1550495588459},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589794},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589794},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589770},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589770},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589771},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589502},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550495589514},{"_id":"source/images/contract7.png","hash":"c01ed17f77bef49b68c6a14a70b31875db74ad41","modified":1550495588460},{"_id":"source/images/contract8.png","hash":"5877aa93aee88c965702bc5f2d01fd7f5553c6f2","modified":1550495588462},{"_id":"source/images/jungle8.png","hash":"964b165a628add82bf7cdd663f7338c0c9e5073b","modified":1550495588483},{"_id":"source/images/jungle4.png","hash":"9efb71603d0846421597c3635067cf9a69293d7c","modified":1550495588478},{"_id":"source/images/jungle7.png","hash":"ddb83d20fee55f903eee4c13a846f6b33be05242","modified":1550495588482},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1550495589770},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1550495589793},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1550495589794},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1550495589794},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1550495589770},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1550495589770},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1550495589944},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1550495589945},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1550495589998},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1550495590035},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1550495590035},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1550495590035},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1550495590035},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1550495590036},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1550495590035},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1550495589942},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1550495590037},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1550495590058},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1550495590058},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1550495590058},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1550495590037},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1550495590059},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1550495590079},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1550495589771},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1550495590079},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1550495590037},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1550495590115},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1550495590079},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1550495590158},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1550495590172},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1550495590206},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1550495590206},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1550495590207},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1550495590214},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1550495590214},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1550495590216},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1550495590216},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1550495590216},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1550495589920},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1550495589920},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1550495589921},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1550495589921},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1550495589920},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1550495589921},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1550495589921},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1550495589921},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1550495589927},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1550495589927},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1550495589938},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1550495590059},{"_id":"source/img_eos1/eos6.png","hash":"90b571090b887d7828fa6d630dbabdf9574d5f8b","modified":1550495588549},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1550495589793},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1550495589989},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1550495589989},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1550495589990},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1550495589990},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1550495589991},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1550495589991},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1550495589991},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1550495589991},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1550495589992},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1550495589477},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1550495589478},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1550495589477},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1550495589479},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1550495589479},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1550495589478},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1550495589479},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1550495589479},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1550495589480},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1550495589478},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1550495589501},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1550495589515},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1550495589569},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1550495589569},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1550495589569},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1550495589569},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1550495589541},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1550495589551},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1550495589551},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"e284b3e4926a001a8a6f0435cc5b991c8c8fa064","modified":1550495589551},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1550495589553},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1550495589552},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1550495589553},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1550495589553},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1550495589553},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1550495589553},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1550495589554},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1550495589555},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1550495589998},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1550495590036},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1550495590036},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1550495590037},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1550495589769},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1550495589769},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1550495589769},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1550495589769},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1550495589769},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1550495589770},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1550495589769},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1550495589705},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1550495589706},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1550495589706},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1550495589718},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1550495589718},{"_id":"source/images/scatter00.png","hash":"604da734617c2c130949a214a52a93750dbf1f1a","modified":1550495588486},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1550495589765},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1550495589940},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1550495589941},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1550495589942},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1550495589771},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1550495589771},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1550495589771},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1550495589772},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1550495589772},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1550495589772},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1550495589772},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1550495589771},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1550495589774},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1550495589792},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1550495589793},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1550495589793},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1550495589793},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1550495589793},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1550495589945},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1550495589946},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1550495589945},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1550495589946},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1550495589980},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1550495589945},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1550495589981},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1550495589981},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1550495590214},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1550495590214},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1550495589946},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1550495589927},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1550495589990},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1550495589990},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1550495589992},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1550495589992},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1550495589993},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1550495589568},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1550495589569},{"_id":"source/eospermission/per1.gif","hash":"f29c7a7ef6c8a98119613910a178f3a7e68ccf2f","modified":1550495588420},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1550495589941},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1550495590215},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1550495589997},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1550495589997},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1550495589719},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1550495589730},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1550495589731},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1550495589731},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1550495589730},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1550495589731},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1550495589764},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1550495589765},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1550495589765},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1550495589765},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1550495589765},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1550495589765},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1550495589766},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1550495589767},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1550495589768},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1550495589746},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1550495589760},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1550495589760},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1550495589760},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1550495589760},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1550495589760},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1550495589761},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1550495589762},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1550495589763},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1550495589763},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1550495589763},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1550495589763},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1550495589763},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1550495589939},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1550495589939},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1550495589939},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1550495589940},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1550495589940},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1550495589759},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1550495589773},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1550495589772},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1550495589774},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1550495589979},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1550495589979},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1550495589979},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1550495589994},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1550495589993},{"_id":"source/img_eos1/eos2.png","hash":"a3def2868f2545d515055f530d2f04f6d67dc138","modified":1550495588544},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1550495589980},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1550495589980},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1550495589980},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1550495589996},{"_id":"source/img_eos1/eos_react3.gif","hash":"a89bc198e8c0a8a4e80040e830fa34be85db1c65","modified":1550495588817},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1550495589944},{"_id":"source/img_eos1/eos_react2.gif","hash":"b15c8fe4c1c7fc7af6bef8954e04c601717c6b21","modified":1550495588813},{"_id":"source/eospermission/per3.gif","hash":"899d192f475989f36c60bf180825680d71e189ba","modified":1550495588440},{"_id":"source/img_eos1/eos_react7.gif","hash":"430176fb3bbb0d4103b5aaa32e028f84ac3691b4","modified":1550495589211},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1550495590213},{"_id":"source/img_eos1/eos0.png","hash":"744efa37022e67124b0a9c85c8aa893ef777dbe8","modified":1550495588504},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1550495589995},{"_id":"source/img_eos1/eos1.png","hash":"519a5ed69c14a3ca239b93a9483ee7783ff41846","modified":1550495588506},{"_id":"source/images/eos11.gif","hash":"d84801d818e447a8da3663702b4f99cd3be5be46","modified":1550495588468},{"_id":"source/eosinline/inline4.gif","hash":"e23895ca417d58125aa9ef03e1b2e2be61ff7aa4","modified":1550495588417},{"_id":"source/eospermission/per4.gif","hash":"602223c6813c313a91ee9c7e7469d09b6f605491","modified":1550495588451},{"_id":"source/img_eos1/eos_react6.gif","hash":"dc8625de9a7d40cdd69f1f4903794c3621f675f5","modified":1550495589207},{"_id":"source/img_eos1/eos_react4.gif","hash":"020de5747f63acbb5bec80acff5f046fe0137f68","modified":1550495588825},{"_id":"source/img_eos1/eos_react8.gif","hash":"0d32a706716142ffae11d2efc7f0b17bfd957724","modified":1550495589223},{"_id":"source/eospermission/per2.gif","hash":"7b1536a1dd65c85e2dae7aae3f4d73dd6b49d259","modified":1550495588436},{"_id":"source/eosinline/inline2.gif","hash":"73fe863d8a8261ead7319c4cd15d17f61a1cd05b","modified":1550495588375},{"_id":"source/img_eos1/eos_gif_1.gif","hash":"a34e3f1120138e7ec6f56b63878147d57cf98aba","modified":1550495588573},{"_id":"source/img_eos1/eos_react.gif","hash":"8c5840843cf3e2d630fececada6186bb7a9f5e1e","modified":1550495588596},{"_id":"source/images/jungle1.png","hash":"8735222765b5f8ef845b57063bc82d0f12d57be5","modified":1550495588475},{"_id":"source/eosinline/inline1.gif","hash":"cfd6093b6f0007600adacabecd010d6452e92e9e","modified":1550495588359},{"_id":"source/img_eos1/eos_react10.gif","hash":"dfba920d3fdc78de56c7407c7e484a3d4c668dab","modified":1550495588807},{"_id":"source/eosinline/inline3.gif","hash":"ef027fdab6f0b73933e584b8890e48f0339db4bb","modified":1550495588409},{"_id":"source/img_eos1/eos_react9.gif","hash":"90ee16065f7369ffce7a165d2c73b943ea246b62","modified":1550495589250},{"_id":"source/img_eos1/eos_gif_3.gif","hash":"6aac14b0ad8af14dc39aba55ad6be23b916db7d0","modified":1550919807124},{"_id":"source/img_eos1/eos_gif_2.gif","hash":"661b9011de13f66f69c4d01c742fec807f2797fc","modified":1550899385787},{"_id":"source/img_eos1/eos_react5.gif","hash":"52e9c494803bd74c68ce8fe6d3bd4921c4c00763","modified":1550495589132},{"_id":"public/archives/page/3/index.html","hash":"c66804a06d90cebc029f1ea8782c09c040115896","modified":1551446708585},{"_id":"public/archives/2018/page/2/index.html","hash":"05fc4e14e1175bed80763be3d7f3a5e55eb7e5cd","modified":1551446708585},{"_id":"public/archives/2018/09/index.html","hash":"7ab1d6e9f613a3916a6ea42b4c37a02f1ae60910","modified":1551446708585},{"_id":"public/archives/2018/10/index.html","hash":"0b369179dd54d9ec80557f6a5067b5742e776ec5","modified":1551446708585},{"_id":"public/archives/2018/11/index.html","hash":"d2929e201aba93a990423e19dbb73d16186fd34f","modified":1551446708585},{"_id":"public/archives/2018/12/index.html","hash":"1b298ae6001be1e646784936c457a820e1d6c5d5","modified":1551446708585},{"_id":"public/archives/2019/index.html","hash":"71d64eb586df17b93084bb1518bb6c3318b838a6","modified":1551446708585},{"_id":"public/archives/2019/01/index.html","hash":"9ada537b150701294ab07cfe093f74a79104d037","modified":1551446708585},{"_id":"public/archives/2019/02/index.html","hash":"ac15a50be7dff415cf225b9417adaeba1bb1446d","modified":1551446708585},{"_id":"public/archives/2019/03/index.html","hash":"96c542ee22e82f54803dbb5d8aeb4b13c28c4642","modified":1551446708585},{"_id":"public/2019/03/02/eosio.token transfer action正确的使用方式/index.html","hash":"317dbf0e1f0a9d3516c3ca598ca8244a420adf3f","modified":1551446708585},{"_id":"public/2019/02/23/eos测试网发行token/index.html","hash":"6489cd37697a3614e9793a3dce7ed5c76a8a529e","modified":1551446708585},{"_id":"public/2019/01/26/eos中inline action的理解6/index.html","hash":"e0a8b8422c005545675e0544ecae4a8093446638","modified":1551446708586},{"_id":"public/2019/01/19/eos中inline action的理解5/index.html","hash":"ccaed1a4bd2ed38e548c2bc90a20970d46feb29a","modified":1551446708586},{"_id":"public/2019/01/12/eos中inline action的理解4/index.html","hash":"7f2cca3ea4fd148cc1a7060c435c3bf5cecc6e64","modified":1551446708586},{"_id":"public/2018/12/08/eos中inline action的理解3/index.html","hash":"2e92019134ddc90372f9e904b05a264a7d11172d","modified":1551446708586},{"_id":"public/2018/12/01/eos中inline action的理解2/index.html","hash":"e419859d2880d3f1f784fe5745cad72e5469da0f","modified":1551446708586},{"_id":"public/2018/11/25/eos中inline action的理解/index.html","hash":"adae8204f3d71ecb7e59586608fe8e216f83b342","modified":1551446708586},{"_id":"public/2018/11/17/eos 权限的理解/index.html","hash":"349207561103f771fe854ad3f054cbdf453bd986","modified":1551446708586},{"_id":"public/2018/11/15/基于eos连接scatter开发dapp(下) 续/index.html","hash":"7678bf0a134a580987f3d4632f4f87965828404c","modified":1551446708586},{"_id":"public/2018/11/11/eos dapp开发 官方教程学习7/index.html","hash":"627cb49ea7caf67b8d7ab9a48041f8e02d224749","modified":1551446708586},{"_id":"public/2018/11/09/eos dapp开发 官方教程学习6/index.html","hash":"057b0485f86ee6eb02aa17bab64b851c6bdadb28","modified":1551446708586},{"_id":"public/2018/11/02/eos dapp开发 官方教程学习5/index.html","hash":"0c203bd843face9194ab5d8c4fcd4de9ef485567","modified":1551446708586},{"_id":"public/2018/10/27/eos dapp开发 官方教程学习4/index.html","hash":"4222180a7ec39002f025312831aa719b4e2c5b2c","modified":1551446708586},{"_id":"public/2018/10/21/eos dapp开发 官方教程学习3/index.html","hash":"9d277a4eff0cf369fba918a7ff5b0c528aa3e514","modified":1551446708586},{"_id":"public/2018/10/20/eos dapp开发 官方教程学习2/index.html","hash":"050bf578e143dca4824ab807e922752a5c13b80a","modified":1551446708586},{"_id":"public/2018/10/20/eos dapp开发 官方教程学习1/index.html","hash":"1be24e920741f2e06f3b9dc0625a6365287e925f","modified":1551446708586},{"_id":"public/2018/10/14/基于eos连接scatter开发dapp(下)/index.html","hash":"1b3b4c8cbf2194e59b1afaa596b42fd57cb2241a","modified":1551446708586},{"_id":"public/2018/10/13/基于eos连接scatter开发dapp/index.html","hash":"452ff6d1248ddf6765f439e7b7856085a465d94d","modified":1551446708586},{"_id":"public/2018/10/02/关于bancor的理解/index.html","hash":"f3022809c488bbadf7b890c98db58a37dc0d1b91","modified":1551446708587},{"_id":"public/2018/09/19/ERC998接口的理解/index.html","hash":"b2b180a35cd797bca137933c4f7ef42a01d0ae89","modified":1551446708587},{"_id":"public/archives/index.html","hash":"4de1a02616842a22db30454e969fd9931b9e2d03","modified":1551446708587},{"_id":"public/archives/page/2/index.html","hash":"cfe670b3447c4e37410552c9047490a7e1811cd8","modified":1551446708587},{"_id":"public/archives/2018/index.html","hash":"56f0aa2441df6e05b344030d8d0962170078968c","modified":1551446708587},{"_id":"public/index.html","hash":"c6290cdbc6d9fb3deafe8d5a8763a743e177f1cc","modified":1551446708587},{"_id":"public/page/2/index.html","hash":"8cdbc55fd5052bde28a203e72b5c8fdd94f2842d","modified":1551446708587},{"_id":"public/page/3/index.html","hash":"46e4202fcf0785eec4715e49774ca5fd24ad8c4d","modified":1551446708587},{"_id":"public/2018/10/13/基于eos连接scatter开发dapp(上)--补充 23.18.52/index.html","hash":"6e2daa5fa7a165c9b6220c3507f728e98b0ac7df","modified":1551446708588},{"_id":"public/common/wx_pay.png","hash":"dfdf181324eedddae378ca9055eabfbb2c186b34","modified":1551446708588},{"_id":"public/img_eos1/eos11.png","hash":"882d373d9ca18407b618b59d3634277283e8120c","modified":1551446708588},{"_id":"public/img_eos1/eos14.png","hash":"cfbc91b89f6ff0c2f581bb4b7efcad66ec93013d","modified":1551446708588},{"_id":"public/images/contract1.png","hash":"46333e5150be3add8eb00fdec68b691c43bd7b62","modified":1551446708588},{"_id":"public/images/contract14.png","hash":"6efccef5899732e2f8c82c4c050302a43e28f070","modified":1551446708588},{"_id":"public/images/contract16.png","hash":"11d6ab3ac266f9d20b48c29266ad1ee60332be7e","modified":1551446708588},{"_id":"public/images/contract3.png","hash":"0d96f6315267157dfd38f6208d0aaef72f307340","modified":1551446708588},{"_id":"public/images/contract2.png","hash":"eb289fdb8d650830fda73d2b695aa907cebb7cb6","modified":1551446708588},{"_id":"public/images/contract4.png","hash":"5e2290c5c60360e1349ca7eed686555234a94fe0","modified":1551446708589},{"_id":"public/images/scatter11.png","hash":"dc29ae75faf4f10262eb820dba20d49d16168071","modified":1551446708589},{"_id":"public/images/scatter12.png","hash":"20a33872c40d14e9fe416effa3d7d6d4191bb4f0","modified":1551446708589},{"_id":"public/images/scatter17.png","hash":"3bb9d123fe42a43c0eaae52a6ce9f609506d98a1","modified":1551446708589},{"_id":"public/images/scatter3.png","hash":"44d68711a499ff55f3386d2295d5a758b4ed257b","modified":1551446708589},{"_id":"public/images/scatter6.png","hash":"a886d5add3655e7296681b004e6707c9b4d86df1","modified":1551446708589},{"_id":"public/images/scatter5.png","hash":"8d9d5635d1b70f9e422c3235da3b45c1fd037e26","modified":1551446708589},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1551446708589},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1551446708589},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551446708589},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1551446708589},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1551446708589},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1551446708589},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1551446708589},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1551446708589},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551446708589},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1551446708589},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551446708589},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551446708589},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551446708590},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551446708590},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1551446708590},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1551446708590},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1551446708590},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551446708590},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1551446708638},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1551446708638},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1551446708663},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1551446708664},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1551446708664},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1551446708664},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1551446708664},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1551446708666},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1551446708692},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1551446708694},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1551446708694},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1551446708694},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1551446708694},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1551446708694},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1551446708694},{"_id":"public/common/wx.png","hash":"631858e62c369194c581951d4f779feff8f75a12","modified":1551446708858},{"_id":"public/img_eos1/eos7.png","hash":"0082886da43a17d7b653e308e23dd9aad0b652e5","modified":1551446708858},{"_id":"public/img_eos1/eos8.png","hash":"9466f5e5c361c9481910dbc7864a6f741ddd425f","modified":1551446708858},{"_id":"public/img_eos1/eos3.png","hash":"eb7c8149ea39b30ed141ca45ae24994d92cb6a8d","modified":1551446710678},{"_id":"public/eospermission/per1.png","hash":"31f2b56ad01aa97511e786e5612919b8da0e107a","modified":1551446710680},{"_id":"public/img_eos1/eos13.png","hash":"b5cf29dba5eabdb4c0ac4ff67c278b8350b00fe7","modified":1551446710682},{"_id":"public/bancor/bancor.png","hash":"634a01be0c87ac706af6182b598eb25d6f0447d8","modified":1551446710682},{"_id":"public/images/contract10.png","hash":"968631c2bea7b031f31089f36d73296546165e5a","modified":1551446710682},{"_id":"public/images/contract13.png","hash":"7365b14f6abf4d8272c9611dd1491d32a706924b","modified":1551446710682},{"_id":"public/images/contract15.png","hash":"525f414944565b012cefa80e2d8f711f7dc45e79","modified":1551446710682},{"_id":"public/images/contract17.png","hash":"e77677f8c477689e5b9f6c768c197da7406f84f1","modified":1551446710682},{"_id":"public/images/scatter13.png","hash":"a0284d7165e0b722a49a3a3377f40b742b1ced19","modified":1551446710682},{"_id":"public/images/scatter15.png","hash":"d0eb576716a1af67da15b9b76ebef3de8c6f9307","modified":1551446710682},{"_id":"public/images/scatter14.png","hash":"f3c61239c215007fd840fba4abb1c3dd17f48e18","modified":1551446710682},{"_id":"public/images/contract9.png","hash":"7892622b7269de6375b41e4621230acd09e9b6b2","modified":1551446710683},{"_id":"public/images/scatter0.png","hash":"0af4912882258e6db0156015e2e90dd4b3bb140f","modified":1551446710683},{"_id":"public/images/scatter1.png","hash":"90655eca64e14876e1144270ea53b5bd8aa407c1","modified":1551446710683},{"_id":"public/images/scatter16.png","hash":"0659b646eab84f644b6cd283ac2d3a85316bf468","modified":1551446710683},{"_id":"public/images/scatter19.png","hash":"3dccdccf9143a0e277cc8c5ecf90aee8d43110d0","modified":1551446710683},{"_id":"public/images/scatter20.png","hash":"7048e98f3976ebab7afaddfb0963a5698055249f","modified":1551446710683},{"_id":"public/images/eosio2.png","hash":"dbd8207d0b0628844cc800a6e6b6ef3bd7562f5d","modified":1551446710683},{"_id":"public/images/scatter21.png","hash":"0dc9169a3972c305fee11a93a376ae7b29945d53","modified":1551446710684},{"_id":"public/images/scatter22.png","hash":"3c74185120c47d151dcf1f5c268f65c5b02e9a79","modified":1551446710684},{"_id":"public/images/scatter23.png","hash":"336b0ede1a5f3514b2b962c0bf57095b7d5a39d0","modified":1551446710684},{"_id":"public/images/scatter4.png","hash":"2bb29ad9348396eb29edf165d89777af5a2b28ff","modified":1551446710684},{"_id":"public/images/scatter7.png","hash":"dbc0a34db5d0149d2bff1bc47d2135963912dab6","modified":1551446710684},{"_id":"public/images/scatter9.png","hash":"220000746454d8634715bb1607a74eea76999b1e","modified":1551446710684},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1551446710700},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1551446710703},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1551446710704},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1551446710705},{"_id":"public/css/main.css","hash":"44cb129bb6de15a88c728d4fdceefba43f744e6e","modified":1551446710705},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551446710705},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551446710705},{"_id":"public/img_eos1/eos5.png","hash":"abd058820d5f80c2d08e8c6824a0c5a41e7bd39e","modified":1551446710705},{"_id":"public/images/contract5.png","hash":"2ed679296412a144360df3122c2854e4ccc818ca","modified":1551446710705},{"_id":"public/images/scatter8.png","hash":"a579dec3b651b8e5e5b5fc09e3a88692803564de","modified":1551446710705},{"_id":"public/images/jungle5.png","hash":"1e1cec6213d8b48558a8bce66a570e7c00e9bd25","modified":1551446710705},{"_id":"public/images/scatter18.png","hash":"7f512b1e23db82e287263f4e2f4ad82cfae1b6e0","modified":1551446710705},{"_id":"public/images/scatter10.png","hash":"8da41ecdeaaa405cf10541cd759389fefced5bf1","modified":1551446710705},{"_id":"public/images/contract11.png","hash":"a972b4c37b1ab8c2d107448126113644154aaab4","modified":1551446710705},{"_id":"public/images/contract6.png","hash":"a3f5169a33e5ef6ad5a0298e3ff311f44d7b9c8b","modified":1551446710706},{"_id":"public/images/contract12.png","hash":"172e38a4bb968875468abdb814d81cd592c18c91","modified":1551446710706},{"_id":"public/images/contract7.png","hash":"c01ed17f77bef49b68c6a14a70b31875db74ad41","modified":1551446710706},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1551446710713},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1551446710713},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1551446710714},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1551446710714},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1551446710714},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1551446710715},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1551446710715},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1551446710715},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1551446710715},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1551446710715},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1551446710715},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1551446710715},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1551446710715},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1551446710715},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1551446710715},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1551446710715},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1551446710715},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1551446710715},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1551446710715},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1551446710715},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1551446710715},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1551446710715},{"_id":"public/images/jungle8.png","hash":"964b165a628add82bf7cdd663f7338c0c9e5073b","modified":1551446710715},{"_id":"public/img_eos1/eos12.png","hash":"e4492a72fc5d5630b40665426f7c1d05159264fa","modified":1551446710715},{"_id":"public/img_eos1/eos4.png","hash":"45700ba597fa3029fdcc78f4491bce263e7370bb","modified":1551446710715},{"_id":"public/images/jungle03.png","hash":"c2b193a4acc56d6640eed33390c5933163c52f29","modified":1551446710716},{"_id":"public/images/jungle6.png","hash":"5eb517a0e063271385e77c0e4f991e4d98c46b7f","modified":1551446710716},{"_id":"public/images/jungle2.png","hash":"d805391a509f8d2d594c129247bd8678926e724d","modified":1551446710716},{"_id":"public/images/contract8.png","hash":"5877aa93aee88c965702bc5f2d01fd7f5553c6f2","modified":1551446710716},{"_id":"public/bancor/bancor_whitepapaer.pdf","hash":"33a0e8d78ccef17adaba0d9df3446c5d466c36c9","modified":1551446710716},{"_id":"public/img_eos1/eos9.png","hash":"0f8494f2a2d47ce278af89af49afca3b48e010c6","modified":1551446710716},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1551446710717},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1551446710718},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1551446710718},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1551446710718},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1551446710718},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1551446710718},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1551446710718},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1551446710718},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1551446710718},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1551446710718},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1551446710718},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1551446710718},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1551446710718},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1551446710718},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1551446710718},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1551446710727},{"_id":"public/img_eos1/eos15.png","hash":"b9ee221de31be184b91b8cdbf0e8d1915309dcb5","modified":1551446710739},{"_id":"public/images/scatter2.png","hash":"aa0f3c87bff8a708d02029ad31cacda5fd9866dd","modified":1551446710739},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1551446710739},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551446710739},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1551446710742},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1551446710742},{"_id":"public/img_eos1/eos10.png","hash":"e5e6cc1f7a1b054e27bb7e9eccce3d9ccd28942e","modified":1551446710742},{"_id":"public/images/jungle7.png","hash":"ddb83d20fee55f903eee4c13a846f6b33be05242","modified":1551446710819},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1551446710823},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1551446710823},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1551446710823},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1551446710823},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1551446710823},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1551446710823},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1551446710823},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1551446711064},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1551446711064},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1551446711064},{"_id":"public/images/jungle4.png","hash":"9efb71603d0846421597c3635067cf9a69293d7c","modified":1551446711128},{"_id":"public/img_eos1/eos6.png","hash":"90b571090b887d7828fa6d630dbabdf9574d5f8b","modified":1551446711128},{"_id":"public/images/scatter00.png","hash":"604da734617c2c130949a214a52a93750dbf1f1a","modified":1551446711128},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1551446711136},{"_id":"public/img_eos1/eos2.png","hash":"a3def2868f2545d515055f530d2f04f6d67dc138","modified":1551446711537},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1551446711564},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1551446711661},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1551446711663},{"_id":"public/img_eos1/eos1.png","hash":"519a5ed69c14a3ca239b93a9483ee7783ff41846","modified":1551446711674},{"_id":"public/eospermission/per1.gif","hash":"f29c7a7ef6c8a98119613910a178f3a7e68ccf2f","modified":1551446711681},{"_id":"public/img_eos1/eos_react3.gif","hash":"a89bc198e8c0a8a4e80040e830fa34be85db1c65","modified":1551446711683},{"_id":"public/eospermission/per3.gif","hash":"899d192f475989f36c60bf180825680d71e189ba","modified":1551446711690},{"_id":"public/img_eos1/eos_react2.gif","hash":"b15c8fe4c1c7fc7af6bef8954e04c601717c6b21","modified":1551446711824},{"_id":"public/eosinline/inline4.gif","hash":"e23895ca417d58125aa9ef03e1b2e2be61ff7aa4","modified":1551446711826},{"_id":"public/img_eos1/eos0.png","hash":"744efa37022e67124b0a9c85c8aa893ef777dbe8","modified":1551446711826},{"_id":"public/img_eos1/eos_react7.gif","hash":"430176fb3bbb0d4103b5aaa32e028f84ac3691b4","modified":1551446711830},{"_id":"public/images/eos11.gif","hash":"d84801d818e447a8da3663702b4f99cd3be5be46","modified":1551446711830},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1551446711858},{"_id":"public/eospermission/per4.gif","hash":"602223c6813c313a91ee9c7e7469d09b6f605491","modified":1551446711858},{"_id":"public/img_eos1/eos_react6.gif","hash":"dc8625de9a7d40cdd69f1f4903794c3621f675f5","modified":1551446711861},{"_id":"public/img_eos1/eos_react8.gif","hash":"0d32a706716142ffae11d2efc7f0b17bfd957724","modified":1551446711864},{"_id":"public/img_eos1/eos_react4.gif","hash":"020de5747f63acbb5bec80acff5f046fe0137f68","modified":1551446711868},{"_id":"public/images/jungle1.png","hash":"8735222765b5f8ef845b57063bc82d0f12d57be5","modified":1551446711879},{"_id":"public/eospermission/per2.gif","hash":"7b1536a1dd65c85e2dae7aae3f4d73dd6b49d259","modified":1551446711884},{"_id":"public/eosinline/inline2.gif","hash":"73fe863d8a8261ead7319c4cd15d17f61a1cd05b","modified":1551446711892},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1551446711929},{"_id":"public/img_eos1/eos_gif_1.gif","hash":"a34e3f1120138e7ec6f56b63878147d57cf98aba","modified":1551446711953},{"_id":"public/eosinline/inline1.gif","hash":"cfd6093b6f0007600adacabecd010d6452e92e9e","modified":1551446711957},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1551446711962},{"_id":"public/img_eos1/eos_react.gif","hash":"8c5840843cf3e2d630fececada6186bb7a9f5e1e","modified":1551446711962},{"_id":"public/img_eos1/eos_react9.gif","hash":"90ee16065f7369ffce7a165d2c73b943ea246b62","modified":1551446712262},{"_id":"public/img_eos1/eos_react10.gif","hash":"dfba920d3fdc78de56c7407c7e484a3d4c668dab","modified":1551446712317},{"_id":"public/eosinline/inline3.gif","hash":"ef027fdab6f0b73933e584b8890e48f0339db4bb","modified":1551446712330},{"_id":"public/img_eos1/eos_gif_3.gif","hash":"6aac14b0ad8af14dc39aba55ad6be23b916db7d0","modified":1551446712448},{"_id":"public/img_eos1/eos_react5.gif","hash":"52e9c494803bd74c68ce8fe6d3bd4921c4c00763","modified":1551446712500},{"_id":"public/img_eos1/eos_gif_2.gif","hash":"661b9011de13f66f69c4d01c742fec807f2797fc","modified":1551446712527}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"eos dapp开发学习 第一课","date":"2018-10-20T00:47:47.000Z","_content":"##### 前言\n> 没想到block one就在10/19放出了一个官方的教程，教程内容很详细，比我上周的详细很多呢，包括语法，逻辑，代码的封装。那么接下来当然也要跟着一步一步的来学一下。  \n[elemental battles](https://battles.eos.io) 我这边貌似不用梯子也能进入的哈。\n>> 这里请注意一点，之前的两篇文章使用的是是使用的当前官网的步骤，使用的eosio.cdt1.2进行wasm和abi的，而现在github是最新的1.3版本，语法变化很多，更加规范。   \n>> 而目前的这个教程使用的最开始的方法，所以为了一致，也会使用最古老的方式进行学习，保持统一。综合来看，整体开发dapp的流程和思想是一致的，新版本的只是语法有变化。\n即整篇采用eos1.2的这个文档 [eosio1.2](https://developers.eos.io/eosio-cpp/v1.2.0/docs) \n![elemental battles cover](/img_eos1/eos1.png)  \n![elemental battles cover](/img_eos1/eos0.png)  \n为了我自己不糊涂，再啰嗦一遍。建议生产中使用新版本  \n \n*  eosio1.2包含了生成.wasm和abi的工具eosiocpp  \n*  eoscdt1.2是单独的一个插件，更加专业，专门用于生成上述两个文件，使用eosio-cpp\n*  eoscdt1.3是1.2的升级版，规范了语法优化了很多\n\n##### 准备阶段\n![目录](/img_eos1/eos2.png)\n> 需要自己注册一个账号哈\n\n可以看到，总共九个大的章节，第0章节介绍了eosio，然后指导安装eosio。这个安装和之前的步骤一样，在此就不啰嗦了。\n\n#### step 1\n1. 新建三个c++文件,注意命名规则\n\t\n\t\tcardgame.hpp  // 定义智能合约的C ++头文件\n\t\tcardgame.cpp  // 用于实现智能合约的操作的C++源文件。\n\t\tgameplay.cpp  // 包含智能合约中使用的内部帮助函数的C++源文件。\n\t\t\n![文件结构1](/img_eos1/eos3.png)\n> \n* 账户名只能包含字符.abcdefghijklmnopqrstuvwxyz12345。 a-z（小写），1-5和. （英文句点)，必须以字母开头必须为12个字符\n* 表名，结构，函数，类最多只能包含12个字母字符\n* 符号必须是A和Z之间的大写字母字符必须是7个字符或更少\n\n#### step 2\n\n使用create-react-app 创建web项目，并移除其中不需要的文件  \n![文件结构2](/img_eos1/eos4.png)\n\n#### 结尾\n额，第0课和第一课就到这里结束了，可以看到和我们之前的流程是类似的。同样需要你掌握web和c++的知识，这些知识点都可以通过网络找到，需要自己积累。  \n第0课主要讲解了eosio开发环境的搭建，自备梯子很重要  \n第1课主要讲解的整个项目的结构\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习1.md","raw":"---\ntitle: eos dapp开发学习 第一课\ndate: 2018-10-20 08:47:47\n---\n##### 前言\n> 没想到block one就在10/19放出了一个官方的教程，教程内容很详细，比我上周的详细很多呢，包括语法，逻辑，代码的封装。那么接下来当然也要跟着一步一步的来学一下。  \n[elemental battles](https://battles.eos.io) 我这边貌似不用梯子也能进入的哈。\n>> 这里请注意一点，之前的两篇文章使用的是是使用的当前官网的步骤，使用的eosio.cdt1.2进行wasm和abi的，而现在github是最新的1.3版本，语法变化很多，更加规范。   \n>> 而目前的这个教程使用的最开始的方法，所以为了一致，也会使用最古老的方式进行学习，保持统一。综合来看，整体开发dapp的流程和思想是一致的，新版本的只是语法有变化。\n即整篇采用eos1.2的这个文档 [eosio1.2](https://developers.eos.io/eosio-cpp/v1.2.0/docs) \n![elemental battles cover](/img_eos1/eos1.png)  \n![elemental battles cover](/img_eos1/eos0.png)  \n为了我自己不糊涂，再啰嗦一遍。建议生产中使用新版本  \n \n*  eosio1.2包含了生成.wasm和abi的工具eosiocpp  \n*  eoscdt1.2是单独的一个插件，更加专业，专门用于生成上述两个文件，使用eosio-cpp\n*  eoscdt1.3是1.2的升级版，规范了语法优化了很多\n\n##### 准备阶段\n![目录](/img_eos1/eos2.png)\n> 需要自己注册一个账号哈\n\n可以看到，总共九个大的章节，第0章节介绍了eosio，然后指导安装eosio。这个安装和之前的步骤一样，在此就不啰嗦了。\n\n#### step 1\n1. 新建三个c++文件,注意命名规则\n\t\n\t\tcardgame.hpp  // 定义智能合约的C ++头文件\n\t\tcardgame.cpp  // 用于实现智能合约的操作的C++源文件。\n\t\tgameplay.cpp  // 包含智能合约中使用的内部帮助函数的C++源文件。\n\t\t\n![文件结构1](/img_eos1/eos3.png)\n> \n* 账户名只能包含字符.abcdefghijklmnopqrstuvwxyz12345。 a-z（小写），1-5和. （英文句点)，必须以字母开头必须为12个字符\n* 表名，结构，函数，类最多只能包含12个字母字符\n* 符号必须是A和Z之间的大写字母字符必须是7个字符或更少\n\n#### step 2\n\n使用create-react-app 创建web项目，并移除其中不需要的文件  \n![文件结构2](/img_eos1/eos4.png)\n\n#### 结尾\n额，第0课和第一课就到这里结束了，可以看到和我们之前的流程是类似的。同样需要你掌握web和c++的知识，这些知识点都可以通过网络找到，需要自己积累。  \n第0课主要讲解了eosio开发环境的搭建，自备梯子很重要  \n第1课主要讲解的整个项目的结构\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习1","published":1,"updated":"2019-02-18T13:13:08.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b5110000nh7s58v6xb34","content":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><blockquote>\n<p>没想到block one就在10/19放出了一个官方的教程，教程内容很详细，比我上周的详细很多呢，包括语法，逻辑，代码的封装。那么接下来当然也要跟着一步一步的来学一下。<br><a href=\"https://battles.eos.io\" target=\"_blank\" rel=\"noopener\">elemental battles</a> 我这边貌似不用梯子也能进入的哈。</p>\n<blockquote>\n<p>这里请注意一点，之前的两篇文章使用的是是使用的当前官网的步骤，使用的eosio.cdt1.2进行wasm和abi的，而现在github是最新的1.3版本，语法变化很多，更加规范。<br>而目前的这个教程使用的最开始的方法，所以为了一致，也会使用最古老的方式进行学习，保持统一。综合来看，整体开发dapp的流程和思想是一致的，新版本的只是语法有变化。<br>即整篇采用eos1.2的这个文档 <a href=\"https://developers.eos.io/eosio-cpp/v1.2.0/docs\" target=\"_blank\" rel=\"noopener\">eosio1.2</a><br><img src=\"/img_eos1/eos1.png\" alt=\"elemental battles cover\"><br><img src=\"/img_eos1/eos0.png\" alt=\"elemental battles cover\"><br>为了我自己不糊涂，再啰嗦一遍。建议生产中使用新版本  </p>\n</blockquote>\n</blockquote>\n<ul>\n<li>eosio1.2包含了生成.wasm和abi的工具eosiocpp  </li>\n<li>eoscdt1.2是单独的一个插件，更加专业，专门用于生成上述两个文件，使用eosio-cpp</li>\n<li>eoscdt1.3是1.2的升级版，规范了语法优化了很多</li>\n</ul>\n<h5 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h5><p><img src=\"/img_eos1/eos2.png\" alt=\"目录\"></p>\n<blockquote>\n<p>需要自己注册一个账号哈</p>\n</blockquote>\n<p>可以看到，总共九个大的章节，第0章节介绍了eosio，然后指导安装eosio。这个安装和之前的步骤一样，在此就不啰嗦了。</p>\n<h4 id=\"step-1\"><a href=\"#step-1\" class=\"headerlink\" title=\"step 1\"></a>step 1</h4><ol>\n<li><p>新建三个c++文件,注意命名规则</p>\n<pre><code>cardgame.hpp  // 定义智能合约的C ++头文件\ncardgame.cpp  // 用于实现智能合约的操作的C++源文件。\ngameplay.cpp  // 包含智能合约中使用的内部帮助函数的C++源文件。\n</code></pre></li>\n</ol>\n<p><img src=\"/img_eos1/eos3.png\" alt=\"文件结构1\"></p>\n<blockquote>\n</blockquote>\n<ul>\n<li>账户名只能包含字符.abcdefghijklmnopqrstuvwxyz12345。 a-z（小写），1-5和. （英文句点)，必须以字母开头必须为12个字符</li>\n<li>表名，结构，函数，类最多只能包含12个字母字符</li>\n<li>符号必须是A和Z之间的大写字母字符必须是7个字符或更少</li>\n</ul>\n<h4 id=\"step-2\"><a href=\"#step-2\" class=\"headerlink\" title=\"step 2\"></a>step 2</h4><p>使用create-react-app 创建web项目，并移除其中不需要的文件<br><img src=\"/img_eos1/eos4.png\" alt=\"文件结构2\"></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>额，第0课和第一课就到这里结束了，可以看到和我们之前的流程是类似的。同样需要你掌握web和c++的知识，这些知识点都可以通过网络找到，需要自己积累。<br>第0课主要讲解了eosio开发环境的搭建，自备梯子很重要<br>第1课主要讲解的整个项目的结构</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#105;&#110;&#103;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#105;&#110;&#103;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h5><blockquote>\n<p>没想到block one就在10/19放出了一个官方的教程，教程内容很详细，比我上周的详细很多呢，包括语法，逻辑，代码的封装。那么接下来当然也要跟着一步一步的来学一下。<br><a href=\"https://battles.eos.io\" target=\"_blank\" rel=\"noopener\">elemental battles</a> 我这边貌似不用梯子也能进入的哈。</p>\n<blockquote>\n<p>这里请注意一点，之前的两篇文章使用的是是使用的当前官网的步骤，使用的eosio.cdt1.2进行wasm和abi的，而现在github是最新的1.3版本，语法变化很多，更加规范。<br>而目前的这个教程使用的最开始的方法，所以为了一致，也会使用最古老的方式进行学习，保持统一。综合来看，整体开发dapp的流程和思想是一致的，新版本的只是语法有变化。<br>即整篇采用eos1.2的这个文档 <a href=\"https://developers.eos.io/eosio-cpp/v1.2.0/docs\" target=\"_blank\" rel=\"noopener\">eosio1.2</a><br><img src=\"/img_eos1/eos1.png\" alt=\"elemental battles cover\"><br><img src=\"/img_eos1/eos0.png\" alt=\"elemental battles cover\"><br>为了我自己不糊涂，再啰嗦一遍。建议生产中使用新版本  </p>\n</blockquote>\n</blockquote>\n<ul>\n<li>eosio1.2包含了生成.wasm和abi的工具eosiocpp  </li>\n<li>eoscdt1.2是单独的一个插件，更加专业，专门用于生成上述两个文件，使用eosio-cpp</li>\n<li>eoscdt1.3是1.2的升级版，规范了语法优化了很多</li>\n</ul>\n<h5 id=\"准备阶段\"><a href=\"#准备阶段\" class=\"headerlink\" title=\"准备阶段\"></a>准备阶段</h5><p><img src=\"/img_eos1/eos2.png\" alt=\"目录\"></p>\n<blockquote>\n<p>需要自己注册一个账号哈</p>\n</blockquote>\n<p>可以看到，总共九个大的章节，第0章节介绍了eosio，然后指导安装eosio。这个安装和之前的步骤一样，在此就不啰嗦了。</p>\n<h4 id=\"step-1\"><a href=\"#step-1\" class=\"headerlink\" title=\"step 1\"></a>step 1</h4><ol>\n<li><p>新建三个c++文件,注意命名规则</p>\n<pre><code>cardgame.hpp  // 定义智能合约的C ++头文件\ncardgame.cpp  // 用于实现智能合约的操作的C++源文件。\ngameplay.cpp  // 包含智能合约中使用的内部帮助函数的C++源文件。\n</code></pre></li>\n</ol>\n<p><img src=\"/img_eos1/eos3.png\" alt=\"文件结构1\"></p>\n<blockquote>\n</blockquote>\n<ul>\n<li>账户名只能包含字符.abcdefghijklmnopqrstuvwxyz12345。 a-z（小写），1-5和. （英文句点)，必须以字母开头必须为12个字符</li>\n<li>表名，结构，函数，类最多只能包含12个字母字符</li>\n<li>符号必须是A和Z之间的大写字母字符必须是7个字符或更少</li>\n</ul>\n<h4 id=\"step-2\"><a href=\"#step-2\" class=\"headerlink\" title=\"step 2\"></a>step 2</h4><p>使用create-react-app 创建web项目，并移除其中不需要的文件<br><img src=\"/img_eos1/eos4.png\" alt=\"文件结构2\"></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>额，第0课和第一课就到这里结束了，可以看到和我们之前的流程是类似的。同样需要你掌握web和c++的知识，这些知识点都可以通过网络找到，需要自己积累。<br>第0课主要讲解了eosio开发环境的搭建，自备梯子很重要<br>第1课主要讲解的整个项目的结构</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#105;&#110;&#103;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#105;&#110;&#103;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#111;&#109;</a></p>\n"},{"title":"eos dapp开发学习 第二课","date":"2018-10-20T14:11:25.000Z","_content":"##### 学习目标\n>我们将学习如何在智能合约中存储玩家信息;使用登录操作。然后我们将开始构建Web前端，添加Login页面。 要使登录页面与智能合约交互，我们将使用eosjs连接到EOSIO区块链。我们使用eosjs库来调用智能合约中的登录操作。接下来，我们将React连接到Redux以存储应用程序状态。最后，我们将所有这些结合起来并添加一个游戏页面，以便我们有一个工作登录屏幕。 在本课程结束时，玩家应该能够登录游戏并进入游戏中的第一个屏幕。\n\n\n#### step 1 定义表结构\n对于元素战斗，我们需要存储每个玩家的游戏进度的详细信息或状态。为此，我们将使用多索引表，这是EOSIO的一个功能。您可以将多索引表视为内存数据库。要使用多索引表，我们需要告诉EOSIO我们要在其中存储哪些数据。 对于游戏，我们需要存储玩家信息，所以让我们在之前创建的cardgame.hpp中创建一个名为user_info的结构。我们要存储：\n\n* the player’s name\n* win count (default to 0)\n* lost count (default to 0)\n\n* cardgame.hpp（这里传图片得了，看得仔细一点）   \n![lessons](/img_eos1/eos5.png)\n\n#### step 2 写入数据到多索引表_user中\n> 现在我们可以使用我们的多索引表了。所以让我们存储我们的合同状态。为此，我们将创建第一个操作，即登录操作。\n\n![lessons](/img_eos1/eos6.png)\n\n#### step 3 前端页面组件布局\n> 这里还是使用Jungle test net来做，account shaokun11113。  \n> 我这里出现了一个问题，就是之前我把eos升级了，但是我的电脑没有升级升级到eoscdt。导致现在能够生成abi和wasm文件，但是部署不到链上去，出现的是如下错误，哪位同学知道可以告诉我，感谢。  \n> ![lessons](/img_eos1/eos7.png)\n\n这里卡住我太久了，那部署合约这一步就先跳过，这一篇文章我们先根据官方的步骤先把前端页面展示出来吧！  \n![lessons](/img_eos1/eos_react.gif)\n主要是精简了官方的图片和ui，这一部分先把功能实现，有心思的同学如果觉得我的这个丑就按照官方的来吧，这里用到了几个react的库，建议你们先了解一下\n\n\t \"eosjs\": \"^16.0.9\",   \n    \"react\": \"^16.5.2\",\n    \"react-dom\": \"^16.5.2\",\n    \"react-redux\": \"^5.0.7\",\n    \"react-scripts\": \"2.0.5\",\n    \"redux\": \"^4.0.1\",\n    \"redux-logger\": \"^3.0.6\"\n\n#### step 4 页面交互\n由于合约没有部署上，所以没有办法上链进行演示，故此处仅仅是将整个前端的ui交互成功，如果你看过我之前的两篇文章，那么到这里你应该可以理解的。 \n![lessons](/img_eos1/eos_react2.gif)\n\n####  结尾\n这篇文章写的很不顺，没有完成最关键的上链一步给大家演示，真是抱歉了。那么只能够走思路了。附上本篇文章所用到的源码 [elementel battels dev2](https://github.com/shaokun11/eoslearning/tree/eos-dev02)\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习2.md","raw":"---\ntitle: eos dapp开发学习 第二课\ndate: 2018-10-20 22:11:25\n---\n##### 学习目标\n>我们将学习如何在智能合约中存储玩家信息;使用登录操作。然后我们将开始构建Web前端，添加Login页面。 要使登录页面与智能合约交互，我们将使用eosjs连接到EOSIO区块链。我们使用eosjs库来调用智能合约中的登录操作。接下来，我们将React连接到Redux以存储应用程序状态。最后，我们将所有这些结合起来并添加一个游戏页面，以便我们有一个工作登录屏幕。 在本课程结束时，玩家应该能够登录游戏并进入游戏中的第一个屏幕。\n\n\n#### step 1 定义表结构\n对于元素战斗，我们需要存储每个玩家的游戏进度的详细信息或状态。为此，我们将使用多索引表，这是EOSIO的一个功能。您可以将多索引表视为内存数据库。要使用多索引表，我们需要告诉EOSIO我们要在其中存储哪些数据。 对于游戏，我们需要存储玩家信息，所以让我们在之前创建的cardgame.hpp中创建一个名为user_info的结构。我们要存储：\n\n* the player’s name\n* win count (default to 0)\n* lost count (default to 0)\n\n* cardgame.hpp（这里传图片得了，看得仔细一点）   \n![lessons](/img_eos1/eos5.png)\n\n#### step 2 写入数据到多索引表_user中\n> 现在我们可以使用我们的多索引表了。所以让我们存储我们的合同状态。为此，我们将创建第一个操作，即登录操作。\n\n![lessons](/img_eos1/eos6.png)\n\n#### step 3 前端页面组件布局\n> 这里还是使用Jungle test net来做，account shaokun11113。  \n> 我这里出现了一个问题，就是之前我把eos升级了，但是我的电脑没有升级升级到eoscdt。导致现在能够生成abi和wasm文件，但是部署不到链上去，出现的是如下错误，哪位同学知道可以告诉我，感谢。  \n> ![lessons](/img_eos1/eos7.png)\n\n这里卡住我太久了，那部署合约这一步就先跳过，这一篇文章我们先根据官方的步骤先把前端页面展示出来吧！  \n![lessons](/img_eos1/eos_react.gif)\n主要是精简了官方的图片和ui，这一部分先把功能实现，有心思的同学如果觉得我的这个丑就按照官方的来吧，这里用到了几个react的库，建议你们先了解一下\n\n\t \"eosjs\": \"^16.0.9\",   \n    \"react\": \"^16.5.2\",\n    \"react-dom\": \"^16.5.2\",\n    \"react-redux\": \"^5.0.7\",\n    \"react-scripts\": \"2.0.5\",\n    \"redux\": \"^4.0.1\",\n    \"redux-logger\": \"^3.0.6\"\n\n#### step 4 页面交互\n由于合约没有部署上，所以没有办法上链进行演示，故此处仅仅是将整个前端的ui交互成功，如果你看过我之前的两篇文章，那么到这里你应该可以理解的。 \n![lessons](/img_eos1/eos_react2.gif)\n\n####  结尾\n这篇文章写的很不顺，没有完成最关键的上链一步给大家演示，真是抱歉了。那么只能够走思路了。附上本篇文章所用到的源码 [elementel battels dev2](https://github.com/shaokun11/eoslearning/tree/eos-dev02)\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习2","published":1,"updated":"2019-02-18T13:13:08.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b5160001nh7sycxx1zuo","content":"<h5 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h5><blockquote>\n<p>我们将学习如何在智能合约中存储玩家信息;使用登录操作。然后我们将开始构建Web前端，添加Login页面。 要使登录页面与智能合约交互，我们将使用eosjs连接到EOSIO区块链。我们使用eosjs库来调用智能合约中的登录操作。接下来，我们将React连接到Redux以存储应用程序状态。最后，我们将所有这些结合起来并添加一个游戏页面，以便我们有一个工作登录屏幕。 在本课程结束时，玩家应该能够登录游戏并进入游戏中的第一个屏幕。</p>\n</blockquote>\n<h4 id=\"step-1-定义表结构\"><a href=\"#step-1-定义表结构\" class=\"headerlink\" title=\"step 1 定义表结构\"></a>step 1 定义表结构</h4><p>对于元素战斗，我们需要存储每个玩家的游戏进度的详细信息或状态。为此，我们将使用多索引表，这是EOSIO的一个功能。您可以将多索引表视为内存数据库。要使用多索引表，我们需要告诉EOSIO我们要在其中存储哪些数据。 对于游戏，我们需要存储玩家信息，所以让我们在之前创建的cardgame.hpp中创建一个名为user_info的结构。我们要存储：</p>\n<ul>\n<li>the player’s name</li>\n<li>win count (default to 0)</li>\n<li><p>lost count (default to 0)</p>\n</li>\n<li><p>cardgame.hpp（这里传图片得了，看得仔细一点）<br><img src=\"/img_eos1/eos5.png\" alt=\"lessons\"></p>\n</li>\n</ul>\n<h4 id=\"step-2-写入数据到多索引表-user中\"><a href=\"#step-2-写入数据到多索引表-user中\" class=\"headerlink\" title=\"step 2 写入数据到多索引表_user中\"></a>step 2 写入数据到多索引表_user中</h4><blockquote>\n<p>现在我们可以使用我们的多索引表了。所以让我们存储我们的合同状态。为此，我们将创建第一个操作，即登录操作。</p>\n</blockquote>\n<p><img src=\"/img_eos1/eos6.png\" alt=\"lessons\"></p>\n<h4 id=\"step-3-前端页面组件布局\"><a href=\"#step-3-前端页面组件布局\" class=\"headerlink\" title=\"step 3 前端页面组件布局\"></a>step 3 前端页面组件布局</h4><blockquote>\n<p>这里还是使用Jungle test net来做，account shaokun11113。<br>我这里出现了一个问题，就是之前我把eos升级了，但是我的电脑没有升级升级到eoscdt。导致现在能够生成abi和wasm文件，但是部署不到链上去，出现的是如下错误，哪位同学知道可以告诉我，感谢。<br><img src=\"/img_eos1/eos7.png\" alt=\"lessons\"></p>\n</blockquote>\n<p>这里卡住我太久了，那部署合约这一步就先跳过，这一篇文章我们先根据官方的步骤先把前端页面展示出来吧！<br><img src=\"/img_eos1/eos_react.gif\" alt=\"lessons\"><br>主要是精简了官方的图片和ui，这一部分先把功能实现，有心思的同学如果觉得我的这个丑就按照官方的来吧，这里用到了几个react的库，建议你们先了解一下</p>\n<pre><code> &quot;eosjs&quot;: &quot;^16.0.9&quot;,   \n&quot;react&quot;: &quot;^16.5.2&quot;,\n&quot;react-dom&quot;: &quot;^16.5.2&quot;,\n&quot;react-redux&quot;: &quot;^5.0.7&quot;,\n&quot;react-scripts&quot;: &quot;2.0.5&quot;,\n&quot;redux&quot;: &quot;^4.0.1&quot;,\n&quot;redux-logger&quot;: &quot;^3.0.6&quot;\n</code></pre><h4 id=\"step-4-页面交互\"><a href=\"#step-4-页面交互\" class=\"headerlink\" title=\"step 4 页面交互\"></a>step 4 页面交互</h4><p>由于合约没有部署上，所以没有办法上链进行演示，故此处仅仅是将整个前端的ui交互成功，如果你看过我之前的两篇文章，那么到这里你应该可以理解的。<br><img src=\"/img_eos1/eos_react2.gif\" alt=\"lessons\"></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>这篇文章写的很不顺，没有完成最关键的上链一步给大家演示，真是抱歉了。那么只能够走思路了。附上本篇文章所用到的源码 <a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev02\" target=\"_blank\" rel=\"noopener\">elementel battels dev2</a></p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#110;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#110;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h5><blockquote>\n<p>我们将学习如何在智能合约中存储玩家信息;使用登录操作。然后我们将开始构建Web前端，添加Login页面。 要使登录页面与智能合约交互，我们将使用eosjs连接到EOSIO区块链。我们使用eosjs库来调用智能合约中的登录操作。接下来，我们将React连接到Redux以存储应用程序状态。最后，我们将所有这些结合起来并添加一个游戏页面，以便我们有一个工作登录屏幕。 在本课程结束时，玩家应该能够登录游戏并进入游戏中的第一个屏幕。</p>\n</blockquote>\n<h4 id=\"step-1-定义表结构\"><a href=\"#step-1-定义表结构\" class=\"headerlink\" title=\"step 1 定义表结构\"></a>step 1 定义表结构</h4><p>对于元素战斗，我们需要存储每个玩家的游戏进度的详细信息或状态。为此，我们将使用多索引表，这是EOSIO的一个功能。您可以将多索引表视为内存数据库。要使用多索引表，我们需要告诉EOSIO我们要在其中存储哪些数据。 对于游戏，我们需要存储玩家信息，所以让我们在之前创建的cardgame.hpp中创建一个名为user_info的结构。我们要存储：</p>\n<ul>\n<li>the player’s name</li>\n<li>win count (default to 0)</li>\n<li><p>lost count (default to 0)</p>\n</li>\n<li><p>cardgame.hpp（这里传图片得了，看得仔细一点）<br><img src=\"/img_eos1/eos5.png\" alt=\"lessons\"></p>\n</li>\n</ul>\n<h4 id=\"step-2-写入数据到多索引表-user中\"><a href=\"#step-2-写入数据到多索引表-user中\" class=\"headerlink\" title=\"step 2 写入数据到多索引表_user中\"></a>step 2 写入数据到多索引表_user中</h4><blockquote>\n<p>现在我们可以使用我们的多索引表了。所以让我们存储我们的合同状态。为此，我们将创建第一个操作，即登录操作。</p>\n</blockquote>\n<p><img src=\"/img_eos1/eos6.png\" alt=\"lessons\"></p>\n<h4 id=\"step-3-前端页面组件布局\"><a href=\"#step-3-前端页面组件布局\" class=\"headerlink\" title=\"step 3 前端页面组件布局\"></a>step 3 前端页面组件布局</h4><blockquote>\n<p>这里还是使用Jungle test net来做，account shaokun11113。<br>我这里出现了一个问题，就是之前我把eos升级了，但是我的电脑没有升级升级到eoscdt。导致现在能够生成abi和wasm文件，但是部署不到链上去，出现的是如下错误，哪位同学知道可以告诉我，感谢。<br><img src=\"/img_eos1/eos7.png\" alt=\"lessons\"></p>\n</blockquote>\n<p>这里卡住我太久了，那部署合约这一步就先跳过，这一篇文章我们先根据官方的步骤先把前端页面展示出来吧！<br><img src=\"/img_eos1/eos_react.gif\" alt=\"lessons\"><br>主要是精简了官方的图片和ui，这一部分先把功能实现，有心思的同学如果觉得我的这个丑就按照官方的来吧，这里用到了几个react的库，建议你们先了解一下</p>\n<pre><code> &quot;eosjs&quot;: &quot;^16.0.9&quot;,   \n&quot;react&quot;: &quot;^16.5.2&quot;,\n&quot;react-dom&quot;: &quot;^16.5.2&quot;,\n&quot;react-redux&quot;: &quot;^5.0.7&quot;,\n&quot;react-scripts&quot;: &quot;2.0.5&quot;,\n&quot;redux&quot;: &quot;^4.0.1&quot;,\n&quot;redux-logger&quot;: &quot;^3.0.6&quot;\n</code></pre><h4 id=\"step-4-页面交互\"><a href=\"#step-4-页面交互\" class=\"headerlink\" title=\"step 4 页面交互\"></a>step 4 页面交互</h4><p>由于合约没有部署上，所以没有办法上链进行演示，故此处仅仅是将整个前端的ui交互成功，如果你看过我之前的两篇文章，那么到这里你应该可以理解的。<br><img src=\"/img_eos1/eos_react2.gif\" alt=\"lessons\"></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><p>这篇文章写的很不顺，没有完成最关键的上链一步给大家演示，真是抱歉了。那么只能够走思路了。附上本篇文章所用到的源码 <a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev02\" target=\"_blank\" rel=\"noopener\">elementel battels dev2</a></p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#110;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#110;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#64;&#x31;&#x36;&#x33;&#x2e;&#x63;&#111;&#x6d;</a></p>\n"},{"title":"eos dapp开发学习 第二课 续","date":"2018-10-21T05:16:25.000Z","_content":"#### 前言\n> 到此我这里发现了多个问题，这里列出来，希望帮到遇到同样问题的同学\n> \n> 1. 目前eoscdt git已经更新到1.4版本了，其中的结构，语法更改了很多，我这边mac系统是10.12.6，弄了一周还是没办法升级到13，而新的cdt最低需求已经要13了，忧伤。。。 \n> 而我从源码编译，总是clone不下来，试过各种方法均失败了。这里提醒一下，最好按照他的系统要求去安装，已经有打包好的二进制文件了 \n> 2. 目前的官网的版本使用的eoscdt1.2，而经过上面的方式失败了，我再次尝试了这个，成功了\n> 3. 这里如果按照昨天的cpp文件使用eosio-cpp进行编译，是没有问题的。但是无法部署合约，这里需要将table name 由user_info 改为 userinfo   注意 不能改成userInfo,UserInfo等等，即所有的需要写入abi的action和table name必须 仅能包含   \n> `.12345abcdefghijklmnopqrstuvwxyz`   \n> 这些字符\n> 4. 莫名的感觉忧伤而兴奋，忧伤是跟不上新版本的步伐，兴奋的是开发越来越规范，现在可以接着上一篇文章继续写作了\n> 5. 带着梯子办事，总会减少很多很多没有必要的问题\n\n#### 编译、部署合约\n> 不同的版本有着不同的变化，这里仅以eoscdt1.2进行操作，如果后续使用eoscdt1.3或者使用之前的eosiocpp来编译出来的abi和wasm文件肯定是用不了的\n\n* 更改cardgame.hpp  \n![contract](/img_eos1/eos8.png)  \n\n\t\t///@abi action  => [[eosio::action]]\n\t\t///@abi table => [[eosio::table]]\n\t\tuser_info => userinfo\n* 再次生成abi和wasm文件，这里要切换到c++文件所在的目录\n \n\t\teosio-cpp -o cardgame.wasm cardgame.cpp --abigen\n\n* 部署合约，这里在任何目录执行都可以，合约的目录输入绝对路径\n\t\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Desktop/eoslearning/cardgame -p shaokun11113@active\n\n* 当部署遇到图中红色的提示时，请注意table,action,class，struct的名字所含字符  \n![contract](/img_eos1/eos9.png)   \n由之前的结论可以看到，我们合约成功部署了\n\n#### 与前端共同交互合约 \n* 这里使用了最新的eosjs,请更新 [eosjs](https://github.com/EOSIO/eosjs)\n\n\t\tnpm install eosjs@beta\t\n  \n* 更新后package.json ,请注意eosjs的版本\n\t\n\t\t{\n\t\t  \"dependencies\": {\n\t\t    \"eosjs\": \"^20.0.0-beta2\",\n\t\t    \"react\": \"^16.5.2\",\n\t\t    \"react-dom\": \"^16.5.2\",\n\t\t    \"react-redux\": \"^5.0.7\",\n\t\t    \"react-scripts\": \"2.0.5\",\n\t\t    \"redux\": \"^4.0.1\",\n\t\t    \"redux-logger\": \"^3.0.6\"\n\t\t  },\n\t\t}\n\n* 新版的eosjs的引入有更改，请仔细对比\n* 由于此处的合约只要是合法的注册到jungle上的account 都可以登录，所以前端框的private key的输入框可以随意输入，这里请注意风险 \n*  登录成功后，跳转界面！！！本篇文章的代码[lesson2 code](https://github.com/shaokun11/eoslearning/tree/eos-dev02-update)  \n![contract](/img_eos1/eos_react3.gif)  \n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 结尾\n>总算完成了之前的坑。^o^   \n>中间有很多前端的知识，这不是这个课程讲解的重点，只能靠各位同学自己去补习了。这个系列使用react，redux也是一个很庞大的工程，所以可以简单一点，展示一下交互就好。  \n>应该说到此，区块链与前端的交互已经完成，接下来就是充实智能合约的功能了。如果你做到了这一步，建议去[eos c++ api](https://developers.eos.io/eosio-cpp/reference)这里了解一下api，这样对于后面的合约编写会有一个更深层次的掌握\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习3.md","raw":"---\ntitle: eos dapp开发学习 第二课 续\ndate: 2018-10-21 13:16:25\n---\n#### 前言\n> 到此我这里发现了多个问题，这里列出来，希望帮到遇到同样问题的同学\n> \n> 1. 目前eoscdt git已经更新到1.4版本了，其中的结构，语法更改了很多，我这边mac系统是10.12.6，弄了一周还是没办法升级到13，而新的cdt最低需求已经要13了，忧伤。。。 \n> 而我从源码编译，总是clone不下来，试过各种方法均失败了。这里提醒一下，最好按照他的系统要求去安装，已经有打包好的二进制文件了 \n> 2. 目前的官网的版本使用的eoscdt1.2，而经过上面的方式失败了，我再次尝试了这个，成功了\n> 3. 这里如果按照昨天的cpp文件使用eosio-cpp进行编译，是没有问题的。但是无法部署合约，这里需要将table name 由user_info 改为 userinfo   注意 不能改成userInfo,UserInfo等等，即所有的需要写入abi的action和table name必须 仅能包含   \n> `.12345abcdefghijklmnopqrstuvwxyz`   \n> 这些字符\n> 4. 莫名的感觉忧伤而兴奋，忧伤是跟不上新版本的步伐，兴奋的是开发越来越规范，现在可以接着上一篇文章继续写作了\n> 5. 带着梯子办事，总会减少很多很多没有必要的问题\n\n#### 编译、部署合约\n> 不同的版本有着不同的变化，这里仅以eoscdt1.2进行操作，如果后续使用eoscdt1.3或者使用之前的eosiocpp来编译出来的abi和wasm文件肯定是用不了的\n\n* 更改cardgame.hpp  \n![contract](/img_eos1/eos8.png)  \n\n\t\t///@abi action  => [[eosio::action]]\n\t\t///@abi table => [[eosio::table]]\n\t\tuser_info => userinfo\n* 再次生成abi和wasm文件，这里要切换到c++文件所在的目录\n \n\t\teosio-cpp -o cardgame.wasm cardgame.cpp --abigen\n\n* 部署合约，这里在任何目录执行都可以，合约的目录输入绝对路径\n\t\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Desktop/eoslearning/cardgame -p shaokun11113@active\n\n* 当部署遇到图中红色的提示时，请注意table,action,class，struct的名字所含字符  \n![contract](/img_eos1/eos9.png)   \n由之前的结论可以看到，我们合约成功部署了\n\n#### 与前端共同交互合约 \n* 这里使用了最新的eosjs,请更新 [eosjs](https://github.com/EOSIO/eosjs)\n\n\t\tnpm install eosjs@beta\t\n  \n* 更新后package.json ,请注意eosjs的版本\n\t\n\t\t{\n\t\t  \"dependencies\": {\n\t\t    \"eosjs\": \"^20.0.0-beta2\",\n\t\t    \"react\": \"^16.5.2\",\n\t\t    \"react-dom\": \"^16.5.2\",\n\t\t    \"react-redux\": \"^5.0.7\",\n\t\t    \"react-scripts\": \"2.0.5\",\n\t\t    \"redux\": \"^4.0.1\",\n\t\t    \"redux-logger\": \"^3.0.6\"\n\t\t  },\n\t\t}\n\n* 新版的eosjs的引入有更改，请仔细对比\n* 由于此处的合约只要是合法的注册到jungle上的account 都可以登录，所以前端框的private key的输入框可以随意输入，这里请注意风险 \n*  登录成功后，跳转界面！！！本篇文章的代码[lesson2 code](https://github.com/shaokun11/eoslearning/tree/eos-dev02-update)  \n![contract](/img_eos1/eos_react3.gif)  \n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 结尾\n>总算完成了之前的坑。^o^   \n>中间有很多前端的知识，这不是这个课程讲解的重点，只能靠各位同学自己去补习了。这个系列使用react，redux也是一个很庞大的工程，所以可以简单一点，展示一下交互就好。  \n>应该说到此，区块链与前端的交互已经完成，接下来就是充实智能合约的功能了。如果你做到了这一步，建议去[eos c++ api](https://developers.eos.io/eosio-cpp/reference)这里了解一下api，这样对于后面的合约编写会有一个更深层次的掌握\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习3","published":1,"updated":"2019-02-18T13:13:08.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b5170002nh7ssw34hn6n","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>到此我这里发现了多个问题，这里列出来，希望帮到遇到同样问题的同学</p>\n<ol>\n<li>目前eoscdt git已经更新到1.4版本了，其中的结构，语法更改了很多，我这边mac系统是10.12.6，弄了一周还是没办法升级到13，而新的cdt最低需求已经要13了，忧伤。。。<br>而我从源码编译，总是clone不下来，试过各种方法均失败了。这里提醒一下，最好按照他的系统要求去安装，已经有打包好的二进制文件了 </li>\n<li>目前的官网的版本使用的eoscdt1.2，而经过上面的方式失败了，我再次尝试了这个，成功了</li>\n<li>这里如果按照昨天的cpp文件使用eosio-cpp进行编译，是没有问题的。但是无法部署合约，这里需要将table name 由user_info 改为 userinfo   注意 不能改成userInfo,UserInfo等等，即所有的需要写入abi的action和table name必须 仅能包含<br><code>.12345abcdefghijklmnopqrstuvwxyz</code><br>这些字符</li>\n<li>莫名的感觉忧伤而兴奋，忧伤是跟不上新版本的步伐，兴奋的是开发越来越规范，现在可以接着上一篇文章继续写作了</li>\n<li>带着梯子办事，总会减少很多很多没有必要的问题</li>\n</ol>\n</blockquote>\n<h4 id=\"编译、部署合约\"><a href=\"#编译、部署合约\" class=\"headerlink\" title=\"编译、部署合约\"></a>编译、部署合约</h4><blockquote>\n<p>不同的版本有着不同的变化，这里仅以eoscdt1.2进行操作，如果后续使用eoscdt1.3或者使用之前的eosiocpp来编译出来的abi和wasm文件肯定是用不了的</p>\n</blockquote>\n<ul>\n<li><p>更改cardgame.hpp<br><img src=\"/img_eos1/eos8.png\" alt=\"contract\">  </p>\n<pre><code>///@abi action  =&gt; [[eosio::action]]\n///@abi table =&gt; [[eosio::table]]\nuser_info =&gt; userinfo\n</code></pre></li>\n<li><p>再次生成abi和wasm文件，这里要切换到c++文件所在的目录</p>\n<pre><code>eosio-cpp -o cardgame.wasm cardgame.cpp --abigen\n</code></pre></li>\n<li><p>部署合约，这里在任何目录执行都可以，合约的目录输入绝对路径</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Desktop/eoslearning/cardgame -p shaokun11113@active\n</code></pre></li>\n<li><p>当部署遇到图中红色的提示时，请注意table,action,class，struct的名字所含字符<br><img src=\"/img_eos1/eos9.png\" alt=\"contract\"><br>由之前的结论可以看到，我们合约成功部署了</p>\n</li>\n</ul>\n<h4 id=\"与前端共同交互合约\"><a href=\"#与前端共同交互合约\" class=\"headerlink\" title=\"与前端共同交互合约\"></a>与前端共同交互合约</h4><ul>\n<li><p>这里使用了最新的eosjs,请更新 <a href=\"https://github.com/EOSIO/eosjs\" target=\"_blank\" rel=\"noopener\">eosjs</a></p>\n<pre><code>npm install eosjs@beta    \n</code></pre></li>\n<li><p>更新后package.json ,请注意eosjs的版本</p>\n<pre><code>{\n  &quot;dependencies&quot;: {\n    &quot;eosjs&quot;: &quot;^20.0.0-beta2&quot;,\n    &quot;react&quot;: &quot;^16.5.2&quot;,\n    &quot;react-dom&quot;: &quot;^16.5.2&quot;,\n    &quot;react-redux&quot;: &quot;^5.0.7&quot;,\n    &quot;react-scripts&quot;: &quot;2.0.5&quot;,\n    &quot;redux&quot;: &quot;^4.0.1&quot;,\n    &quot;redux-logger&quot;: &quot;^3.0.6&quot;\n  },\n}\n</code></pre></li>\n<li><p>新版的eosjs的引入有更改，请仔细对比</p>\n</li>\n<li>由于此处的合约只要是合法的注册到jungle上的account 都可以登录，所以前端框的private key的输入框可以随意输入，这里请注意风险 </li>\n<li>登录成功后，跳转界面！！！本篇文章的代码<a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev02-update\" target=\"_blank\" rel=\"noopener\">lesson2 code</a><br><img src=\"/img_eos1/eos_react3.gif\" alt=\"contract\">  </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><blockquote>\n<p>总算完成了之前的坑。^o^<br>中间有很多前端的知识，这不是这个课程讲解的重点，只能靠各位同学自己去补习了。这个系列使用react，redux也是一个很庞大的工程，所以可以简单一点，展示一下交互就好。<br>应该说到此，区块链与前端的交互已经完成，接下来就是充实智能合约的功能了。如果你做到了这一步，建议去<a href=\"https://developers.eos.io/eosio-cpp/reference\" target=\"_blank\" rel=\"noopener\">eos c++ api</a>这里了解一下api，这样对于后面的合约编写会有一个更深层次的掌握</p>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#x6f;&#107;&#x75;&#110;&#x69;&#110;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#x6f;&#107;&#x75;&#110;&#x69;&#110;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>到此我这里发现了多个问题，这里列出来，希望帮到遇到同样问题的同学</p>\n<ol>\n<li>目前eoscdt git已经更新到1.4版本了，其中的结构，语法更改了很多，我这边mac系统是10.12.6，弄了一周还是没办法升级到13，而新的cdt最低需求已经要13了，忧伤。。。<br>而我从源码编译，总是clone不下来，试过各种方法均失败了。这里提醒一下，最好按照他的系统要求去安装，已经有打包好的二进制文件了 </li>\n<li>目前的官网的版本使用的eoscdt1.2，而经过上面的方式失败了，我再次尝试了这个，成功了</li>\n<li>这里如果按照昨天的cpp文件使用eosio-cpp进行编译，是没有问题的。但是无法部署合约，这里需要将table name 由user_info 改为 userinfo   注意 不能改成userInfo,UserInfo等等，即所有的需要写入abi的action和table name必须 仅能包含<br><code>.12345abcdefghijklmnopqrstuvwxyz</code><br>这些字符</li>\n<li>莫名的感觉忧伤而兴奋，忧伤是跟不上新版本的步伐，兴奋的是开发越来越规范，现在可以接着上一篇文章继续写作了</li>\n<li>带着梯子办事，总会减少很多很多没有必要的问题</li>\n</ol>\n</blockquote>\n<h4 id=\"编译、部署合约\"><a href=\"#编译、部署合约\" class=\"headerlink\" title=\"编译、部署合约\"></a>编译、部署合约</h4><blockquote>\n<p>不同的版本有着不同的变化，这里仅以eoscdt1.2进行操作，如果后续使用eoscdt1.3或者使用之前的eosiocpp来编译出来的abi和wasm文件肯定是用不了的</p>\n</blockquote>\n<ul>\n<li><p>更改cardgame.hpp<br><img src=\"/img_eos1/eos8.png\" alt=\"contract\">  </p>\n<pre><code>///@abi action  =&gt; [[eosio::action]]\n///@abi table =&gt; [[eosio::table]]\nuser_info =&gt; userinfo\n</code></pre></li>\n<li><p>再次生成abi和wasm文件，这里要切换到c++文件所在的目录</p>\n<pre><code>eosio-cpp -o cardgame.wasm cardgame.cpp --abigen\n</code></pre></li>\n<li><p>部署合约，这里在任何目录执行都可以，合约的目录输入绝对路径</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Desktop/eoslearning/cardgame -p shaokun11113@active\n</code></pre></li>\n<li><p>当部署遇到图中红色的提示时，请注意table,action,class，struct的名字所含字符<br><img src=\"/img_eos1/eos9.png\" alt=\"contract\"><br>由之前的结论可以看到，我们合约成功部署了</p>\n</li>\n</ul>\n<h4 id=\"与前端共同交互合约\"><a href=\"#与前端共同交互合约\" class=\"headerlink\" title=\"与前端共同交互合约\"></a>与前端共同交互合约</h4><ul>\n<li><p>这里使用了最新的eosjs,请更新 <a href=\"https://github.com/EOSIO/eosjs\" target=\"_blank\" rel=\"noopener\">eosjs</a></p>\n<pre><code>npm install eosjs@beta    \n</code></pre></li>\n<li><p>更新后package.json ,请注意eosjs的版本</p>\n<pre><code>{\n  &quot;dependencies&quot;: {\n    &quot;eosjs&quot;: &quot;^20.0.0-beta2&quot;,\n    &quot;react&quot;: &quot;^16.5.2&quot;,\n    &quot;react-dom&quot;: &quot;^16.5.2&quot;,\n    &quot;react-redux&quot;: &quot;^5.0.7&quot;,\n    &quot;react-scripts&quot;: &quot;2.0.5&quot;,\n    &quot;redux&quot;: &quot;^4.0.1&quot;,\n    &quot;redux-logger&quot;: &quot;^3.0.6&quot;\n  },\n}\n</code></pre></li>\n<li><p>新版的eosjs的引入有更改，请仔细对比</p>\n</li>\n<li>由于此处的合约只要是合法的注册到jungle上的account 都可以登录，所以前端框的private key的输入框可以随意输入，这里请注意风险 </li>\n<li>登录成功后，跳转界面！！！本篇文章的代码<a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev02-update\" target=\"_blank\" rel=\"noopener\">lesson2 code</a><br><img src=\"/img_eos1/eos_react3.gif\" alt=\"contract\">  </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><blockquote>\n<p>总算完成了之前的坑。^o^<br>中间有很多前端的知识，这不是这个课程讲解的重点，只能靠各位同学自己去补习了。这个系列使用react，redux也是一个很庞大的工程，所以可以简单一点，展示一下交互就好。<br>应该说到此，区块链与前端的交互已经完成，接下来就是充实智能合约的功能了。如果你做到了这一步，建议去<a href=\"https://developers.eos.io/eosio-cpp/reference\" target=\"_blank\" rel=\"noopener\">eos c++ api</a>这里了解一下api，这样对于后面的合约编写会有一个更深层次的掌握</p>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#x6f;&#107;&#x75;&#110;&#x69;&#110;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#x6f;&#107;&#x75;&#110;&#x69;&#110;&#x67;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#x2e;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#51;&#46;&#99;&#x6f;&#x6d;</a></p>\n"},{"title":"eos dapp开发学习 第三课","date":"2018-10-27T05:12:11.000Z","_content":"#### 前言\n>上一篇文章登录的时候，你如果做了，虽然也未报错，按照结论貌似登录上了，但是，其实是没有登录上的，这里给大家说一声对不起，因为其中的某些参数未完全按照官方的例子敲，所以造成了参数不对。  \n>既然上篇文章登录错了，那么这篇文章还是得纠正过来，并且找到错在哪里\n\n#### 教程内容\n>在本课中，我们将学习如何从区块链中获取数据。数据通过来自前端的交易进入区块链，我们在第2.2课和第2.3课中查看了这一点。调用操作可以更改状态，该状态存储在多索引表中。此外，此操作记录在区块链中。\n#### 教程结果\n>首先声明，所有的结果均未完全百分之百按照官方教程走，省略了其中的ui，而只涉及了其中正常开发所必须掌握的内容，如果觉得页面不够美丽，建议你可以按照官方的例子去学，这是地址[elemental battles](https://battles.eos.io/)  \n>本次调整了部分逻辑，方便我操作，如果你觉得不合适，可以修改  \n>再来强调一下你需要哪些知识才能看懂：\n>> * 区块链共识算法，这是区块链的核心\n>> * eos 账户,权限，cpu,net,ram等相关知识\n>> * eos 本地环境，得安装在电脑上，安装方式自行查找（也就是部署合约用，如果你没有而又想走捷径，这里有个好东西，拿去不谢，[eos4js](https://github.com/itleaks/js4eos)，这个库开源出来才2天，也许后面还有更多类似的优秀的库，你都可以使用）\n>> * eoscdt 得安装，去下载，然后下一步就好。（这个东西是用来编译成wasm和abi的，单独抽出来的，建议使用，当前时间我使用的eoscdt1.2，语法是旧的，如果你后续用了高版本，按照这篇文章敲语法会有问题的，但是思想是不变的）\n>> * react 这是一个前端的库，为什么要用这个？因为第一，我会，第二，官方也是用的他，第三，用起来很爽，你如果用的别的如vue活着原生来写，只要你把流程搞懂了，也是一样的\n>> * react-redux 这东西有点难懂，可能会看得你一脸蒙蔽，和上面一点是配套使用的，数据流的管理方式。简单理解就是数据的传递方式，写起来很复杂，理解起来还是很烧脑。我一时半会也说不完，来这里去看看吧[react-redux](https://cn.redux.js.org/docs/react-redux/)。（我也考虑过不用这个写，这样简单很多，对大家的理解也会有帮助，但是考虑到官方用了，我也就顺便用了） \n>> * c++ 这个东西我也是为了写eos智能合约才开始学的，还好我之前有java的基础，学点基础够我们用了，难点的在它的指针上面，（话说，写合约貌似不怎么用指针了，eos已经帮我们封装的够多了，用得多的是引用），这个就看自己了  \n>>* node 基础 够用就好  \n>>* 当然 js基础  同样够用就好\n>>* 梯子\n>>* 系统，反正不能是Windows系统\n\n为了避免上一篇文章犯错，这次先把结果展示了\n[eos第三课源码](https://github.com/shaokun11/eoslearning/tree/eos-dev03)\n>这里尽量放git图片了，先看图后看文字解释。  \n\n![eos](/img_eos1/eos_react4.gif) \n#### 布局更新\n* 更改了采取内置账号和秘钥的方式，直接点击不用输入了\n* 当登录成功，去区块链上拿到用户的信息，刷新ui\n* 下面的代码已经有注释了\n\n\t\timport {Api, JsonRpc, JsSignatureProvider} from 'eosjs';\n\t\t\n\t\tasync function takeAction(action, account, pk, dataValue) {\n\t\t    console.log(\"takeAction\", action, dataValue)\n\t\t    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n\t\t    const signatureProvider = new JsSignatureProvider([pk]);\n\t\t    const api = new Api({rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder()});\n\t\t    try {\n\t\t        return await api.transact({\n\t\t            actions: [{\n\t\t                account: \"shaokun11113\",  // 合约的拥有者\n\t\t                name: action,             // 执行的合约方法\n\t\t                authorization: [{\n\t\t                    actor: account,       // 执行合约的账户\n\t\t                    permission: 'active', // 执行合约的账户所需要的权限\n\t\t                }],\n\t\t                data: dataValue,          // 所需要的参数,以json字符串进行传递，注意key为合约中定义的参数的名字，也可以通过abi进行查看\n\t\n\t            }]\n\t        }, {\n\t            blocksBehind: 3,              // 多少个块后确认\n\t            expireSeconds: 30,            // 超时时间\n\t        });\n\t    } catch (err) {\n\t        throw(err)\n\t    }\n\t\t}\n\t\n\t\tclass ApiService {\n\t\n\t    static async getUserByName(username) {\n\t        const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n\t        const res = await rpc.get_table_rows({\n\t            code: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n\t            scope: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n\t            table: \"userinfo\",                                           //由于在合约中写死了，这里也可以写死\n\t            json: true,                                                // 默认值 ，可以不填\n\t            lower_bound: username,                                      // 匹配规则，不填默认返回全部\n\t        })\n\t        return res.rows[0];\n\t    }\n\t\n\t    static login({name, key}) {\n\t        return new Promise((resolve, reject) => {\n\t            takeAction(\"login\", name, key, {user: name}).then(res => {\n\t                // 执行成功会返回默认的交易hash\n\t                console.log(\"login success\", res);\n\t                resolve();\n\t            }).catch(err => {\n\t                console.log(err)\n\t                reject(err);\n\t            })\n\t        });\n\t    }\n\t\t}\n\t\n\t\texport default ApiService;\n* 当登录成功显示的组件,这是当跳转后立即获取最新数据。结合上面的代码，就知道了。\n\n\t![eos](/img_eos1/eos10.png) \n\t\n* 上面最后，我使用postman拿取了合约中所有的数据，可以看到，目前的数据储存是两条，当然，你在代码中也可以实现，至于怎么实现，我想你应该知道的。至于上一篇文章错在哪里，你仔细看了上面的代码就知道了。\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 结尾\n> 对个人的总结：  \n> 目前分享的经验不是很足，严格算起来，就一个多月而已,还是经过一个外国老哥的建议才开始写的，目前文章也比较粗糙。  \n> 但我还是会尽力来记录这些。一来这样记录下来可以让自己对知识把握得更牢靠，二来也可以帮助到他人。  \n> 从零开始搭博客，学习markdown语法，搜集图片，上传图片，传动图或者视频，都是一步一步摸索出来，中间坑很多，但是乐趣也在此.\n\n至于后续的文章，尽量跟着官方的教程走，所以到这里，第三课结束了。  \n小小的总结一下前三课的内容    \n\n* 第一课  搭环境  \n* 第二课  搭ui与合约的编写\n* 第二课续 部署，测试合约（合约部署成功，连接合约是失败的）\n* 第三课  更改上课的错误，连接合约，增加新的展示界面\n\t\t\t\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习4.md","raw":"---\ntitle: eos dapp开发学习 第三课\ndate: 2018-10-27 13:12:11\n---\n#### 前言\n>上一篇文章登录的时候，你如果做了，虽然也未报错，按照结论貌似登录上了，但是，其实是没有登录上的，这里给大家说一声对不起，因为其中的某些参数未完全按照官方的例子敲，所以造成了参数不对。  \n>既然上篇文章登录错了，那么这篇文章还是得纠正过来，并且找到错在哪里\n\n#### 教程内容\n>在本课中，我们将学习如何从区块链中获取数据。数据通过来自前端的交易进入区块链，我们在第2.2课和第2.3课中查看了这一点。调用操作可以更改状态，该状态存储在多索引表中。此外，此操作记录在区块链中。\n#### 教程结果\n>首先声明，所有的结果均未完全百分之百按照官方教程走，省略了其中的ui，而只涉及了其中正常开发所必须掌握的内容，如果觉得页面不够美丽，建议你可以按照官方的例子去学，这是地址[elemental battles](https://battles.eos.io/)  \n>本次调整了部分逻辑，方便我操作，如果你觉得不合适，可以修改  \n>再来强调一下你需要哪些知识才能看懂：\n>> * 区块链共识算法，这是区块链的核心\n>> * eos 账户,权限，cpu,net,ram等相关知识\n>> * eos 本地环境，得安装在电脑上，安装方式自行查找（也就是部署合约用，如果你没有而又想走捷径，这里有个好东西，拿去不谢，[eos4js](https://github.com/itleaks/js4eos)，这个库开源出来才2天，也许后面还有更多类似的优秀的库，你都可以使用）\n>> * eoscdt 得安装，去下载，然后下一步就好。（这个东西是用来编译成wasm和abi的，单独抽出来的，建议使用，当前时间我使用的eoscdt1.2，语法是旧的，如果你后续用了高版本，按照这篇文章敲语法会有问题的，但是思想是不变的）\n>> * react 这是一个前端的库，为什么要用这个？因为第一，我会，第二，官方也是用的他，第三，用起来很爽，你如果用的别的如vue活着原生来写，只要你把流程搞懂了，也是一样的\n>> * react-redux 这东西有点难懂，可能会看得你一脸蒙蔽，和上面一点是配套使用的，数据流的管理方式。简单理解就是数据的传递方式，写起来很复杂，理解起来还是很烧脑。我一时半会也说不完，来这里去看看吧[react-redux](https://cn.redux.js.org/docs/react-redux/)。（我也考虑过不用这个写，这样简单很多，对大家的理解也会有帮助，但是考虑到官方用了，我也就顺便用了） \n>> * c++ 这个东西我也是为了写eos智能合约才开始学的，还好我之前有java的基础，学点基础够我们用了，难点的在它的指针上面，（话说，写合约貌似不怎么用指针了，eos已经帮我们封装的够多了，用得多的是引用），这个就看自己了  \n>>* node 基础 够用就好  \n>>* 当然 js基础  同样够用就好\n>>* 梯子\n>>* 系统，反正不能是Windows系统\n\n为了避免上一篇文章犯错，这次先把结果展示了\n[eos第三课源码](https://github.com/shaokun11/eoslearning/tree/eos-dev03)\n>这里尽量放git图片了，先看图后看文字解释。  \n\n![eos](/img_eos1/eos_react4.gif) \n#### 布局更新\n* 更改了采取内置账号和秘钥的方式，直接点击不用输入了\n* 当登录成功，去区块链上拿到用户的信息，刷新ui\n* 下面的代码已经有注释了\n\n\t\timport {Api, JsonRpc, JsSignatureProvider} from 'eosjs';\n\t\t\n\t\tasync function takeAction(action, account, pk, dataValue) {\n\t\t    console.log(\"takeAction\", action, dataValue)\n\t\t    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n\t\t    const signatureProvider = new JsSignatureProvider([pk]);\n\t\t    const api = new Api({rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder()});\n\t\t    try {\n\t\t        return await api.transact({\n\t\t            actions: [{\n\t\t                account: \"shaokun11113\",  // 合约的拥有者\n\t\t                name: action,             // 执行的合约方法\n\t\t                authorization: [{\n\t\t                    actor: account,       // 执行合约的账户\n\t\t                    permission: 'active', // 执行合约的账户所需要的权限\n\t\t                }],\n\t\t                data: dataValue,          // 所需要的参数,以json字符串进行传递，注意key为合约中定义的参数的名字，也可以通过abi进行查看\n\t\n\t            }]\n\t        }, {\n\t            blocksBehind: 3,              // 多少个块后确认\n\t            expireSeconds: 30,            // 超时时间\n\t        });\n\t    } catch (err) {\n\t        throw(err)\n\t    }\n\t\t}\n\t\n\t\tclass ApiService {\n\t\n\t    static async getUserByName(username) {\n\t        const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n\t        const res = await rpc.get_table_rows({\n\t            code: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n\t            scope: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n\t            table: \"userinfo\",                                           //由于在合约中写死了，这里也可以写死\n\t            json: true,                                                // 默认值 ，可以不填\n\t            lower_bound: username,                                      // 匹配规则，不填默认返回全部\n\t        })\n\t        return res.rows[0];\n\t    }\n\t\n\t    static login({name, key}) {\n\t        return new Promise((resolve, reject) => {\n\t            takeAction(\"login\", name, key, {user: name}).then(res => {\n\t                // 执行成功会返回默认的交易hash\n\t                console.log(\"login success\", res);\n\t                resolve();\n\t            }).catch(err => {\n\t                console.log(err)\n\t                reject(err);\n\t            })\n\t        });\n\t    }\n\t\t}\n\t\n\t\texport default ApiService;\n* 当登录成功显示的组件,这是当跳转后立即获取最新数据。结合上面的代码，就知道了。\n\n\t![eos](/img_eos1/eos10.png) \n\t\n* 上面最后，我使用postman拿取了合约中所有的数据，可以看到，目前的数据储存是两条，当然，你在代码中也可以实现，至于怎么实现，我想你应该知道的。至于上一篇文章错在哪里，你仔细看了上面的代码就知道了。\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 结尾\n> 对个人的总结：  \n> 目前分享的经验不是很足，严格算起来，就一个多月而已,还是经过一个外国老哥的建议才开始写的，目前文章也比较粗糙。  \n> 但我还是会尽力来记录这些。一来这样记录下来可以让自己对知识把握得更牢靠，二来也可以帮助到他人。  \n> 从零开始搭博客，学习markdown语法，搜集图片，上传图片，传动图或者视频，都是一步一步摸索出来，中间坑很多，但是乐趣也在此.\n\n至于后续的文章，尽量跟着官方的教程走，所以到这里，第三课结束了。  \n小小的总结一下前三课的内容    \n\n* 第一课  搭环境  \n* 第二课  搭ui与合约的编写\n* 第二课续 部署，测试合约（合约部署成功，连接合约是失败的）\n* 第三课  更改上课的错误，连接合约，增加新的展示界面\n\t\t\t\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习4","published":1,"updated":"2019-02-18T13:13:08.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b5180003nh7sbhfmiw4s","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>上一篇文章登录的时候，你如果做了，虽然也未报错，按照结论貌似登录上了，但是，其实是没有登录上的，这里给大家说一声对不起，因为其中的某些参数未完全按照官方的例子敲，所以造成了参数不对。<br>既然上篇文章登录错了，那么这篇文章还是得纠正过来，并且找到错在哪里</p>\n</blockquote>\n<h4 id=\"教程内容\"><a href=\"#教程内容\" class=\"headerlink\" title=\"教程内容\"></a>教程内容</h4><blockquote>\n<p>在本课中，我们将学习如何从区块链中获取数据。数据通过来自前端的交易进入区块链，我们在第2.2课和第2.3课中查看了这一点。调用操作可以更改状态，该状态存储在多索引表中。此外，此操作记录在区块链中。</p>\n</blockquote>\n<h4 id=\"教程结果\"><a href=\"#教程结果\" class=\"headerlink\" title=\"教程结果\"></a>教程结果</h4><blockquote>\n<p>首先声明，所有的结果均未完全百分之百按照官方教程走，省略了其中的ui，而只涉及了其中正常开发所必须掌握的内容，如果觉得页面不够美丽，建议你可以按照官方的例子去学，这是地址<a href=\"https://battles.eos.io/\" target=\"_blank\" rel=\"noopener\">elemental battles</a><br>本次调整了部分逻辑，方便我操作，如果你觉得不合适，可以修改<br>再来强调一下你需要哪些知识才能看懂：</p>\n<blockquote>\n<ul>\n<li>区块链共识算法，这是区块链的核心</li>\n<li>eos 账户,权限，cpu,net,ram等相关知识</li>\n<li>eos 本地环境，得安装在电脑上，安装方式自行查找（也就是部署合约用，如果你没有而又想走捷径，这里有个好东西，拿去不谢，<a href=\"https://github.com/itleaks/js4eos\" target=\"_blank\" rel=\"noopener\">eos4js</a>，这个库开源出来才2天，也许后面还有更多类似的优秀的库，你都可以使用）</li>\n<li>eoscdt 得安装，去下载，然后下一步就好。（这个东西是用来编译成wasm和abi的，单独抽出来的，建议使用，当前时间我使用的eoscdt1.2，语法是旧的，如果你后续用了高版本，按照这篇文章敲语法会有问题的，但是思想是不变的）</li>\n<li>react 这是一个前端的库，为什么要用这个？因为第一，我会，第二，官方也是用的他，第三，用起来很爽，你如果用的别的如vue活着原生来写，只要你把流程搞懂了，也是一样的</li>\n<li>react-redux 这东西有点难懂，可能会看得你一脸蒙蔽，和上面一点是配套使用的，数据流的管理方式。简单理解就是数据的传递方式，写起来很复杂，理解起来还是很烧脑。我一时半会也说不完，来这里去看看吧<a href=\"https://cn.redux.js.org/docs/react-redux/\" target=\"_blank\" rel=\"noopener\">react-redux</a>。（我也考虑过不用这个写，这样简单很多，对大家的理解也会有帮助，但是考虑到官方用了，我也就顺便用了） </li>\n<li>c++ 这个东西我也是为了写eos智能合约才开始学的，还好我之前有java的基础，学点基础够我们用了，难点的在它的指针上面，（话说，写合约貌似不怎么用指针了，eos已经帮我们封装的够多了，用得多的是引用），这个就看自己了  </li>\n<li>node 基础 够用就好  </li>\n<li>当然 js基础  同样够用就好</li>\n<li>梯子</li>\n<li>系统，反正不能是Windows系统</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>为了避免上一篇文章犯错，这次先把结果展示了<br><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev03\" target=\"_blank\" rel=\"noopener\">eos第三课源码</a></p>\n<blockquote>\n<p>这里尽量放git图片了，先看图后看文字解释。  </p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react4.gif\" alt=\"eos\"> </p>\n<h4 id=\"布局更新\"><a href=\"#布局更新\" class=\"headerlink\" title=\"布局更新\"></a>布局更新</h4><ul>\n<li>更改了采取内置账号和秘钥的方式，直接点击不用输入了</li>\n<li>当登录成功，去区块链上拿到用户的信息，刷新ui</li>\n<li><p>下面的代码已经有注释了</p>\n<pre><code>import {Api, JsonRpc, JsSignatureProvider} from &apos;eosjs&apos;;\n\nasync function takeAction(action, account, pk, dataValue) {\n    console.log(&quot;takeAction&quot;, action, dataValue)\n    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n    const signatureProvider = new JsSignatureProvider([pk]);\n    const api = new Api({rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder()});\n    try {\n        return await api.transact({\n            actions: [{\n                account: &quot;shaokun11113&quot;,  // 合约的拥有者\n                name: action,             // 执行的合约方法\n                authorization: [{\n                    actor: account,       // 执行合约的账户\n                    permission: &apos;active&apos;, // 执行合约的账户所需要的权限\n                }],\n                data: dataValue,          // 所需要的参数,以json字符串进行传递，注意key为合约中定义的参数的名字，也可以通过abi进行查看\n\n        }]\n    }, {\n        blocksBehind: 3,              // 多少个块后确认\n        expireSeconds: 30,            // 超时时间\n    });\n} catch (err) {\n    throw(err)\n}\n}\n\nclass ApiService {\n\nstatic async getUserByName(username) {\n    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n    const res = await rpc.get_table_rows({\n        code: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n        scope: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n        table: &quot;userinfo&quot;,                                           //由于在合约中写死了，这里也可以写死\n        json: true,                                                // 默认值 ，可以不填\n        lower_bound: username,                                      // 匹配规则，不填默认返回全部\n    })\n    return res.rows[0];\n}\n\nstatic login({name, key}) {\n    return new Promise((resolve, reject) =&gt; {\n        takeAction(&quot;login&quot;, name, key, {user: name}).then(res =&gt; {\n            // 执行成功会返回默认的交易hash\n            console.log(&quot;login success&quot;, res);\n            resolve();\n        }).catch(err =&gt; {\n            console.log(err)\n            reject(err);\n        })\n    });\n}\n}\n\nexport default ApiService;\n</code></pre></li>\n<li><p>当登录成功显示的组件,这是当跳转后立即获取最新数据。结合上面的代码，就知道了。</p>\n<p>  <img src=\"/img_eos1/eos10.png\" alt=\"eos\"> </p>\n</li>\n<li><p>上面最后，我使用postman拿取了合约中所有的数据，可以看到，目前的数据储存是两条，当然，你在代码中也可以实现，至于怎么实现，我想你应该知道的。至于上一篇文章错在哪里，你仔细看了上面的代码就知道了。</p>\n</li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><blockquote>\n<p>对个人的总结：<br>目前分享的经验不是很足，严格算起来，就一个多月而已,还是经过一个外国老哥的建议才开始写的，目前文章也比较粗糙。<br>但我还是会尽力来记录这些。一来这样记录下来可以让自己对知识把握得更牢靠，二来也可以帮助到他人。<br>从零开始搭博客，学习markdown语法，搜集图片，上传图片，传动图或者视频，都是一步一步摸索出来，中间坑很多，但是乐趣也在此.</p>\n</blockquote>\n<p>至于后续的文章，尽量跟着官方的教程走，所以到这里，第三课结束了。<br>小小的总结一下前三课的内容    </p>\n<ul>\n<li>第一课  搭环境  </li>\n<li>第二课  搭ui与合约的编写</li>\n<li>第二课续 部署，测试合约（合约部署成功，连接合约是失败的）</li>\n<li>第三课  更改上课的错误，连接合约，增加新的展示界面</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>上一篇文章登录的时候，你如果做了，虽然也未报错，按照结论貌似登录上了，但是，其实是没有登录上的，这里给大家说一声对不起，因为其中的某些参数未完全按照官方的例子敲，所以造成了参数不对。<br>既然上篇文章登录错了，那么这篇文章还是得纠正过来，并且找到错在哪里</p>\n</blockquote>\n<h4 id=\"教程内容\"><a href=\"#教程内容\" class=\"headerlink\" title=\"教程内容\"></a>教程内容</h4><blockquote>\n<p>在本课中，我们将学习如何从区块链中获取数据。数据通过来自前端的交易进入区块链，我们在第2.2课和第2.3课中查看了这一点。调用操作可以更改状态，该状态存储在多索引表中。此外，此操作记录在区块链中。</p>\n</blockquote>\n<h4 id=\"教程结果\"><a href=\"#教程结果\" class=\"headerlink\" title=\"教程结果\"></a>教程结果</h4><blockquote>\n<p>首先声明，所有的结果均未完全百分之百按照官方教程走，省略了其中的ui，而只涉及了其中正常开发所必须掌握的内容，如果觉得页面不够美丽，建议你可以按照官方的例子去学，这是地址<a href=\"https://battles.eos.io/\" target=\"_blank\" rel=\"noopener\">elemental battles</a><br>本次调整了部分逻辑，方便我操作，如果你觉得不合适，可以修改<br>再来强调一下你需要哪些知识才能看懂：</p>\n<blockquote>\n<ul>\n<li>区块链共识算法，这是区块链的核心</li>\n<li>eos 账户,权限，cpu,net,ram等相关知识</li>\n<li>eos 本地环境，得安装在电脑上，安装方式自行查找（也就是部署合约用，如果你没有而又想走捷径，这里有个好东西，拿去不谢，<a href=\"https://github.com/itleaks/js4eos\" target=\"_blank\" rel=\"noopener\">eos4js</a>，这个库开源出来才2天，也许后面还有更多类似的优秀的库，你都可以使用）</li>\n<li>eoscdt 得安装，去下载，然后下一步就好。（这个东西是用来编译成wasm和abi的，单独抽出来的，建议使用，当前时间我使用的eoscdt1.2，语法是旧的，如果你后续用了高版本，按照这篇文章敲语法会有问题的，但是思想是不变的）</li>\n<li>react 这是一个前端的库，为什么要用这个？因为第一，我会，第二，官方也是用的他，第三，用起来很爽，你如果用的别的如vue活着原生来写，只要你把流程搞懂了，也是一样的</li>\n<li>react-redux 这东西有点难懂，可能会看得你一脸蒙蔽，和上面一点是配套使用的，数据流的管理方式。简单理解就是数据的传递方式，写起来很复杂，理解起来还是很烧脑。我一时半会也说不完，来这里去看看吧<a href=\"https://cn.redux.js.org/docs/react-redux/\" target=\"_blank\" rel=\"noopener\">react-redux</a>。（我也考虑过不用这个写，这样简单很多，对大家的理解也会有帮助，但是考虑到官方用了，我也就顺便用了） </li>\n<li>c++ 这个东西我也是为了写eos智能合约才开始学的，还好我之前有java的基础，学点基础够我们用了，难点的在它的指针上面，（话说，写合约貌似不怎么用指针了，eos已经帮我们封装的够多了，用得多的是引用），这个就看自己了  </li>\n<li>node 基础 够用就好  </li>\n<li>当然 js基础  同样够用就好</li>\n<li>梯子</li>\n<li>系统，反正不能是Windows系统</li>\n</ul>\n</blockquote>\n</blockquote>\n<p>为了避免上一篇文章犯错，这次先把结果展示了<br><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev03\" target=\"_blank\" rel=\"noopener\">eos第三课源码</a></p>\n<blockquote>\n<p>这里尽量放git图片了，先看图后看文字解释。  </p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react4.gif\" alt=\"eos\"> </p>\n<h4 id=\"布局更新\"><a href=\"#布局更新\" class=\"headerlink\" title=\"布局更新\"></a>布局更新</h4><ul>\n<li>更改了采取内置账号和秘钥的方式，直接点击不用输入了</li>\n<li>当登录成功，去区块链上拿到用户的信息，刷新ui</li>\n<li><p>下面的代码已经有注释了</p>\n<pre><code>import {Api, JsonRpc, JsSignatureProvider} from &apos;eosjs&apos;;\n\nasync function takeAction(action, account, pk, dataValue) {\n    console.log(&quot;takeAction&quot;, action, dataValue)\n    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n    const signatureProvider = new JsSignatureProvider([pk]);\n    const api = new Api({rpc, signatureProvider, textDecoder: new TextDecoder(), textEncoder: new TextEncoder()});\n    try {\n        return await api.transact({\n            actions: [{\n                account: &quot;shaokun11113&quot;,  // 合约的拥有者\n                name: action,             // 执行的合约方法\n                authorization: [{\n                    actor: account,       // 执行合约的账户\n                    permission: &apos;active&apos;, // 执行合约的账户所需要的权限\n                }],\n                data: dataValue,          // 所需要的参数,以json字符串进行传递，注意key为合约中定义的参数的名字，也可以通过abi进行查看\n\n        }]\n    }, {\n        blocksBehind: 3,              // 多少个块后确认\n        expireSeconds: 30,            // 超时时间\n    });\n} catch (err) {\n    throw(err)\n}\n}\n\nclass ApiService {\n\nstatic async getUserByName(username) {\n    const rpc = new JsonRpc(process.env.REACT_APP_EOS_HTTP_ENDPOINT);\n    const res = await rpc.get_table_rows({\n        code: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n        scope: process.env.REACT_APP_EOS_CONTRACT_NAME,             //由于在合约中写死了，这里也可以写死\n        table: &quot;userinfo&quot;,                                           //由于在合约中写死了，这里也可以写死\n        json: true,                                                // 默认值 ，可以不填\n        lower_bound: username,                                      // 匹配规则，不填默认返回全部\n    })\n    return res.rows[0];\n}\n\nstatic login({name, key}) {\n    return new Promise((resolve, reject) =&gt; {\n        takeAction(&quot;login&quot;, name, key, {user: name}).then(res =&gt; {\n            // 执行成功会返回默认的交易hash\n            console.log(&quot;login success&quot;, res);\n            resolve();\n        }).catch(err =&gt; {\n            console.log(err)\n            reject(err);\n        })\n    });\n}\n}\n\nexport default ApiService;\n</code></pre></li>\n<li><p>当登录成功显示的组件,这是当跳转后立即获取最新数据。结合上面的代码，就知道了。</p>\n<p>  <img src=\"/img_eos1/eos10.png\" alt=\"eos\"> </p>\n</li>\n<li><p>上面最后，我使用postman拿取了合约中所有的数据，可以看到，目前的数据储存是两条，当然，你在代码中也可以实现，至于怎么实现，我想你应该知道的。至于上一篇文章错在哪里，你仔细看了上面的代码就知道了。</p>\n</li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h4><blockquote>\n<p>对个人的总结：<br>目前分享的经验不是很足，严格算起来，就一个多月而已,还是经过一个外国老哥的建议才开始写的，目前文章也比较粗糙。<br>但我还是会尽力来记录这些。一来这样记录下来可以让自己对知识把握得更牢靠，二来也可以帮助到他人。<br>从零开始搭博客，学习markdown语法，搜集图片，上传图片，传动图或者视频，都是一步一步摸索出来，中间坑很多，但是乐趣也在此.</p>\n</blockquote>\n<p>至于后续的文章，尽量跟着官方的教程走，所以到这里，第三课结束了。<br>小小的总结一下前三课的内容    </p>\n<ul>\n<li>第一课  搭环境  </li>\n<li>第二课  搭ui与合约的编写</li>\n<li>第二课续 部署，测试合约（合约部署成功，连接合约是失败的）</li>\n<li>第三课  更改上课的错误，连接合约，增加新的展示界面</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"eos dapp开发学习 第五课","date":"2018-11-11T11:30:46.000Z","_content":"#### 前言\n> * 这次将更新完官方所有的教程，但是不会一一讲解了，因为我也没怎么看懂这个算法，因为这个算法不是我要完成这篇文章的重点，所以感兴趣的同学可以自行探索  \n> * 上一篇文章虽然完成了数据上链和读取，但是由于我的大意，有些数据得做调整，具体的可以参考本篇的代码    \n> * 更改了前端的显示结构，更加清晰\n> * 说说我遇到的坑，以免你犯同样的错误 \n \n>> * 坑1==> `void playcard(account_name username, uint8_t player_card_idx);` 这是官方的方式，当我调用方法正确传参的时候，会出现 *player_card_idx*这个参数错误，我采取的办法是重命名为 index可解决，至于原因我猜测是大于12个字符了，而且 _ 应该不允许使用  \n\n>>* 自己挖的坑1 ==> 困扰了我1天，该打。  \n> 按照上篇文章的代码，当执行开始的游戏，我的手里牌仅会产生一张，结果是我在定义dict_card的时候，使用copy的方式，所有的类型全部是empty造成  \n>>* 自己挖的坑2 ==> 困扰了我2天，该打。   \n> 当我写了endgame的方法，怎么执行都不报错，但是数据就是无法更改进able，后面发现没有加入abi_dispatch中。这是个大坑，简直坑死我了  \n>>* 自己挖的坑3 ==> 这个是eos issues中看到的\n> 当更新合约时，出现这种错误，请使用绝对路径即可   \n> ![eos](/img_eos1/eos12.png)\n\n#### 结果展示\n> 这里仅做简单展示，想具体玩可以使用去官网玩  \n> 登录->开始游戏->选择手里牌和ai进行对比，进行血量的计算->再进行下一轮选牌对比，直至谁的life先到达0则为输  \n> 可以使用endgame 结束这场游戏\n\n![eos](/img_eos1/eos_react6.gif)\n\n#### 代码演示\n这里只贴了我很仔细写了代码，剩下的代码 计算ai选牌，分数计算是copy官方的\n\n\tvoid cardgame::login(eosio::name user)\n\t{\n\t\teosio::require_auth(user);\n\t\tauto itr = _users.find(user.value);\n\t\tif(itr == _users.end()){\n\t\t\t_users.emplace(get_self(),[&](auto&  row){\n\t\t\t\t\trow.name = user;\n\t\t\t\t});\n\t\t} \n\t\t// 否则登录成功\n\t}\n\t\n\tvoid cardgame::startgame(eosio::name user) {\n\t\teosio::require_auth(user);\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr, get_self(), [&](auto& row){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_card(game_data.deck_player, game_data.hand_player);\n\t\t\t\tdraw_card(game_data.deck_ai, game_data.hand_ai);\n\t\t\t}\n\t\t\trow.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::endgame(eosio::name user) {\n\t\teosio::require_auth(user);\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr, get_self(), [&](auto& row){\n\t\t\trow.game_data = game();\n\t\t});\n\t}\n#### 总结\n* 根据eos官方的elemental battle的dapp开发教程到这里我就简单的结束了，如果你按照第一篇文章来写，应该能够走得到最后，完成编写。\n* eosio.cdt又更新到1.4了，估计有新的变化，当你按照别人的教程写合约时，请注意版本\n* 上面演示时，可以看到使用eosjs进行与链上的交互很慢，而且有时还会报错，这是因为我的这边的梯子不是很好的原因，所以请不要担心\n* 对于我个人来说，我觉得写合约这块:\n  1. 先了解一下其基本的术语，比如account，action，permission\n  2. 就是增删改查 multi_index，记住这个数据储存的特殊性\n  3. 知道系统提供的一些特殊的变量和方法，比如“name”_n 和现在的get_self()\n  4. 合约中一些地方权限的验证，这非常重要。\n  5. 养成良好的代码风格。\n  6. 当能够编写基本的合约后，应该思考一下代码的结构，\n  7. 编写dapp的思想,不能按照传统的应用的模式来编写。而应该根据区块链的特性来编写应用，就例如现在在区块链上运行，储存数据都是需要有费用的。\n  8. 目前来说，区块链上的由于其特性，相对公平，不容易作假，因为所有的交易历史均可以查询，但前提是你的**智能合约**足够足够安全，而合约毕竟是用代码写的，难免有bug,所以只有多写，多看，多总结了\n* 目前eos的教程有很多版本，语法上面都有改变，即使是目前官方的demo，也有很多歌版本。所以你认准你编译合约的版本，不然你会越写越烦。我这个系列经历了eoiocpp eosio.cdt1.2 eosio1.3.2等等，写着也非常不顺，不过好歹也写完了。  \n\n[第五课源码](https://github.com/shaokun11/eoslearning/tree/eos-dve5)\n#### 接下来的计划\n> 目前我的文章基本上都是比较简单的demo或者概念性的文章，这样看多了也没有意思，我写着也觉得没有意思了。所以接下来准备找一些具有代表性的基于以太坊，波场和eos合约与大家分享了。\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习7.md","raw":"---\ntitle: eos dapp开发学习 第五课 \ndate: 2018-11-11 19:30:46\n---\n#### 前言\n> * 这次将更新完官方所有的教程，但是不会一一讲解了，因为我也没怎么看懂这个算法，因为这个算法不是我要完成这篇文章的重点，所以感兴趣的同学可以自行探索  \n> * 上一篇文章虽然完成了数据上链和读取，但是由于我的大意，有些数据得做调整，具体的可以参考本篇的代码    \n> * 更改了前端的显示结构，更加清晰\n> * 说说我遇到的坑，以免你犯同样的错误 \n \n>> * 坑1==> `void playcard(account_name username, uint8_t player_card_idx);` 这是官方的方式，当我调用方法正确传参的时候，会出现 *player_card_idx*这个参数错误，我采取的办法是重命名为 index可解决，至于原因我猜测是大于12个字符了，而且 _ 应该不允许使用  \n\n>>* 自己挖的坑1 ==> 困扰了我1天，该打。  \n> 按照上篇文章的代码，当执行开始的游戏，我的手里牌仅会产生一张，结果是我在定义dict_card的时候，使用copy的方式，所有的类型全部是empty造成  \n>>* 自己挖的坑2 ==> 困扰了我2天，该打。   \n> 当我写了endgame的方法，怎么执行都不报错，但是数据就是无法更改进able，后面发现没有加入abi_dispatch中。这是个大坑，简直坑死我了  \n>>* 自己挖的坑3 ==> 这个是eos issues中看到的\n> 当更新合约时，出现这种错误，请使用绝对路径即可   \n> ![eos](/img_eos1/eos12.png)\n\n#### 结果展示\n> 这里仅做简单展示，想具体玩可以使用去官网玩  \n> 登录->开始游戏->选择手里牌和ai进行对比，进行血量的计算->再进行下一轮选牌对比，直至谁的life先到达0则为输  \n> 可以使用endgame 结束这场游戏\n\n![eos](/img_eos1/eos_react6.gif)\n\n#### 代码演示\n这里只贴了我很仔细写了代码，剩下的代码 计算ai选牌，分数计算是copy官方的\n\n\tvoid cardgame::login(eosio::name user)\n\t{\n\t\teosio::require_auth(user);\n\t\tauto itr = _users.find(user.value);\n\t\tif(itr == _users.end()){\n\t\t\t_users.emplace(get_self(),[&](auto&  row){\n\t\t\t\t\trow.name = user;\n\t\t\t\t});\n\t\t} \n\t\t// 否则登录成功\n\t}\n\t\n\tvoid cardgame::startgame(eosio::name user) {\n\t\teosio::require_auth(user);\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr, get_self(), [&](auto& row){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_card(game_data.deck_player, game_data.hand_player);\n\t\t\t\tdraw_card(game_data.deck_ai, game_data.hand_ai);\n\t\t\t}\n\t\t\trow.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::endgame(eosio::name user) {\n\t\teosio::require_auth(user);\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr, get_self(), [&](auto& row){\n\t\t\trow.game_data = game();\n\t\t});\n\t}\n#### 总结\n* 根据eos官方的elemental battle的dapp开发教程到这里我就简单的结束了，如果你按照第一篇文章来写，应该能够走得到最后，完成编写。\n* eosio.cdt又更新到1.4了，估计有新的变化，当你按照别人的教程写合约时，请注意版本\n* 上面演示时，可以看到使用eosjs进行与链上的交互很慢，而且有时还会报错，这是因为我的这边的梯子不是很好的原因，所以请不要担心\n* 对于我个人来说，我觉得写合约这块:\n  1. 先了解一下其基本的术语，比如account，action，permission\n  2. 就是增删改查 multi_index，记住这个数据储存的特殊性\n  3. 知道系统提供的一些特殊的变量和方法，比如“name”_n 和现在的get_self()\n  4. 合约中一些地方权限的验证，这非常重要。\n  5. 养成良好的代码风格。\n  6. 当能够编写基本的合约后，应该思考一下代码的结构，\n  7. 编写dapp的思想,不能按照传统的应用的模式来编写。而应该根据区块链的特性来编写应用，就例如现在在区块链上运行，储存数据都是需要有费用的。\n  8. 目前来说，区块链上的由于其特性，相对公平，不容易作假，因为所有的交易历史均可以查询，但前提是你的**智能合约**足够足够安全，而合约毕竟是用代码写的，难免有bug,所以只有多写，多看，多总结了\n* 目前eos的教程有很多版本，语法上面都有改变，即使是目前官方的demo，也有很多歌版本。所以你认准你编译合约的版本，不然你会越写越烦。我这个系列经历了eoiocpp eosio.cdt1.2 eosio1.3.2等等，写着也非常不顺，不过好歹也写完了。  \n\n[第五课源码](https://github.com/shaokun11/eoslearning/tree/eos-dve5)\n#### 接下来的计划\n> 目前我的文章基本上都是比较简单的demo或者概念性的文章，这样看多了也没有意思，我写着也觉得没有意思了。所以接下来准备找一些具有代表性的基于以太坊，波场和eos合约与大家分享了。\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习7","published":1,"updated":"2019-02-18T13:13:08.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b5190004nh7sz9wa71ug","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<ul>\n<li>这次将更新完官方所有的教程，但是不会一一讲解了，因为我也没怎么看懂这个算法，因为这个算法不是我要完成这篇文章的重点，所以感兴趣的同学可以自行探索  </li>\n<li>上一篇文章虽然完成了数据上链和读取，但是由于我的大意，有些数据得做调整，具体的可以参考本篇的代码    </li>\n<li>更改了前端的显示结构，更加清晰</li>\n<li>说说我遇到的坑，以免你犯同样的错误 </li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>坑1==&gt; <code>void playcard(account_name username, uint8_t player_card_idx);</code> 这是官方的方式，当我调用方法正确传参的时候，会出现 <em>player_card_idx</em>这个参数错误，我采取的办法是重命名为 index可解决，至于原因我猜测是大于12个字符了，而且 _ 应该不允许使用  </li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>自己挖的坑1 ==&gt; 困扰了我1天，该打。<br>按照上篇文章的代码，当执行开始的游戏，我的手里牌仅会产生一张，结果是我在定义dict_card的时候，使用copy的方式，所有的类型全部是empty造成  </li>\n<li>自己挖的坑2 ==&gt; 困扰了我2天，该打。<br>当我写了endgame的方法，怎么执行都不报错，但是数据就是无法更改进able，后面发现没有加入abi_dispatch中。这是个大坑，简直坑死我了  </li>\n<li>自己挖的坑3 ==&gt; 这个是eos issues中看到的<br>当更新合约时，出现这种错误，请使用绝对路径即可<br><img src=\"/img_eos1/eos12.png\" alt=\"eos\"></li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h4><blockquote>\n<p>这里仅做简单展示，想具体玩可以使用去官网玩<br>登录-&gt;开始游戏-&gt;选择手里牌和ai进行对比，进行血量的计算-&gt;再进行下一轮选牌对比，直至谁的life先到达0则为输<br>可以使用endgame 结束这场游戏</p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react6.gif\" alt=\"eos\"></p>\n<h4 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h4><p>这里只贴了我很仔细写了代码，剩下的代码 计算ai选牌，分数计算是copy官方的</p>\n<pre><code>void cardgame::login(eosio::name user)\n{\n    eosio::require_auth(user);\n    auto itr = _users.find(user.value);\n    if(itr == _users.end()){\n        _users.emplace(get_self(),[&amp;](auto&amp;  row){\n                row.name = user;\n            });\n    } \n    // 否则登录成功\n}\n\nvoid cardgame::startgame(eosio::name user) {\n    eosio::require_auth(user);\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr, get_self(), [&amp;](auto&amp; row){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_card(game_data.deck_player, game_data.hand_player);\n            draw_card(game_data.deck_ai, game_data.hand_ai);\n        }\n        row.game_data = game_data;\n    });\n}\n\nvoid cardgame::endgame(eosio::name user) {\n    eosio::require_auth(user);\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr, get_self(), [&amp;](auto&amp; row){\n        row.game_data = game();\n    });\n}\n</code></pre><h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>根据eos官方的elemental battle的dapp开发教程到这里我就简单的结束了，如果你按照第一篇文章来写，应该能够走得到最后，完成编写。</li>\n<li>eosio.cdt又更新到1.4了，估计有新的变化，当你按照别人的教程写合约时，请注意版本</li>\n<li>上面演示时，可以看到使用eosjs进行与链上的交互很慢，而且有时还会报错，这是因为我的这边的梯子不是很好的原因，所以请不要担心</li>\n<li>对于我个人来说，我觉得写合约这块:<ol>\n<li>先了解一下其基本的术语，比如account，action，permission</li>\n<li>就是增删改查 multi_index，记住这个数据储存的特殊性</li>\n<li>知道系统提供的一些特殊的变量和方法，比如“name”_n 和现在的get_self()</li>\n<li>合约中一些地方权限的验证，这非常重要。</li>\n<li>养成良好的代码风格。</li>\n<li>当能够编写基本的合约后，应该思考一下代码的结构，</li>\n<li>编写dapp的思想,不能按照传统的应用的模式来编写。而应该根据区块链的特性来编写应用，就例如现在在区块链上运行，储存数据都是需要有费用的。</li>\n<li>目前来说，区块链上的由于其特性，相对公平，不容易作假，因为所有的交易历史均可以查询，但前提是你的<strong>智能合约</strong>足够足够安全，而合约毕竟是用代码写的，难免有bug,所以只有多写，多看，多总结了</li>\n</ol>\n</li>\n<li>目前eos的教程有很多版本，语法上面都有改变，即使是目前官方的demo，也有很多歌版本。所以你认准你编译合约的版本，不然你会越写越烦。我这个系列经历了eoiocpp eosio.cdt1.2 eosio1.3.2等等，写着也非常不顺，不过好歹也写完了。  </li>\n</ul>\n<p><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dve5\" target=\"_blank\" rel=\"noopener\">第五课源码</a></p>\n<h4 id=\"接下来的计划\"><a href=\"#接下来的计划\" class=\"headerlink\" title=\"接下来的计划\"></a>接下来的计划</h4><blockquote>\n<p>目前我的文章基本上都是比较简单的demo或者概念性的文章，这样看多了也没有意思，我写着也觉得没有意思了。所以接下来准备找一些具有代表性的基于以太坊，波场和eos合约与大家分享了。</p>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#107;&#x75;&#110;&#x69;&#110;&#103;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#107;&#x75;&#110;&#x69;&#110;&#103;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<ul>\n<li>这次将更新完官方所有的教程，但是不会一一讲解了，因为我也没怎么看懂这个算法，因为这个算法不是我要完成这篇文章的重点，所以感兴趣的同学可以自行探索  </li>\n<li>上一篇文章虽然完成了数据上链和读取，但是由于我的大意，有些数据得做调整，具体的可以参考本篇的代码    </li>\n<li>更改了前端的显示结构，更加清晰</li>\n<li>说说我遇到的坑，以免你犯同样的错误 </li>\n</ul>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>坑1==&gt; <code>void playcard(account_name username, uint8_t player_card_idx);</code> 这是官方的方式，当我调用方法正确传参的时候，会出现 <em>player_card_idx</em>这个参数错误，我采取的办法是重命名为 index可解决，至于原因我猜测是大于12个字符了，而且 _ 应该不允许使用  </li>\n</ul>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<ul>\n<li>自己挖的坑1 ==&gt; 困扰了我1天，该打。<br>按照上篇文章的代码，当执行开始的游戏，我的手里牌仅会产生一张，结果是我在定义dict_card的时候，使用copy的方式，所有的类型全部是empty造成  </li>\n<li>自己挖的坑2 ==&gt; 困扰了我2天，该打。<br>当我写了endgame的方法，怎么执行都不报错，但是数据就是无法更改进able，后面发现没有加入abi_dispatch中。这是个大坑，简直坑死我了  </li>\n<li>自己挖的坑3 ==&gt; 这个是eos issues中看到的<br>当更新合约时，出现这种错误，请使用绝对路径即可<br><img src=\"/img_eos1/eos12.png\" alt=\"eos\"></li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h4><blockquote>\n<p>这里仅做简单展示，想具体玩可以使用去官网玩<br>登录-&gt;开始游戏-&gt;选择手里牌和ai进行对比，进行血量的计算-&gt;再进行下一轮选牌对比，直至谁的life先到达0则为输<br>可以使用endgame 结束这场游戏</p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react6.gif\" alt=\"eos\"></p>\n<h4 id=\"代码演示\"><a href=\"#代码演示\" class=\"headerlink\" title=\"代码演示\"></a>代码演示</h4><p>这里只贴了我很仔细写了代码，剩下的代码 计算ai选牌，分数计算是copy官方的</p>\n<pre><code>void cardgame::login(eosio::name user)\n{\n    eosio::require_auth(user);\n    auto itr = _users.find(user.value);\n    if(itr == _users.end()){\n        _users.emplace(get_self(),[&amp;](auto&amp;  row){\n                row.name = user;\n            });\n    } \n    // 否则登录成功\n}\n\nvoid cardgame::startgame(eosio::name user) {\n    eosio::require_auth(user);\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr, get_self(), [&amp;](auto&amp; row){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_card(game_data.deck_player, game_data.hand_player);\n            draw_card(game_data.deck_ai, game_data.hand_ai);\n        }\n        row.game_data = game_data;\n    });\n}\n\nvoid cardgame::endgame(eosio::name user) {\n    eosio::require_auth(user);\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr, get_self(), [&amp;](auto&amp; row){\n        row.game_data = game();\n    });\n}\n</code></pre><h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>根据eos官方的elemental battle的dapp开发教程到这里我就简单的结束了，如果你按照第一篇文章来写，应该能够走得到最后，完成编写。</li>\n<li>eosio.cdt又更新到1.4了，估计有新的变化，当你按照别人的教程写合约时，请注意版本</li>\n<li>上面演示时，可以看到使用eosjs进行与链上的交互很慢，而且有时还会报错，这是因为我的这边的梯子不是很好的原因，所以请不要担心</li>\n<li>对于我个人来说，我觉得写合约这块:<ol>\n<li>先了解一下其基本的术语，比如account，action，permission</li>\n<li>就是增删改查 multi_index，记住这个数据储存的特殊性</li>\n<li>知道系统提供的一些特殊的变量和方法，比如“name”_n 和现在的get_self()</li>\n<li>合约中一些地方权限的验证，这非常重要。</li>\n<li>养成良好的代码风格。</li>\n<li>当能够编写基本的合约后，应该思考一下代码的结构，</li>\n<li>编写dapp的思想,不能按照传统的应用的模式来编写。而应该根据区块链的特性来编写应用，就例如现在在区块链上运行，储存数据都是需要有费用的。</li>\n<li>目前来说，区块链上的由于其特性，相对公平，不容易作假，因为所有的交易历史均可以查询，但前提是你的<strong>智能合约</strong>足够足够安全，而合约毕竟是用代码写的，难免有bug,所以只有多写，多看，多总结了</li>\n</ol>\n</li>\n<li>目前eos的教程有很多版本，语法上面都有改变，即使是目前官方的demo，也有很多歌版本。所以你认准你编译合约的版本，不然你会越写越烦。我这个系列经历了eoiocpp eosio.cdt1.2 eosio1.3.2等等，写着也非常不顺，不过好歹也写完了。  </li>\n</ul>\n<p><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dve5\" target=\"_blank\" rel=\"noopener\">第五课源码</a></p>\n<h4 id=\"接下来的计划\"><a href=\"#接下来的计划\" class=\"headerlink\" title=\"接下来的计划\"></a>接下来的计划</h4><blockquote>\n<p>目前我的文章基本上都是比较简单的demo或者概念性的文章，这样看多了也没有意思，我写着也觉得没有意思了。所以接下来准备找一些具有代表性的基于以太坊，波场和eos合约与大家分享了。</p>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#107;&#x75;&#110;&#x69;&#110;&#103;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#107;&#x75;&#110;&#x69;&#110;&#103;&#64;&#103;&#109;&#97;&#105;&#108;&#x2e;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n"},{"title":"eos dapp开发学习 第四课 续","date":"2018-11-09T13:48:45.000Z","_content":"#### 前言\n>很幸运，总算把新版本的eos和cdt装上了，踩过了很多坑，说多了都是泪。 \n>\n>* 首先，目前本地我的环境eos1.4 eosio.cdt1.3.2 所以你按照接下来的教程走，那么请核对你的版本\n>* 坑1 ==> 如果在原来的账号上部署过类似的table的合约，再次更新合约如果在table中增加修改了字段，能够部署，但是不能够得到得到table的内容和执行action，建议用新的账号进行部署解决\n>* 坑2 ==> [helloworld](https://developers.eos.io/eosio-home/docs/your-first-contract)很流畅，一路走下去完美。[table数据储存](https://developers.eos.io/eosio-home/docs/data-persistence)这里不知道知道是我的操作不对还是怎么回事，跟着官网的教程，abi和wasm都能够正常生成，这里合约能够部署上去。但是来了，无法get table，也无法push action。\n>* 坑3 ==> 语法变了哈，这里强调一下，支持vector，enume，map 和任何自定义的类型哈，剩下的这个就大家自行琢磨了\n>* 坑4 ==> 目前来看，尽量把合code在一个cpp中，不然有想不到的意外等着的哈\n\n#### 合约代码\n`cardgame.hpp`\n\n\t#pragma once\n\t#include <eosiolib/eosio.hpp>\n\tusing namespace std;\n\t\n\tclass [[eosio::contract]]cardgame : public eosio::contract {\n\t  public:\n\t    cardgame(eosio::name reciever,eosio::name code,eosio::datastream<const char*> ds )\n\t                                :contract(reciever,code,ds),\n\t                                _users(reciever,code.value),\n\t                                _seed(reciever,code.value){};\n\t                                \n\t    [[eosio::action]] void login(eosio::name user);\n\t    [[eosio::action]] void startgame(eosio::name user);\n\t    [[eosio::action]] void playcard(eosio::name user,uint8_t player_card_index);\n\t\n\t  private:\n\t    enum game_status:int8_t\n\t    {\n\t      ONGOING = 0,      // 游戏正在进行中\n\t      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n\t      PLAYER_LOST = -1 // 游戏结束， 完结失败\n\t    };\n\t    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n\t    {\n\t      EMPTY = 0,    // 不存在的卡片\n\t      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n\t      VOID = 5      // 平局属性       共计力为0 总共1张\n\t    };\n\t\n\t    struct card\n\t    {\n\t      uint8_t type;   // 卡片类型\n\t      uint8_t attack_point; // 卡片的攻击力\n\t    };\n\t\n\t    const  map<uint8_t,card> card_dict = {\n\t        {0 , {EMPTY , 0}},\n\t        {1 , {EMPTY , 1}},\n\t        {2 , {EMPTY , 1}},\n\t        {3 , {EMPTY , 2}},\n\t        {4 , {EMPTY , 2}},\n\t        {5 , {EMPTY , 3}},\n\t        {6 , {EMPTY , 1}},\n\t        {7 , {EMPTY , 1}},\n\t        {8 , {EMPTY , 2}},\n\t        {9 , {EMPTY , 2}},\n\t        {10 , {EMPTY , 3}},\n\t        {11 , {EMPTY , 1}},\n\t        {12 , {EMPTY , 1}},\n\t        {13 , {EMPTY , 2}},\n\t        {14 , {EMPTY , 2}},\n\t        {15 , {EMPTY , 3}},\n\t        {16 , {EMPTY , 3}},\n\t        {17 , {EMPTY , 0}},\n\t    };\n\t    struct game\n\t    {\n\t     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n\t     int8_t life_player = 5;    // 游戏玩家 5条生命\n\t     int8_t ai_player = 5;      // 游戏玩家 5条生命\n\t     vector<uint8_t>  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n\t     vector<uint8_t> deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n\t     vector<uint8_t> hand_player = {0,0,0,0}; // 玩家的手里牌\n\t     vector<uint8_t> hand_ai = {0,0,0,0};     // ai的手里牌\n\t     uint8_t selected_card_player = 0;          // 从待选牌中选中的牌\n\t     uint8_t selected_card_ai = 0;              // 从待选牌中选中的牌\n\t    };\n\t    \n\t\n\t  \tstruct [[eosio::table]] userinfo\n\t  \t{\n\t  \t\teosio::name  name;\t\t\t\n\t  \t\tuint16_t win_count = 0;\t\t\n\t  \t\tuint16_t lost_count = 0;\n\t      game game_data;         \n\t\n\t  \t\tauto primary_key() const {return name.value;}  \n\t  \t};\n\t    \n\t    struct [[eosio::table]] seed \n\t    {\n\t      uint64_t key = 1;\n\t      uint32_t seed_value = 1;\n\t\n\t      auto primary_key() const {return key;};\n\t    };\n\t\n\t  \ttypedef eosio::multi_index<\"userinfo\"_n,userinfo> user_index;\n\t    typedef eosio::multi_index<\"seed\"_n,seed> seed_index;\n\t    user_index _users; //声明表的实例\n\t    seed_index _seed;\n\t\n\t  int random(const int range);\n\t  void draw_card(vector<uint8_t>& deck, vector<uint8_t>& hand);\n\t};\n\n`cardgame.cpp`\n\n\t#include \"cardgame.hpp\"\n\t\n\tvoid cardgame::login(eosio::name user)\n\t{\n\t\t_users.emplace(get_self(),[&](auto&  u){\n\t\t\t\tu.name = user;\n\t\t});\n\t}\n\t\n\tvoid cardgame::startgame(eosio::name user) {\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr,get_self(),[&](auto& _to_modify_user){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_card(game_data.deck_player,game_data.hand_player);\n\t\t\t\tdraw_card(game_data.deck_ai,game_data.hand_ai);\n\t\t\t}\n\t\t\t_to_modify_user.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::playcard(eosio::name user, uint8_t player_card_index){\n\t\teosio::require_auth(user);\n\t\teosio_assert(player_card_index < 4,\"invalid hand index\");// 手上牌最多四张\n\t\t// 通过user找到数据表中数据\n\t\tauto& player = _users.get(user.value,\"User not exist\");\n\t\teosio_assert(player.game_data.status == ONGOING,\"game have ended\");\n\t\teosio_assert(player.game_data.selected_card_player == 0,\"the player have selected car in this turn\");\n\t\t// 修改数据表\n\t\t_users.modify(player,get_self(),[&](auto& _to_modify_user){\n\t\t\tgame& game_data = _to_modify_user.game_data;\n\t\t\t// 设定选中的卡片id\n\t\t\tgame_data.selected_card_player = game_data.hand_player[player_card_index];\n\t\t\t// 将手中卡片对应位置置位empty\n\t\t\tgame_data.hand_player[player_card_index] = 0;\n\t\t});\n\t};\n\tint cardgame::random(const int range) {\n\t\tauto seed_itr = _seed.begin();\n\t\tif (seed_itr  == _seed.end()){\t// 如果没有随机数据，就用默认值初始化\n\t\t\tseed_itr = _seed.emplace(get_self(),[&](auto& s){\n\t\t\t\ts = seed{};\n\t\t\t});\n\t\t};\n\t\tint prime = 65535;\n\t\tint new_seed_value = (seed_itr->seed_value + now()) % prime;\n\t\t_seed.modify(seed_itr,get_self(),[&](auto& s){\n\t\t\t\ts.seed_value = new_seed_value;\n\t\t});\n\t\t// 随机范围  0 ~ range\n\t\tint random_res = new_seed_value % range;\n\t\treturn random_res;\n\t};\n\tvoid cardgame::draw_card(vector<uint8_t>& deck, vector<uint8_t>& hand) {\n\t\t  int deck_card_idx = random(deck.size());\n\t\t  int first_empty_slot = -1;\n\t\t  for (int i = 0; i <= hand.size(); i++) {\n\t\t      auto id = hand[i];\n\t\t      if (card_dict.at(id).type == EMPTY) {\n\t\t          first_empty_slot = i;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t  eosio_assert(first_empty_slot != -1, \"No empty slot in the player's hand\");\n\t\t  hand[first_empty_slot] = deck[deck_card_idx];\n\t\t  deck.erase(deck.begin() + deck_card_idx);\n\t };\n\tEOSIO_DISPATCH(cardgame,(login)(startgame)(playcard))\n\n* 由于上面的坑，用shaokun11113是无法正确的，所以我用了shaokun11114进行部署  \n* 终于能够写数据到链上了![eos](/img_eos1/eos11.png)   \n* [更新的合约源码](https://github.com/shaokun11/eoslearning/tree/eos-dve4-update)，这次就没有更新前端的mock数据了，相信聪明的你一定知道怎样调整过来\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习6.md","raw":"---\ntitle: eos dapp开发学习 第四课 续  \ndate: 2018-11-09 21:48:45\n---\n#### 前言\n>很幸运，总算把新版本的eos和cdt装上了，踩过了很多坑，说多了都是泪。 \n>\n>* 首先，目前本地我的环境eos1.4 eosio.cdt1.3.2 所以你按照接下来的教程走，那么请核对你的版本\n>* 坑1 ==> 如果在原来的账号上部署过类似的table的合约，再次更新合约如果在table中增加修改了字段，能够部署，但是不能够得到得到table的内容和执行action，建议用新的账号进行部署解决\n>* 坑2 ==> [helloworld](https://developers.eos.io/eosio-home/docs/your-first-contract)很流畅，一路走下去完美。[table数据储存](https://developers.eos.io/eosio-home/docs/data-persistence)这里不知道知道是我的操作不对还是怎么回事，跟着官网的教程，abi和wasm都能够正常生成，这里合约能够部署上去。但是来了，无法get table，也无法push action。\n>* 坑3 ==> 语法变了哈，这里强调一下，支持vector，enume，map 和任何自定义的类型哈，剩下的这个就大家自行琢磨了\n>* 坑4 ==> 目前来看，尽量把合code在一个cpp中，不然有想不到的意外等着的哈\n\n#### 合约代码\n`cardgame.hpp`\n\n\t#pragma once\n\t#include <eosiolib/eosio.hpp>\n\tusing namespace std;\n\t\n\tclass [[eosio::contract]]cardgame : public eosio::contract {\n\t  public:\n\t    cardgame(eosio::name reciever,eosio::name code,eosio::datastream<const char*> ds )\n\t                                :contract(reciever,code,ds),\n\t                                _users(reciever,code.value),\n\t                                _seed(reciever,code.value){};\n\t                                \n\t    [[eosio::action]] void login(eosio::name user);\n\t    [[eosio::action]] void startgame(eosio::name user);\n\t    [[eosio::action]] void playcard(eosio::name user,uint8_t player_card_index);\n\t\n\t  private:\n\t    enum game_status:int8_t\n\t    {\n\t      ONGOING = 0,      // 游戏正在进行中\n\t      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n\t      PLAYER_LOST = -1 // 游戏结束， 完结失败\n\t    };\n\t    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n\t    {\n\t      EMPTY = 0,    // 不存在的卡片\n\t      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n\t      VOID = 5      // 平局属性       共计力为0 总共1张\n\t    };\n\t\n\t    struct card\n\t    {\n\t      uint8_t type;   // 卡片类型\n\t      uint8_t attack_point; // 卡片的攻击力\n\t    };\n\t\n\t    const  map<uint8_t,card> card_dict = {\n\t        {0 , {EMPTY , 0}},\n\t        {1 , {EMPTY , 1}},\n\t        {2 , {EMPTY , 1}},\n\t        {3 , {EMPTY , 2}},\n\t        {4 , {EMPTY , 2}},\n\t        {5 , {EMPTY , 3}},\n\t        {6 , {EMPTY , 1}},\n\t        {7 , {EMPTY , 1}},\n\t        {8 , {EMPTY , 2}},\n\t        {9 , {EMPTY , 2}},\n\t        {10 , {EMPTY , 3}},\n\t        {11 , {EMPTY , 1}},\n\t        {12 , {EMPTY , 1}},\n\t        {13 , {EMPTY , 2}},\n\t        {14 , {EMPTY , 2}},\n\t        {15 , {EMPTY , 3}},\n\t        {16 , {EMPTY , 3}},\n\t        {17 , {EMPTY , 0}},\n\t    };\n\t    struct game\n\t    {\n\t     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n\t     int8_t life_player = 5;    // 游戏玩家 5条生命\n\t     int8_t ai_player = 5;      // 游戏玩家 5条生命\n\t     vector<uint8_t>  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n\t     vector<uint8_t> deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n\t     vector<uint8_t> hand_player = {0,0,0,0}; // 玩家的手里牌\n\t     vector<uint8_t> hand_ai = {0,0,0,0};     // ai的手里牌\n\t     uint8_t selected_card_player = 0;          // 从待选牌中选中的牌\n\t     uint8_t selected_card_ai = 0;              // 从待选牌中选中的牌\n\t    };\n\t    \n\t\n\t  \tstruct [[eosio::table]] userinfo\n\t  \t{\n\t  \t\teosio::name  name;\t\t\t\n\t  \t\tuint16_t win_count = 0;\t\t\n\t  \t\tuint16_t lost_count = 0;\n\t      game game_data;         \n\t\n\t  \t\tauto primary_key() const {return name.value;}  \n\t  \t};\n\t    \n\t    struct [[eosio::table]] seed \n\t    {\n\t      uint64_t key = 1;\n\t      uint32_t seed_value = 1;\n\t\n\t      auto primary_key() const {return key;};\n\t    };\n\t\n\t  \ttypedef eosio::multi_index<\"userinfo\"_n,userinfo> user_index;\n\t    typedef eosio::multi_index<\"seed\"_n,seed> seed_index;\n\t    user_index _users; //声明表的实例\n\t    seed_index _seed;\n\t\n\t  int random(const int range);\n\t  void draw_card(vector<uint8_t>& deck, vector<uint8_t>& hand);\n\t};\n\n`cardgame.cpp`\n\n\t#include \"cardgame.hpp\"\n\t\n\tvoid cardgame::login(eosio::name user)\n\t{\n\t\t_users.emplace(get_self(),[&](auto&  u){\n\t\t\t\tu.name = user;\n\t\t});\n\t}\n\t\n\tvoid cardgame::startgame(eosio::name user) {\n\t\tauto& itr = _users.get(user.value,\"User not exist\");\n\t\t_users.modify(itr,get_self(),[&](auto& _to_modify_user){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_card(game_data.deck_player,game_data.hand_player);\n\t\t\t\tdraw_card(game_data.deck_ai,game_data.hand_ai);\n\t\t\t}\n\t\t\t_to_modify_user.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::playcard(eosio::name user, uint8_t player_card_index){\n\t\teosio::require_auth(user);\n\t\teosio_assert(player_card_index < 4,\"invalid hand index\");// 手上牌最多四张\n\t\t// 通过user找到数据表中数据\n\t\tauto& player = _users.get(user.value,\"User not exist\");\n\t\teosio_assert(player.game_data.status == ONGOING,\"game have ended\");\n\t\teosio_assert(player.game_data.selected_card_player == 0,\"the player have selected car in this turn\");\n\t\t// 修改数据表\n\t\t_users.modify(player,get_self(),[&](auto& _to_modify_user){\n\t\t\tgame& game_data = _to_modify_user.game_data;\n\t\t\t// 设定选中的卡片id\n\t\t\tgame_data.selected_card_player = game_data.hand_player[player_card_index];\n\t\t\t// 将手中卡片对应位置置位empty\n\t\t\tgame_data.hand_player[player_card_index] = 0;\n\t\t});\n\t};\n\tint cardgame::random(const int range) {\n\t\tauto seed_itr = _seed.begin();\n\t\tif (seed_itr  == _seed.end()){\t// 如果没有随机数据，就用默认值初始化\n\t\t\tseed_itr = _seed.emplace(get_self(),[&](auto& s){\n\t\t\t\ts = seed{};\n\t\t\t});\n\t\t};\n\t\tint prime = 65535;\n\t\tint new_seed_value = (seed_itr->seed_value + now()) % prime;\n\t\t_seed.modify(seed_itr,get_self(),[&](auto& s){\n\t\t\t\ts.seed_value = new_seed_value;\n\t\t});\n\t\t// 随机范围  0 ~ range\n\t\tint random_res = new_seed_value % range;\n\t\treturn random_res;\n\t};\n\tvoid cardgame::draw_card(vector<uint8_t>& deck, vector<uint8_t>& hand) {\n\t\t  int deck_card_idx = random(deck.size());\n\t\t  int first_empty_slot = -1;\n\t\t  for (int i = 0; i <= hand.size(); i++) {\n\t\t      auto id = hand[i];\n\t\t      if (card_dict.at(id).type == EMPTY) {\n\t\t          first_empty_slot = i;\n\t\t          break;\n\t\t      }\n\t\t    }\n\t\t  eosio_assert(first_empty_slot != -1, \"No empty slot in the player's hand\");\n\t\t  hand[first_empty_slot] = deck[deck_card_idx];\n\t\t  deck.erase(deck.begin() + deck_card_idx);\n\t };\n\tEOSIO_DISPATCH(cardgame,(login)(startgame)(playcard))\n\n* 由于上面的坑，用shaokun11113是无法正确的，所以我用了shaokun11114进行部署  \n* 终于能够写数据到链上了![eos](/img_eos1/eos11.png)   \n* [更新的合约源码](https://github.com/shaokun11/eoslearning/tree/eos-dve4-update)，这次就没有更新前端的mock数据了，相信聪明的你一定知道怎样调整过来\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习6","published":1,"updated":"2019-02-18T13:13:08.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b51a0005nh7s7cb3wvdq","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>很幸运，总算把新版本的eos和cdt装上了，踩过了很多坑，说多了都是泪。 </p>\n<ul>\n<li>首先，目前本地我的环境eos1.4 eosio.cdt1.3.2 所以你按照接下来的教程走，那么请核对你的版本</li>\n<li>坑1 ==&gt; 如果在原来的账号上部署过类似的table的合约，再次更新合约如果在table中增加修改了字段，能够部署，但是不能够得到得到table的内容和执行action，建议用新的账号进行部署解决</li>\n<li>坑2 ==&gt; <a href=\"https://developers.eos.io/eosio-home/docs/your-first-contract\" target=\"_blank\" rel=\"noopener\">helloworld</a>很流畅，一路走下去完美。<a href=\"https://developers.eos.io/eosio-home/docs/data-persistence\" target=\"_blank\" rel=\"noopener\">table数据储存</a>这里不知道知道是我的操作不对还是怎么回事，跟着官网的教程，abi和wasm都能够正常生成，这里合约能够部署上去。但是来了，无法get table，也无法push action。</li>\n<li>坑3 ==&gt; 语法变了哈，这里强调一下，支持vector，enume，map 和任何自定义的类型哈，剩下的这个就大家自行琢磨了</li>\n<li>坑4 ==&gt; 目前来看，尽量把合code在一个cpp中，不然有想不到的意外等着的哈</li>\n</ul>\n</blockquote>\n<h4 id=\"合约代码\"><a href=\"#合约代码\" class=\"headerlink\" title=\"合约代码\"></a>合约代码</h4><p><code>cardgame.hpp</code></p>\n<pre><code>#pragma once\n#include &lt;eosiolib/eosio.hpp&gt;\nusing namespace std;\n\nclass [[eosio::contract]]cardgame : public eosio::contract {\n  public:\n    cardgame(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )\n                                :contract(reciever,code,ds),\n                                _users(reciever,code.value),\n                                _seed(reciever,code.value){};\n\n    [[eosio::action]] void login(eosio::name user);\n    [[eosio::action]] void startgame(eosio::name user);\n    [[eosio::action]] void playcard(eosio::name user,uint8_t player_card_index);\n\n  private:\n    enum game_status:int8_t\n    {\n      ONGOING = 0,      // 游戏正在进行中\n      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n      PLAYER_LOST = -1 // 游戏结束， 完结失败\n    };\n    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n    {\n      EMPTY = 0,    // 不存在的卡片\n      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n      VOID = 5      // 平局属性       共计力为0 总共1张\n    };\n\n    struct card\n    {\n      uint8_t type;   // 卡片类型\n      uint8_t attack_point; // 卡片的攻击力\n    };\n\n    const  map&lt;uint8_t,card&gt; card_dict = {\n        {0 , {EMPTY , 0}},\n        {1 , {EMPTY , 1}},\n        {2 , {EMPTY , 1}},\n        {3 , {EMPTY , 2}},\n        {4 , {EMPTY , 2}},\n        {5 , {EMPTY , 3}},\n        {6 , {EMPTY , 1}},\n        {7 , {EMPTY , 1}},\n        {8 , {EMPTY , 2}},\n        {9 , {EMPTY , 2}},\n        {10 , {EMPTY , 3}},\n        {11 , {EMPTY , 1}},\n        {12 , {EMPTY , 1}},\n        {13 , {EMPTY , 2}},\n        {14 , {EMPTY , 2}},\n        {15 , {EMPTY , 3}},\n        {16 , {EMPTY , 3}},\n        {17 , {EMPTY , 0}},\n    };\n    struct game\n    {\n     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n     int8_t life_player = 5;    // 游戏玩家 5条生命\n     int8_t ai_player = 5;      // 游戏玩家 5条生命\n     vector&lt;uint8_t&gt;  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n     vector&lt;uint8_t&gt; deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n     vector&lt;uint8_t&gt; hand_player = {0,0,0,0}; // 玩家的手里牌\n     vector&lt;uint8_t&gt; hand_ai = {0,0,0,0};     // ai的手里牌\n     uint8_t selected_card_player = 0;          // 从待选牌中选中的牌\n     uint8_t selected_card_ai = 0;              // 从待选牌中选中的牌\n    };\n\n\n      struct [[eosio::table]] userinfo\n      {\n          eosio::name  name;            \n          uint16_t win_count = 0;        \n          uint16_t lost_count = 0;\n      game game_data;         \n\n          auto primary_key() const {return name.value;}  \n      };\n\n    struct [[eosio::table]] seed \n    {\n      uint64_t key = 1;\n      uint32_t seed_value = 1;\n\n      auto primary_key() const {return key;};\n    };\n\n      typedef eosio::multi_index&lt;&quot;userinfo&quot;_n,userinfo&gt; user_index;\n    typedef eosio::multi_index&lt;&quot;seed&quot;_n,seed&gt; seed_index;\n    user_index _users; //声明表的实例\n    seed_index _seed;\n\n  int random(const int range);\n  void draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand);\n};\n</code></pre><p><code>cardgame.cpp</code></p>\n<pre><code>#include &quot;cardgame.hpp&quot;\n\nvoid cardgame::login(eosio::name user)\n{\n    _users.emplace(get_self(),[&amp;](auto&amp;  u){\n            u.name = user;\n    });\n}\n\nvoid cardgame::startgame(eosio::name user) {\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr,get_self(),[&amp;](auto&amp; _to_modify_user){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_card(game_data.deck_player,game_data.hand_player);\n            draw_card(game_data.deck_ai,game_data.hand_ai);\n        }\n        _to_modify_user.game_data = game_data;\n    });\n}\n\nvoid cardgame::playcard(eosio::name user, uint8_t player_card_index){\n    eosio::require_auth(user);\n    eosio_assert(player_card_index &lt; 4,&quot;invalid hand index&quot;);// 手上牌最多四张\n    // 通过user找到数据表中数据\n    auto&amp; player = _users.get(user.value,&quot;User not exist&quot;);\n    eosio_assert(player.game_data.status == ONGOING,&quot;game have ended&quot;);\n    eosio_assert(player.game_data.selected_card_player == 0,&quot;the player have selected car in this turn&quot;);\n    // 修改数据表\n    _users.modify(player,get_self(),[&amp;](auto&amp; _to_modify_user){\n        game&amp; game_data = _to_modify_user.game_data;\n        // 设定选中的卡片id\n        game_data.selected_card_player = game_data.hand_player[player_card_index];\n        // 将手中卡片对应位置置位empty\n        game_data.hand_player[player_card_index] = 0;\n    });\n};\nint cardgame::random(const int range) {\n    auto seed_itr = _seed.begin();\n    if (seed_itr  == _seed.end()){    // 如果没有随机数据，就用默认值初始化\n        seed_itr = _seed.emplace(get_self(),[&amp;](auto&amp; s){\n            s = seed{};\n        });\n    };\n    int prime = 65535;\n    int new_seed_value = (seed_itr-&gt;seed_value + now()) % prime;\n    _seed.modify(seed_itr,get_self(),[&amp;](auto&amp; s){\n            s.seed_value = new_seed_value;\n    });\n    // 随机范围  0 ~ range\n    int random_res = new_seed_value % range;\n    return random_res;\n};\nvoid cardgame::draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand) {\n      int deck_card_idx = random(deck.size());\n      int first_empty_slot = -1;\n      for (int i = 0; i &lt;= hand.size(); i++) {\n          auto id = hand[i];\n          if (card_dict.at(id).type == EMPTY) {\n              first_empty_slot = i;\n              break;\n          }\n        }\n      eosio_assert(first_empty_slot != -1, &quot;No empty slot in the player&apos;s hand&quot;);\n      hand[first_empty_slot] = deck[deck_card_idx];\n      deck.erase(deck.begin() + deck_card_idx);\n };\nEOSIO_DISPATCH(cardgame,(login)(startgame)(playcard))\n</code></pre><ul>\n<li>由于上面的坑，用shaokun11113是无法正确的，所以我用了shaokun11114进行部署  </li>\n<li>终于能够写数据到链上了<img src=\"/img_eos1/eos11.png\" alt=\"eos\">   </li>\n<li><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dve4-update\" target=\"_blank\" rel=\"noopener\">更新的合约源码</a>，这次就没有更新前端的mock数据了，相信聪明的你一定知道怎样调整过来</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#x68;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#x67;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#x68;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#x67;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#110;&#x6e;&#x79;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#110;&#x6e;&#x79;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>很幸运，总算把新版本的eos和cdt装上了，踩过了很多坑，说多了都是泪。 </p>\n<ul>\n<li>首先，目前本地我的环境eos1.4 eosio.cdt1.3.2 所以你按照接下来的教程走，那么请核对你的版本</li>\n<li>坑1 ==&gt; 如果在原来的账号上部署过类似的table的合约，再次更新合约如果在table中增加修改了字段，能够部署，但是不能够得到得到table的内容和执行action，建议用新的账号进行部署解决</li>\n<li>坑2 ==&gt; <a href=\"https://developers.eos.io/eosio-home/docs/your-first-contract\" target=\"_blank\" rel=\"noopener\">helloworld</a>很流畅，一路走下去完美。<a href=\"https://developers.eos.io/eosio-home/docs/data-persistence\" target=\"_blank\" rel=\"noopener\">table数据储存</a>这里不知道知道是我的操作不对还是怎么回事，跟着官网的教程，abi和wasm都能够正常生成，这里合约能够部署上去。但是来了，无法get table，也无法push action。</li>\n<li>坑3 ==&gt; 语法变了哈，这里强调一下，支持vector，enume，map 和任何自定义的类型哈，剩下的这个就大家自行琢磨了</li>\n<li>坑4 ==&gt; 目前来看，尽量把合code在一个cpp中，不然有想不到的意外等着的哈</li>\n</ul>\n</blockquote>\n<h4 id=\"合约代码\"><a href=\"#合约代码\" class=\"headerlink\" title=\"合约代码\"></a>合约代码</h4><p><code>cardgame.hpp</code></p>\n<pre><code>#pragma once\n#include &lt;eosiolib/eosio.hpp&gt;\nusing namespace std;\n\nclass [[eosio::contract]]cardgame : public eosio::contract {\n  public:\n    cardgame(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )\n                                :contract(reciever,code,ds),\n                                _users(reciever,code.value),\n                                _seed(reciever,code.value){};\n\n    [[eosio::action]] void login(eosio::name user);\n    [[eosio::action]] void startgame(eosio::name user);\n    [[eosio::action]] void playcard(eosio::name user,uint8_t player_card_index);\n\n  private:\n    enum game_status:int8_t\n    {\n      ONGOING = 0,      // 游戏正在进行中\n      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n      PLAYER_LOST = -1 // 游戏结束， 完结失败\n    };\n    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n    {\n      EMPTY = 0,    // 不存在的卡片\n      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n      VOID = 5      // 平局属性       共计力为0 总共1张\n    };\n\n    struct card\n    {\n      uint8_t type;   // 卡片类型\n      uint8_t attack_point; // 卡片的攻击力\n    };\n\n    const  map&lt;uint8_t,card&gt; card_dict = {\n        {0 , {EMPTY , 0}},\n        {1 , {EMPTY , 1}},\n        {2 , {EMPTY , 1}},\n        {3 , {EMPTY , 2}},\n        {4 , {EMPTY , 2}},\n        {5 , {EMPTY , 3}},\n        {6 , {EMPTY , 1}},\n        {7 , {EMPTY , 1}},\n        {8 , {EMPTY , 2}},\n        {9 , {EMPTY , 2}},\n        {10 , {EMPTY , 3}},\n        {11 , {EMPTY , 1}},\n        {12 , {EMPTY , 1}},\n        {13 , {EMPTY , 2}},\n        {14 , {EMPTY , 2}},\n        {15 , {EMPTY , 3}},\n        {16 , {EMPTY , 3}},\n        {17 , {EMPTY , 0}},\n    };\n    struct game\n    {\n     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n     int8_t life_player = 5;    // 游戏玩家 5条生命\n     int8_t ai_player = 5;      // 游戏玩家 5条生命\n     vector&lt;uint8_t&gt;  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n     vector&lt;uint8_t&gt; deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n     vector&lt;uint8_t&gt; hand_player = {0,0,0,0}; // 玩家的手里牌\n     vector&lt;uint8_t&gt; hand_ai = {0,0,0,0};     // ai的手里牌\n     uint8_t selected_card_player = 0;          // 从待选牌中选中的牌\n     uint8_t selected_card_ai = 0;              // 从待选牌中选中的牌\n    };\n\n\n      struct [[eosio::table]] userinfo\n      {\n          eosio::name  name;            \n          uint16_t win_count = 0;        \n          uint16_t lost_count = 0;\n      game game_data;         \n\n          auto primary_key() const {return name.value;}  \n      };\n\n    struct [[eosio::table]] seed \n    {\n      uint64_t key = 1;\n      uint32_t seed_value = 1;\n\n      auto primary_key() const {return key;};\n    };\n\n      typedef eosio::multi_index&lt;&quot;userinfo&quot;_n,userinfo&gt; user_index;\n    typedef eosio::multi_index&lt;&quot;seed&quot;_n,seed&gt; seed_index;\n    user_index _users; //声明表的实例\n    seed_index _seed;\n\n  int random(const int range);\n  void draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand);\n};\n</code></pre><p><code>cardgame.cpp</code></p>\n<pre><code>#include &quot;cardgame.hpp&quot;\n\nvoid cardgame::login(eosio::name user)\n{\n    _users.emplace(get_self(),[&amp;](auto&amp;  u){\n            u.name = user;\n    });\n}\n\nvoid cardgame::startgame(eosio::name user) {\n    auto&amp; itr = _users.get(user.value,&quot;User not exist&quot;);\n    _users.modify(itr,get_self(),[&amp;](auto&amp; _to_modify_user){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_card(game_data.deck_player,game_data.hand_player);\n            draw_card(game_data.deck_ai,game_data.hand_ai);\n        }\n        _to_modify_user.game_data = game_data;\n    });\n}\n\nvoid cardgame::playcard(eosio::name user, uint8_t player_card_index){\n    eosio::require_auth(user);\n    eosio_assert(player_card_index &lt; 4,&quot;invalid hand index&quot;);// 手上牌最多四张\n    // 通过user找到数据表中数据\n    auto&amp; player = _users.get(user.value,&quot;User not exist&quot;);\n    eosio_assert(player.game_data.status == ONGOING,&quot;game have ended&quot;);\n    eosio_assert(player.game_data.selected_card_player == 0,&quot;the player have selected car in this turn&quot;);\n    // 修改数据表\n    _users.modify(player,get_self(),[&amp;](auto&amp; _to_modify_user){\n        game&amp; game_data = _to_modify_user.game_data;\n        // 设定选中的卡片id\n        game_data.selected_card_player = game_data.hand_player[player_card_index];\n        // 将手中卡片对应位置置位empty\n        game_data.hand_player[player_card_index] = 0;\n    });\n};\nint cardgame::random(const int range) {\n    auto seed_itr = _seed.begin();\n    if (seed_itr  == _seed.end()){    // 如果没有随机数据，就用默认值初始化\n        seed_itr = _seed.emplace(get_self(),[&amp;](auto&amp; s){\n            s = seed{};\n        });\n    };\n    int prime = 65535;\n    int new_seed_value = (seed_itr-&gt;seed_value + now()) % prime;\n    _seed.modify(seed_itr,get_self(),[&amp;](auto&amp; s){\n            s.seed_value = new_seed_value;\n    });\n    // 随机范围  0 ~ range\n    int random_res = new_seed_value % range;\n    return random_res;\n};\nvoid cardgame::draw_card(vector&lt;uint8_t&gt;&amp; deck, vector&lt;uint8_t&gt;&amp; hand) {\n      int deck_card_idx = random(deck.size());\n      int first_empty_slot = -1;\n      for (int i = 0; i &lt;= hand.size(); i++) {\n          auto id = hand[i];\n          if (card_dict.at(id).type == EMPTY) {\n              first_empty_slot = i;\n              break;\n          }\n        }\n      eosio_assert(first_empty_slot != -1, &quot;No empty slot in the player&apos;s hand&quot;);\n      hand[first_empty_slot] = deck[deck_card_idx];\n      deck.erase(deck.begin() + deck_card_idx);\n };\nEOSIO_DISPATCH(cardgame,(login)(startgame)(playcard))\n</code></pre><ul>\n<li>由于上面的坑，用shaokun11113是无法正确的，所以我用了shaokun11114进行部署  </li>\n<li>终于能够写数据到链上了<img src=\"/img_eos1/eos11.png\" alt=\"eos\">   </li>\n<li><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dve4-update\" target=\"_blank\" rel=\"noopener\">更新的合约源码</a>，这次就没有更新前端的mock数据了，相信聪明的你一定知道怎样调整过来</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#x68;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#x67;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#x68;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#x67;&#x40;&#x67;&#109;&#97;&#105;&#108;&#46;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#110;&#x6e;&#x79;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#110;&#x6e;&#x79;&#64;&#x31;&#54;&#51;&#x2e;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"eos中inline action的使用方式 (上)","date":"2018-11-25T12:03:05.000Z","_content":"\n#### 前言\n> eos中有两种action,一种是本文要带大家理解使用的inline action,一种deffer action.    \n> 关于他们的差别我觉得主要一点就是前者一定是打包在同一个块中的,而且是事务操作.\n\n#### surprise\n> * jungle的测试网升级到2.0了,既然升级了,应该有不少的优化吧[jugnle2.0地址](https://monitor.jungletestnet.io/)  \n> * 由于在jungle测试网遇到很多坑,所以试了试另外一个测试网[麒麟](https://tools.cryptokylin.io/#/tools/create),用起来很不错,不用带梯子,建议大家在国内使用这个网络\n> * 在kylin创建账号和获取测试币,直接在浏览器地址栏敲进去就可以了\n\n\thttp://faucet.cryptokylin.io/create_account?new_account_name\n\thttp://faucet.cryptokylin.io/get_token?your_account_name\n####  action的结果展示\n> * 结果和之前的todolist内容差不多,只是多了一些额外的输出内容,而且这也是官方的例子\n> * 那为什么还要记录呢?第一是我学习的过程,第二是看看具体的结果,第三是部署到测试网试试\n> * 这里我也一些疑问?这样是否会多消耗ram? 如果不消耗,可以作为一些log的使用还是不错的,如果消耗,个人感觉没什么用,毕竟输出的每一个文字都是ram呢\n> * 当然,它最主要的作用是可以调用其他的合约的内容,而同时保证在一个事务中,这个下篇文章给大家展示\n> * 以太坊中的event有点类似本问所展示的作用,它可以监听,而且这部分log不消耗gas\n> * 在交互中,也顺便展示了scatter中如何切换账号的操作\n\n![inline](/eosinline/inline1.gif)\n\n#### cpp源码展示\n> 没什么需要多说的,注意inline action的写法\n\n\t#include <eosiolib/eosio.hpp>\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] addressbook : public eosio::contract {\n\tpublic:\n\t    using contract::contract;\n\t    addressbook(name reciever, name code, datastream<const char*> ds) : contract(reciever,code,ds){}\n\t\n\t    [[eosio::action]]\n\t    void upsert(name user, std::string first_name, uint64_t age){\n\t        require_auth(user);\n\t        address_index addresses(_code,_code.value);\n\t        auto itr = addresses.find(user.value);\n\t        if(itr == addresses.end()){\n\t            addresses.emplace(user,[&](auto& row){\n\t                row.key = user;\n\t                row.first_name = first_name;\n\t                row.age = age;\n\t            });\n\t            send_summary(user, \"emplace data\");\n\t        } else {\n\t            addresses.modify(itr, user, [&](auto& row){\n\t                        row.first_name = first_name;\n\t                        row.age = age;\n\t            });\n\t            send_summary(user, \"modify data\");\n\t        }\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void erase(name user){\n\t        require_auth(user);\n\t        address_index addresses(_self, _code.value);\n\t        auto itr = addresses.find(user.value);\n\t        eosio_assert(itr != addresses.end(),\"record not exist\");\n\t        addresses.erase(itr);\n\t        send_summary(user, \"erase data\");\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void notify(name user, std::string){\n\t        require_auth(get_self());\n\t        require_recipient(user);\n\t    }\n\t\n\tprivate:\n\t    struct [[eosio::table]] person {\n\t        name key;\n\t        std::string first_name;\n\t        uint64_t age;\n\t\n\t        auto primary_key() const {\n\t            return key.value;\n\t        };\n\t    };\n\t    typedef multi_index<\"person\"_n, person> address_index;\n\t \n\t    void send_summary(name user, std::string msg){\n\t        action(\n\t            permission_level{get_self(),\"active\"_n},\n\t                get_self(),\n\t                \"notify\"_n,\n\t                std::make_tuple(user, name{user}.to_string() +msg)\n\t            ).send();\n\t    }\n\t};\n\tEOSIO_DISPATCH(addressbook,(upsert)(erase))\n\n#### eth中的event的使用\n>* eth的event可以当做log使用,而且可以单独监听.这给了极大的方便了给任何一个人或则组织想知道某个合约函数的执行情况,我觉得这是一种非常好的机制.不知道eos中有没有类似的功能.\n>* 也就是说合约中的信息可以主动推送给我们\n>* 可以看到一个简单的node七八行代码就可以监听任何一个合约的所有事件的功能,前提你得拿到这个合约的地址和abi\n>* 这里涉及了较多的以太坊的知识,只是为了向大家展示一下这个功能,不知道eos中目前有不有类似的功能,感觉它这个inline action即本篇文章描述的这个功能有点点类似,但是不知道能不能主动推送给我们呢?   \n  \n![inline](/eosinline/inline2.gif)\n\n#### scatter遇到的一个小问题\n>* 这里遇到了一个很纠结的问题,就是scatter无法弹出来.\n>* 如果有遇到的同学,请重新安装scatter那两个lib,再次感谢某位朋友帮忙  \n\n\tyarn remove eosjs scatterjs-core scatterjs-plugin-eosjs\n\tyarn add eosjs scatterjs-core scatterjs-plugin-eosjs\n#### 源码献上\n>这里的源码包括本篇文章演示所有的合约和js文件,涉及到了eos和eth,各位同学可以选择性使用.\n\n[inline action的使用](https://github.com/shaokun11/eosabout/tree/eos-inline-action)\n#### 总结\n> * 我为什么喜欢用测试网,而且总是要带梯子? 我觉得测试网与主网的环境操作一模一样,只是换了endpoint而已.如果在测试网能够按照设想运行,那么主网只需要改变一下下即可.而梯子对于我们这行的同学来说,应该是必备的.\n> * 而现在用麒麟,不用梯子了哈.这点很重要\n> * 由于eos的交易速度很快,所以用测试网来测试完全没有任何问题.\n> * 这篇文章只讲解的eos的inline action的一个功能,下篇文章将使用它的更加实用的功能,而不仅仅是一个log的功能哈\n> * 最近公司的项目很紧,所以能不能快速把新的知识点分享给大家还是未知数了呢,如果你也对dapp开发感兴趣,可以加个微信一起探讨 ^.^\n> * 声明一点,我目前只对dapp的开发有点经验,至于源码分析,个人能力达不到呢.\n> * eth和eos虽然实现的机制不一样,但都是区块链啊.所以学习eos的时候,当我有些地方不怎么明白,我会再回去用eth的思想来思考一下这个eos的功能怎么用,目前看来,毕竟eos个人觉得比eth上手难度大很多呢\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解.md","raw":"---\ntitle: eos中inline action的使用方式 (上)\ndate: 2018-11-25 20:03:05\n---\n\n#### 前言\n> eos中有两种action,一种是本文要带大家理解使用的inline action,一种deffer action.    \n> 关于他们的差别我觉得主要一点就是前者一定是打包在同一个块中的,而且是事务操作.\n\n#### surprise\n> * jungle的测试网升级到2.0了,既然升级了,应该有不少的优化吧[jugnle2.0地址](https://monitor.jungletestnet.io/)  \n> * 由于在jungle测试网遇到很多坑,所以试了试另外一个测试网[麒麟](https://tools.cryptokylin.io/#/tools/create),用起来很不错,不用带梯子,建议大家在国内使用这个网络\n> * 在kylin创建账号和获取测试币,直接在浏览器地址栏敲进去就可以了\n\n\thttp://faucet.cryptokylin.io/create_account?new_account_name\n\thttp://faucet.cryptokylin.io/get_token?your_account_name\n####  action的结果展示\n> * 结果和之前的todolist内容差不多,只是多了一些额外的输出内容,而且这也是官方的例子\n> * 那为什么还要记录呢?第一是我学习的过程,第二是看看具体的结果,第三是部署到测试网试试\n> * 这里我也一些疑问?这样是否会多消耗ram? 如果不消耗,可以作为一些log的使用还是不错的,如果消耗,个人感觉没什么用,毕竟输出的每一个文字都是ram呢\n> * 当然,它最主要的作用是可以调用其他的合约的内容,而同时保证在一个事务中,这个下篇文章给大家展示\n> * 以太坊中的event有点类似本问所展示的作用,它可以监听,而且这部分log不消耗gas\n> * 在交互中,也顺便展示了scatter中如何切换账号的操作\n\n![inline](/eosinline/inline1.gif)\n\n#### cpp源码展示\n> 没什么需要多说的,注意inline action的写法\n\n\t#include <eosiolib/eosio.hpp>\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] addressbook : public eosio::contract {\n\tpublic:\n\t    using contract::contract;\n\t    addressbook(name reciever, name code, datastream<const char*> ds) : contract(reciever,code,ds){}\n\t\n\t    [[eosio::action]]\n\t    void upsert(name user, std::string first_name, uint64_t age){\n\t        require_auth(user);\n\t        address_index addresses(_code,_code.value);\n\t        auto itr = addresses.find(user.value);\n\t        if(itr == addresses.end()){\n\t            addresses.emplace(user,[&](auto& row){\n\t                row.key = user;\n\t                row.first_name = first_name;\n\t                row.age = age;\n\t            });\n\t            send_summary(user, \"emplace data\");\n\t        } else {\n\t            addresses.modify(itr, user, [&](auto& row){\n\t                        row.first_name = first_name;\n\t                        row.age = age;\n\t            });\n\t            send_summary(user, \"modify data\");\n\t        }\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void erase(name user){\n\t        require_auth(user);\n\t        address_index addresses(_self, _code.value);\n\t        auto itr = addresses.find(user.value);\n\t        eosio_assert(itr != addresses.end(),\"record not exist\");\n\t        addresses.erase(itr);\n\t        send_summary(user, \"erase data\");\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void notify(name user, std::string){\n\t        require_auth(get_self());\n\t        require_recipient(user);\n\t    }\n\t\n\tprivate:\n\t    struct [[eosio::table]] person {\n\t        name key;\n\t        std::string first_name;\n\t        uint64_t age;\n\t\n\t        auto primary_key() const {\n\t            return key.value;\n\t        };\n\t    };\n\t    typedef multi_index<\"person\"_n, person> address_index;\n\t \n\t    void send_summary(name user, std::string msg){\n\t        action(\n\t            permission_level{get_self(),\"active\"_n},\n\t                get_self(),\n\t                \"notify\"_n,\n\t                std::make_tuple(user, name{user}.to_string() +msg)\n\t            ).send();\n\t    }\n\t};\n\tEOSIO_DISPATCH(addressbook,(upsert)(erase))\n\n#### eth中的event的使用\n>* eth的event可以当做log使用,而且可以单独监听.这给了极大的方便了给任何一个人或则组织想知道某个合约函数的执行情况,我觉得这是一种非常好的机制.不知道eos中有没有类似的功能.\n>* 也就是说合约中的信息可以主动推送给我们\n>* 可以看到一个简单的node七八行代码就可以监听任何一个合约的所有事件的功能,前提你得拿到这个合约的地址和abi\n>* 这里涉及了较多的以太坊的知识,只是为了向大家展示一下这个功能,不知道eos中目前有不有类似的功能,感觉它这个inline action即本篇文章描述的这个功能有点点类似,但是不知道能不能主动推送给我们呢?   \n  \n![inline](/eosinline/inline2.gif)\n\n#### scatter遇到的一个小问题\n>* 这里遇到了一个很纠结的问题,就是scatter无法弹出来.\n>* 如果有遇到的同学,请重新安装scatter那两个lib,再次感谢某位朋友帮忙  \n\n\tyarn remove eosjs scatterjs-core scatterjs-plugin-eosjs\n\tyarn add eosjs scatterjs-core scatterjs-plugin-eosjs\n#### 源码献上\n>这里的源码包括本篇文章演示所有的合约和js文件,涉及到了eos和eth,各位同学可以选择性使用.\n\n[inline action的使用](https://github.com/shaokun11/eosabout/tree/eos-inline-action)\n#### 总结\n> * 我为什么喜欢用测试网,而且总是要带梯子? 我觉得测试网与主网的环境操作一模一样,只是换了endpoint而已.如果在测试网能够按照设想运行,那么主网只需要改变一下下即可.而梯子对于我们这行的同学来说,应该是必备的.\n> * 而现在用麒麟,不用梯子了哈.这点很重要\n> * 由于eos的交易速度很快,所以用测试网来测试完全没有任何问题.\n> * 这篇文章只讲解的eos的inline action的一个功能,下篇文章将使用它的更加实用的功能,而不仅仅是一个log的功能哈\n> * 最近公司的项目很紧,所以能不能快速把新的知识点分享给大家还是未知数了呢,如果你也对dapp开发感兴趣,可以加个微信一起探讨 ^.^\n> * 声明一点,我目前只对dapp的开发有点经验,至于源码分析,个人能力达不到呢.\n> * eth和eos虽然实现的机制不一样,但都是区块链啊.所以学习eos的时候,当我有些地方不怎么明白,我会再回去用eth的思想来思考一下这个eos的功能怎么用,目前看来,毕竟eos个人觉得比eth上手难度大很多呢\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解","published":1,"updated":"2019-02-18T13:13:08.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b51u0006nh7sruheder4","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>eos中有两种action,一种是本文要带大家理解使用的inline action,一种deffer action.<br>关于他们的差别我觉得主要一点就是前者一定是打包在同一个块中的,而且是事务操作.</p>\n</blockquote>\n<h4 id=\"surprise\"><a href=\"#surprise\" class=\"headerlink\" title=\"surprise\"></a>surprise</h4><blockquote>\n<ul>\n<li>jungle的测试网升级到2.0了,既然升级了,应该有不少的优化吧<a href=\"https://monitor.jungletestnet.io/\" target=\"_blank\" rel=\"noopener\">jugnle2.0地址</a>  </li>\n<li>由于在jungle测试网遇到很多坑,所以试了试另外一个测试网<a href=\"https://tools.cryptokylin.io/#/tools/create\" target=\"_blank\" rel=\"noopener\">麒麟</a>,用起来很不错,不用带梯子,建议大家在国内使用这个网络</li>\n<li>在kylin创建账号和获取测试币,直接在浏览器地址栏敲进去就可以了</li>\n</ul>\n</blockquote>\n<pre><code>http://faucet.cryptokylin.io/create_account?new_account_name\nhttp://faucet.cryptokylin.io/get_token?your_account_name\n</code></pre><h4 id=\"action的结果展示\"><a href=\"#action的结果展示\" class=\"headerlink\" title=\"action的结果展示\"></a>action的结果展示</h4><blockquote>\n<ul>\n<li>结果和之前的todolist内容差不多,只是多了一些额外的输出内容,而且这也是官方的例子</li>\n<li>那为什么还要记录呢?第一是我学习的过程,第二是看看具体的结果,第三是部署到测试网试试</li>\n<li>这里我也一些疑问?这样是否会多消耗ram? 如果不消耗,可以作为一些log的使用还是不错的,如果消耗,个人感觉没什么用,毕竟输出的每一个文字都是ram呢</li>\n<li>当然,它最主要的作用是可以调用其他的合约的内容,而同时保证在一个事务中,这个下篇文章给大家展示</li>\n<li>以太坊中的event有点类似本问所展示的作用,它可以监听,而且这部分log不消耗gas</li>\n<li>在交互中,也顺便展示了scatter中如何切换账号的操作</li>\n</ul>\n</blockquote>\n<p><img src=\"/eosinline/inline1.gif\" alt=\"inline\"></p>\n<h4 id=\"cpp源码展示\"><a href=\"#cpp源码展示\" class=\"headerlink\" title=\"cpp源码展示\"></a>cpp源码展示</h4><blockquote>\n<p>没什么需要多说的,注意inline action的写法</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;    \nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\npublic:\n    using contract::contract;\n    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}\n\n    [[eosio::action]]\n    void upsert(name user, std::string first_name, uint64_t age){\n        require_auth(user);\n        address_index addresses(_code,_code.value);\n        auto itr = addresses.find(user.value);\n        if(itr == addresses.end()){\n            addresses.emplace(user,[&amp;](auto&amp; row){\n                row.key = user;\n                row.first_name = first_name;\n                row.age = age;\n            });\n            send_summary(user, &quot;emplace data&quot;);\n        } else {\n            addresses.modify(itr, user, [&amp;](auto&amp; row){\n                        row.first_name = first_name;\n                        row.age = age;\n            });\n            send_summary(user, &quot;modify data&quot;);\n        }\n    }\n\n    [[eosio::action]]\n    void erase(name user){\n        require_auth(user);\n        address_index addresses(_self, _code.value);\n        auto itr = addresses.find(user.value);\n        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);\n        addresses.erase(itr);\n        send_summary(user, &quot;erase data&quot;);\n    }\n\n    [[eosio::action]]\n    void notify(name user, std::string){\n        require_auth(get_self());\n        require_recipient(user);\n    }\n\nprivate:\n    struct [[eosio::table]] person {\n        name key;\n        std::string first_name;\n        uint64_t age;\n\n        auto primary_key() const {\n            return key.value;\n        };\n    };\n    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;\n\n    void send_summary(name user, std::string msg){\n        action(\n            permission_level{get_self(),&quot;active&quot;_n},\n                get_self(),\n                &quot;notify&quot;_n,\n                std::make_tuple(user, name{user}.to_string() +msg)\n            ).send();\n    }\n};\nEOSIO_DISPATCH(addressbook,(upsert)(erase))\n</code></pre><h4 id=\"eth中的event的使用\"><a href=\"#eth中的event的使用\" class=\"headerlink\" title=\"eth中的event的使用\"></a>eth中的event的使用</h4><blockquote>\n<ul>\n<li>eth的event可以当做log使用,而且可以单独监听.这给了极大的方便了给任何一个人或则组织想知道某个合约函数的执行情况,我觉得这是一种非常好的机制.不知道eos中有没有类似的功能.</li>\n<li>也就是说合约中的信息可以主动推送给我们</li>\n<li>可以看到一个简单的node七八行代码就可以监听任何一个合约的所有事件的功能,前提你得拿到这个合约的地址和abi</li>\n<li>这里涉及了较多的以太坊的知识,只是为了向大家展示一下这个功能,不知道eos中目前有不有类似的功能,感觉它这个inline action即本篇文章描述的这个功能有点点类似,但是不知道能不能主动推送给我们呢?   </li>\n</ul>\n</blockquote>\n<p><img src=\"/eosinline/inline2.gif\" alt=\"inline\"></p>\n<h4 id=\"scatter遇到的一个小问题\"><a href=\"#scatter遇到的一个小问题\" class=\"headerlink\" title=\"scatter遇到的一个小问题\"></a>scatter遇到的一个小问题</h4><blockquote>\n<ul>\n<li>这里遇到了一个很纠结的问题,就是scatter无法弹出来.</li>\n<li>如果有遇到的同学,请重新安装scatter那两个lib,再次感谢某位朋友帮忙  </li>\n</ul>\n</blockquote>\n<pre><code>yarn remove eosjs scatterjs-core scatterjs-plugin-eosjs\nyarn add eosjs scatterjs-core scatterjs-plugin-eosjs\n</code></pre><h4 id=\"源码献上\"><a href=\"#源码献上\" class=\"headerlink\" title=\"源码献上\"></a>源码献上</h4><blockquote>\n<p>这里的源码包括本篇文章演示所有的合约和js文件,涉及到了eos和eth,各位同学可以选择性使用.</p>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-inline-action\" target=\"_blank\" rel=\"noopener\">inline action的使用</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<ul>\n<li>我为什么喜欢用测试网,而且总是要带梯子? 我觉得测试网与主网的环境操作一模一样,只是换了endpoint而已.如果在测试网能够按照设想运行,那么主网只需要改变一下下即可.而梯子对于我们这行的同学来说,应该是必备的.</li>\n<li>而现在用麒麟,不用梯子了哈.这点很重要</li>\n<li>由于eos的交易速度很快,所以用测试网来测试完全没有任何问题.</li>\n<li>这篇文章只讲解的eos的inline action的一个功能,下篇文章将使用它的更加实用的功能,而不仅仅是一个log的功能哈</li>\n<li>最近公司的项目很紧,所以能不能快速把新的知识点分享给大家还是未知数了呢,如果你也对dapp开发感兴趣,可以加个微信一起探讨 ^.^</li>\n<li>声明一点,我目前只对dapp的开发有点经验,至于源码分析,个人能力达不到呢.</li>\n<li>eth和eos虽然实现的机制不一样,但都是区块链啊.所以学习eos的时候,当我有些地方不怎么明白,我会再回去用eth的思想来思考一下这个eos的功能怎么用,目前看来,毕竟eos个人觉得比eth上手难度大很多呢</li>\n</ul>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>eos中有两种action,一种是本文要带大家理解使用的inline action,一种deffer action.<br>关于他们的差别我觉得主要一点就是前者一定是打包在同一个块中的,而且是事务操作.</p>\n</blockquote>\n<h4 id=\"surprise\"><a href=\"#surprise\" class=\"headerlink\" title=\"surprise\"></a>surprise</h4><blockquote>\n<ul>\n<li>jungle的测试网升级到2.0了,既然升级了,应该有不少的优化吧<a href=\"https://monitor.jungletestnet.io/\" target=\"_blank\" rel=\"noopener\">jugnle2.0地址</a>  </li>\n<li>由于在jungle测试网遇到很多坑,所以试了试另外一个测试网<a href=\"https://tools.cryptokylin.io/#/tools/create\" target=\"_blank\" rel=\"noopener\">麒麟</a>,用起来很不错,不用带梯子,建议大家在国内使用这个网络</li>\n<li>在kylin创建账号和获取测试币,直接在浏览器地址栏敲进去就可以了</li>\n</ul>\n</blockquote>\n<pre><code>http://faucet.cryptokylin.io/create_account?new_account_name\nhttp://faucet.cryptokylin.io/get_token?your_account_name\n</code></pre><h4 id=\"action的结果展示\"><a href=\"#action的结果展示\" class=\"headerlink\" title=\"action的结果展示\"></a>action的结果展示</h4><blockquote>\n<ul>\n<li>结果和之前的todolist内容差不多,只是多了一些额外的输出内容,而且这也是官方的例子</li>\n<li>那为什么还要记录呢?第一是我学习的过程,第二是看看具体的结果,第三是部署到测试网试试</li>\n<li>这里我也一些疑问?这样是否会多消耗ram? 如果不消耗,可以作为一些log的使用还是不错的,如果消耗,个人感觉没什么用,毕竟输出的每一个文字都是ram呢</li>\n<li>当然,它最主要的作用是可以调用其他的合约的内容,而同时保证在一个事务中,这个下篇文章给大家展示</li>\n<li>以太坊中的event有点类似本问所展示的作用,它可以监听,而且这部分log不消耗gas</li>\n<li>在交互中,也顺便展示了scatter中如何切换账号的操作</li>\n</ul>\n</blockquote>\n<p><img src=\"/eosinline/inline1.gif\" alt=\"inline\"></p>\n<h4 id=\"cpp源码展示\"><a href=\"#cpp源码展示\" class=\"headerlink\" title=\"cpp源码展示\"></a>cpp源码展示</h4><blockquote>\n<p>没什么需要多说的,注意inline action的写法</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;    \nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\npublic:\n    using contract::contract;\n    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}\n\n    [[eosio::action]]\n    void upsert(name user, std::string first_name, uint64_t age){\n        require_auth(user);\n        address_index addresses(_code,_code.value);\n        auto itr = addresses.find(user.value);\n        if(itr == addresses.end()){\n            addresses.emplace(user,[&amp;](auto&amp; row){\n                row.key = user;\n                row.first_name = first_name;\n                row.age = age;\n            });\n            send_summary(user, &quot;emplace data&quot;);\n        } else {\n            addresses.modify(itr, user, [&amp;](auto&amp; row){\n                        row.first_name = first_name;\n                        row.age = age;\n            });\n            send_summary(user, &quot;modify data&quot;);\n        }\n    }\n\n    [[eosio::action]]\n    void erase(name user){\n        require_auth(user);\n        address_index addresses(_self, _code.value);\n        auto itr = addresses.find(user.value);\n        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);\n        addresses.erase(itr);\n        send_summary(user, &quot;erase data&quot;);\n    }\n\n    [[eosio::action]]\n    void notify(name user, std::string){\n        require_auth(get_self());\n        require_recipient(user);\n    }\n\nprivate:\n    struct [[eosio::table]] person {\n        name key;\n        std::string first_name;\n        uint64_t age;\n\n        auto primary_key() const {\n            return key.value;\n        };\n    };\n    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;\n\n    void send_summary(name user, std::string msg){\n        action(\n            permission_level{get_self(),&quot;active&quot;_n},\n                get_self(),\n                &quot;notify&quot;_n,\n                std::make_tuple(user, name{user}.to_string() +msg)\n            ).send();\n    }\n};\nEOSIO_DISPATCH(addressbook,(upsert)(erase))\n</code></pre><h4 id=\"eth中的event的使用\"><a href=\"#eth中的event的使用\" class=\"headerlink\" title=\"eth中的event的使用\"></a>eth中的event的使用</h4><blockquote>\n<ul>\n<li>eth的event可以当做log使用,而且可以单独监听.这给了极大的方便了给任何一个人或则组织想知道某个合约函数的执行情况,我觉得这是一种非常好的机制.不知道eos中有没有类似的功能.</li>\n<li>也就是说合约中的信息可以主动推送给我们</li>\n<li>可以看到一个简单的node七八行代码就可以监听任何一个合约的所有事件的功能,前提你得拿到这个合约的地址和abi</li>\n<li>这里涉及了较多的以太坊的知识,只是为了向大家展示一下这个功能,不知道eos中目前有不有类似的功能,感觉它这个inline action即本篇文章描述的这个功能有点点类似,但是不知道能不能主动推送给我们呢?   </li>\n</ul>\n</blockquote>\n<p><img src=\"/eosinline/inline2.gif\" alt=\"inline\"></p>\n<h4 id=\"scatter遇到的一个小问题\"><a href=\"#scatter遇到的一个小问题\" class=\"headerlink\" title=\"scatter遇到的一个小问题\"></a>scatter遇到的一个小问题</h4><blockquote>\n<ul>\n<li>这里遇到了一个很纠结的问题,就是scatter无法弹出来.</li>\n<li>如果有遇到的同学,请重新安装scatter那两个lib,再次感谢某位朋友帮忙  </li>\n</ul>\n</blockquote>\n<pre><code>yarn remove eosjs scatterjs-core scatterjs-plugin-eosjs\nyarn add eosjs scatterjs-core scatterjs-plugin-eosjs\n</code></pre><h4 id=\"源码献上\"><a href=\"#源码献上\" class=\"headerlink\" title=\"源码献上\"></a>源码献上</h4><blockquote>\n<p>这里的源码包括本篇文章演示所有的合约和js文件,涉及到了eos和eth,各位同学可以选择性使用.</p>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-inline-action\" target=\"_blank\" rel=\"noopener\">inline action的使用</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><blockquote>\n<ul>\n<li>我为什么喜欢用测试网,而且总是要带梯子? 我觉得测试网与主网的环境操作一模一样,只是换了endpoint而已.如果在测试网能够按照设想运行,那么主网只需要改变一下下即可.而梯子对于我们这行的同学来说,应该是必备的.</li>\n<li>而现在用麒麟,不用梯子了哈.这点很重要</li>\n<li>由于eos的交易速度很快,所以用测试网来测试完全没有任何问题.</li>\n<li>这篇文章只讲解的eos的inline action的一个功能,下篇文章将使用它的更加实用的功能,而不仅仅是一个log的功能哈</li>\n<li>最近公司的项目很紧,所以能不能快速把新的知识点分享给大家还是未知数了呢,如果你也对dapp开发感兴趣,可以加个微信一起探讨 ^.^</li>\n<li>声明一点,我目前只对dapp的开发有点经验,至于源码分析,个人能力达不到呢.</li>\n<li>eth和eos虽然实现的机制不一样,但都是区块链啊.所以学习eos的时候,当我有些地方不怎么明白,我会再回去用eth的思想来思考一下这个eos的功能怎么用,目前看来,毕竟eos个人觉得比eth上手难度大很多呢</li>\n</ul>\n</blockquote>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#111;&#x6b;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#x40;&#x31;&#54;&#51;&#46;&#99;&#x6f;&#109;</a></p>\n"},{"title":"eos中inline action的使用方式 (续)","date":"2018-12-08T03:47:24.000Z","_content":"\n#### 填坑\n 这里填一个一直以来对于我来说的一个坑,也在之前的文章的文章误导了大家关于这个event.   \n  \n1. 之前我说以太坊区块链会主动通知我们当有数据发生变化,这是经过几天的琢磨发现使用了web3.js库造成的错觉.\n2. 也正是由于这样,我没有在eos中找到类似的方法,所以去看看了web3.js的源码,发现它是才用轮询最新区块的内容而进行的事件的匹配然后产生的回调.  \n3. [requestmanager.js](https://github.com/ethereum/web3.js/blob/develop/lib/web3/requestmanager.js),如果你感兴趣,可以看看这个文件就大概知道了,更加进一步,你可以发现一些更有趣并且非常熟悉的东西,那就是在[methods.js](https://github.com/ethereum/web3.js/blob/develop/lib/web3/methods/eth.js)这个文件中 \n \n4. 这是web3提供的方法,既然这样,那我们是不是不调用web3的方法也可以得到同样的效果呢?答案肯定是可以的.通过以上的两个文件,那我们用node也来写一个监听最新块的方法\n\n\t\tconst axios = require('axios')\n\t\tconst obj = { \"jsonrpc\": \"2.0\", \"method\": \"eth_getBlockByNumber\", \"params\": [\"latest\", true], \"id\": 1 }\n\t\t\n\t\tgetBlockInfo()\n\t\t\n\t\tfunction getBlockInfo() {\n\t\t    axios.request('https://mainnet.infura.io/v3/e8947e207ac142519554d382200e663b', {\n\t\t        method: 'post',\n\t\t        header: {\n\t\t            'Content-type': 'application/json'\n\t\t        },\n\t\t        data: JSON.stringify(obj)\n\t\t    }).then(response => response.data).then(res => {\n\t\t            console.log(res)\n\t\t        })\n\t\t}\n5. 上面的方式可以监听到最新一个块的所有交易信息,然后根据条件筛选即可达到我们要的目的了.这里注意两点:一是json-rpc的请求格式,二是json-rpc提供的endpoint,我这里使用的是infrua提供的.其实metamask也是使用的这个端点,所以使用web3的时候会让你提供provider,其实就是提供的这个端点\n\n#### 前言\n> 填完坑后,给出个结论   \n\n> * 区块链从来不会主动推送消息给各位同学的\n> * 所有的数据都是在区块里面的,只要在区块链发生的所有操作,均可以通过查询区块得到结果.\n> * 至于web3或者是其他库提供的监听的功能,实际上是封装了这个轮询的过程\n\n> 本篇文章还是属于inline action的范畴.就是如何在合约中进行eos的交易\n\n#### 在合约中交易eos\n1. 直接调用eosjs提供的api,这种方式比较简单,也不是我要说的重点(这里使用的是scatter官网提供的这个例子)\n\n\t\tconst transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\t\n\t        eos.transfer(account.name, 'helloworld', '1.0000 EOS', 'memo', transactionOptions).then(trx => {\n\t            // That's it!\n\t            console.log(`Transaction ID: ${trx.transaction_id}`);\n\t        }).catch(error => {\n\t            console.error(error);\n\t        });\n\n2. 这里有一种需求,就是在执行某个action的时候,需要预先支付一定费用的eos,当达到某种条件时候,再返回给调用者一定的量的eos.\n3. 根据需求我们写出了如下的代码,(注意asset这个类型,必须这样传入,关于它的更详细的用法得去看看api了哈;二是now()这个函数返回当前的时间戳,真实环境中这都是固定的,不能用来产生随机数).\n4. 还记得之前的权限操作吗? 如果要在合约中转账,必须给合约添加eosio.code的权限,我这个合约现在部署在shaokun11113中的,那么就要给shaokun11113添加eosio.code权限.\n5. 添加了权限之后,我们使用shaokun11112来调用这个合约,可以看到当shaokun11113向shaokun11112转账可以成功,但是shaokun11112向shaokun11113转账是没有权限的.\n6. 那么,我们在shaokun11112中给shaokun11113添加eosio.code的权限\n7. 添加权限后,可以看到一切转账成功了\n8. 那么就实现了在合约中进行transfer eos的操作\n\n\n\t\t#include <eosiolib/eosio.hpp>\n\t\t#include <eosiolib/asset.hpp>\t\n\t\tusing namespace eosio;\n\t\t\n\t\tclass [[eosio::contract]] lucky : eosio::contract {\n\t\t\n\t\tpublic:\n\t\t\tusing contract::contract;\n\t\t\tlucky(name r,name c, datastream<const char*> ds):contract(r,c,ds){}\n\t\n\t\t[[eosio::action]]\n\t\tvoid play(name player, const asset& quantity) {\n\t\t\trequire_auth(player);\n\t\t\tif(now() % 2 == 1){\n\t\t\t\taction(\n\t\t\tpermission_level{get_self(),\"active\"_n},  //所需要的权限结构\n\t\t\t\"eosio.token\"_n,\t\t\t\t\t\t  // 调用的合约名称\n\t\t\t\"transfer\"_n,\t\t\t\t\t\t\t  // 合约的方法\n\t\t\tstd::make_tuple(get_self(),player, quantity, std::string(\"shao kun game\")) // 传递的参数\n\t\t\t\t).send();\n\t\t\t} else {\n\t\t\t\taction(\n\t\t\t\tpermission_level{player,\"active\"_n},\n\t\t\t\t\"eosio.token\"_n,\n\t\t\t\t\"transfer\"_n,\n\t\t\t\tstd::make_tuple(player,get_self(), quantity, std::string(\"shao kun game\"))\n\t\t\t\t).send();\n\t\t\t}\n\t\t};\n\t\t};\n\t\tEOSIO_DISPATCH(lucky,(play))\n![shaokun](/eosinline/inline3.gif)\n\n#### 以太坊中eth使用合约进行交易\n* 在以太坊中,如果某个方法要接收eth,必须给这个方法加上payable的关键字即可,合约中可以通过msg.value获取到交易的金额.如果此方法不加上payable而调用时传递了金额,那么调用此方法会失败  \n* 如果要在初始化的时候传入eth,必须给构造方法加上payable\n\n\t\tcontract Test4 {\n\t    \n\t    constructor() public payable {\n\t        \n\t    }\n\t    \n\t    function withPayable() public payable {\n\t        if(now % 2 == 0 ){\n\t            msg.sender.transfer(msg.value * 2);\n\t        }\n\t    }\n\t    \n\t     function withoutPayable() public {\n\t         \n\t     }\n\t\t}\n![shaokun](/eosinline/inline4.gif)\n\n#### 源码与总结\n* [合约transfer](https://github.com/shaokun11/eosabout/tree/eos-transfer)\n* 相对于eth来说,个人觉得eos中在合约中转账过于麻烦,这需要用户手动去给合约设置转账权限\n* 如果哪位同学有更好的关于转账的方法,请告知一下,个人觉得在合约中进行转账还是很常见的需求\n* 官方的eos dice合约现在已经移除了,但是可以在历史中找到[eos dice](https://github.com/EOSIO/eos/blob/v1.0.0/contracts/dice/dice.cpp) 有兴趣的同学可以研究一下\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解3.md","raw":"---\ntitle: eos中inline action的使用方式 (续)\ndate: 2018-12-08 11:47:24\n---\n\n#### 填坑\n 这里填一个一直以来对于我来说的一个坑,也在之前的文章的文章误导了大家关于这个event.   \n  \n1. 之前我说以太坊区块链会主动通知我们当有数据发生变化,这是经过几天的琢磨发现使用了web3.js库造成的错觉.\n2. 也正是由于这样,我没有在eos中找到类似的方法,所以去看看了web3.js的源码,发现它是才用轮询最新区块的内容而进行的事件的匹配然后产生的回调.  \n3. [requestmanager.js](https://github.com/ethereum/web3.js/blob/develop/lib/web3/requestmanager.js),如果你感兴趣,可以看看这个文件就大概知道了,更加进一步,你可以发现一些更有趣并且非常熟悉的东西,那就是在[methods.js](https://github.com/ethereum/web3.js/blob/develop/lib/web3/methods/eth.js)这个文件中 \n \n4. 这是web3提供的方法,既然这样,那我们是不是不调用web3的方法也可以得到同样的效果呢?答案肯定是可以的.通过以上的两个文件,那我们用node也来写一个监听最新块的方法\n\n\t\tconst axios = require('axios')\n\t\tconst obj = { \"jsonrpc\": \"2.0\", \"method\": \"eth_getBlockByNumber\", \"params\": [\"latest\", true], \"id\": 1 }\n\t\t\n\t\tgetBlockInfo()\n\t\t\n\t\tfunction getBlockInfo() {\n\t\t    axios.request('https://mainnet.infura.io/v3/e8947e207ac142519554d382200e663b', {\n\t\t        method: 'post',\n\t\t        header: {\n\t\t            'Content-type': 'application/json'\n\t\t        },\n\t\t        data: JSON.stringify(obj)\n\t\t    }).then(response => response.data).then(res => {\n\t\t            console.log(res)\n\t\t        })\n\t\t}\n5. 上面的方式可以监听到最新一个块的所有交易信息,然后根据条件筛选即可达到我们要的目的了.这里注意两点:一是json-rpc的请求格式,二是json-rpc提供的endpoint,我这里使用的是infrua提供的.其实metamask也是使用的这个端点,所以使用web3的时候会让你提供provider,其实就是提供的这个端点\n\n#### 前言\n> 填完坑后,给出个结论   \n\n> * 区块链从来不会主动推送消息给各位同学的\n> * 所有的数据都是在区块里面的,只要在区块链发生的所有操作,均可以通过查询区块得到结果.\n> * 至于web3或者是其他库提供的监听的功能,实际上是封装了这个轮询的过程\n\n> 本篇文章还是属于inline action的范畴.就是如何在合约中进行eos的交易\n\n#### 在合约中交易eos\n1. 直接调用eosjs提供的api,这种方式比较简单,也不是我要说的重点(这里使用的是scatter官网提供的这个例子)\n\n\t\tconst transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\t\n\t        eos.transfer(account.name, 'helloworld', '1.0000 EOS', 'memo', transactionOptions).then(trx => {\n\t            // That's it!\n\t            console.log(`Transaction ID: ${trx.transaction_id}`);\n\t        }).catch(error => {\n\t            console.error(error);\n\t        });\n\n2. 这里有一种需求,就是在执行某个action的时候,需要预先支付一定费用的eos,当达到某种条件时候,再返回给调用者一定的量的eos.\n3. 根据需求我们写出了如下的代码,(注意asset这个类型,必须这样传入,关于它的更详细的用法得去看看api了哈;二是now()这个函数返回当前的时间戳,真实环境中这都是固定的,不能用来产生随机数).\n4. 还记得之前的权限操作吗? 如果要在合约中转账,必须给合约添加eosio.code的权限,我这个合约现在部署在shaokun11113中的,那么就要给shaokun11113添加eosio.code权限.\n5. 添加了权限之后,我们使用shaokun11112来调用这个合约,可以看到当shaokun11113向shaokun11112转账可以成功,但是shaokun11112向shaokun11113转账是没有权限的.\n6. 那么,我们在shaokun11112中给shaokun11113添加eosio.code的权限\n7. 添加权限后,可以看到一切转账成功了\n8. 那么就实现了在合约中进行transfer eos的操作\n\n\n\t\t#include <eosiolib/eosio.hpp>\n\t\t#include <eosiolib/asset.hpp>\t\n\t\tusing namespace eosio;\n\t\t\n\t\tclass [[eosio::contract]] lucky : eosio::contract {\n\t\t\n\t\tpublic:\n\t\t\tusing contract::contract;\n\t\t\tlucky(name r,name c, datastream<const char*> ds):contract(r,c,ds){}\n\t\n\t\t[[eosio::action]]\n\t\tvoid play(name player, const asset& quantity) {\n\t\t\trequire_auth(player);\n\t\t\tif(now() % 2 == 1){\n\t\t\t\taction(\n\t\t\tpermission_level{get_self(),\"active\"_n},  //所需要的权限结构\n\t\t\t\"eosio.token\"_n,\t\t\t\t\t\t  // 调用的合约名称\n\t\t\t\"transfer\"_n,\t\t\t\t\t\t\t  // 合约的方法\n\t\t\tstd::make_tuple(get_self(),player, quantity, std::string(\"shao kun game\")) // 传递的参数\n\t\t\t\t).send();\n\t\t\t} else {\n\t\t\t\taction(\n\t\t\t\tpermission_level{player,\"active\"_n},\n\t\t\t\t\"eosio.token\"_n,\n\t\t\t\t\"transfer\"_n,\n\t\t\t\tstd::make_tuple(player,get_self(), quantity, std::string(\"shao kun game\"))\n\t\t\t\t).send();\n\t\t\t}\n\t\t};\n\t\t};\n\t\tEOSIO_DISPATCH(lucky,(play))\n![shaokun](/eosinline/inline3.gif)\n\n#### 以太坊中eth使用合约进行交易\n* 在以太坊中,如果某个方法要接收eth,必须给这个方法加上payable的关键字即可,合约中可以通过msg.value获取到交易的金额.如果此方法不加上payable而调用时传递了金额,那么调用此方法会失败  \n* 如果要在初始化的时候传入eth,必须给构造方法加上payable\n\n\t\tcontract Test4 {\n\t    \n\t    constructor() public payable {\n\t        \n\t    }\n\t    \n\t    function withPayable() public payable {\n\t        if(now % 2 == 0 ){\n\t            msg.sender.transfer(msg.value * 2);\n\t        }\n\t    }\n\t    \n\t     function withoutPayable() public {\n\t         \n\t     }\n\t\t}\n![shaokun](/eosinline/inline4.gif)\n\n#### 源码与总结\n* [合约transfer](https://github.com/shaokun11/eosabout/tree/eos-transfer)\n* 相对于eth来说,个人觉得eos中在合约中转账过于麻烦,这需要用户手动去给合约设置转账权限\n* 如果哪位同学有更好的关于转账的方法,请告知一下,个人觉得在合约中进行转账还是很常见的需求\n* 官方的eos dice合约现在已经移除了,但是可以在历史中找到[eos dice](https://github.com/EOSIO/eos/blob/v1.0.0/contracts/dice/dice.cpp) 有兴趣的同学可以研究一下\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解3","published":1,"updated":"2019-02-18T13:13:08.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b51v0007nh7slc999qa7","content":"<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><p> 这里填一个一直以来对于我来说的一个坑,也在之前的文章的文章误导了大家关于这个event.   </p>\n<ol>\n<li>之前我说以太坊区块链会主动通知我们当有数据发生变化,这是经过几天的琢磨发现使用了web3.js库造成的错觉.</li>\n<li>也正是由于这样,我没有在eos中找到类似的方法,所以去看看了web3.js的源码,发现它是才用轮询最新区块的内容而进行的事件的匹配然后产生的回调.  </li>\n<li><p><a href=\"https://github.com/ethereum/web3.js/blob/develop/lib/web3/requestmanager.js\" target=\"_blank\" rel=\"noopener\">requestmanager.js</a>,如果你感兴趣,可以看看这个文件就大概知道了,更加进一步,你可以发现一些更有趣并且非常熟悉的东西,那就是在<a href=\"https://github.com/ethereum/web3.js/blob/develop/lib/web3/methods/eth.js\" target=\"_blank\" rel=\"noopener\">methods.js</a>这个文件中 </p>\n</li>\n<li><p>这是web3提供的方法,既然这样,那我们是不是不调用web3的方法也可以得到同样的效果呢?答案肯定是可以的.通过以上的两个文件,那我们用node也来写一个监听最新块的方法</p>\n<pre><code>const axios = require(&apos;axios&apos;)\nconst obj = { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;eth_getBlockByNumber&quot;, &quot;params&quot;: [&quot;latest&quot;, true], &quot;id&quot;: 1 }\n\ngetBlockInfo()\n\nfunction getBlockInfo() {\n    axios.request(&apos;https://mainnet.infura.io/v3/e8947e207ac142519554d382200e663b&apos;, {\n        method: &apos;post&apos;,\n        header: {\n            &apos;Content-type&apos;: &apos;application/json&apos;\n        },\n        data: JSON.stringify(obj)\n    }).then(response =&gt; response.data).then(res =&gt; {\n            console.log(res)\n        })\n}\n</code></pre></li>\n<li>上面的方式可以监听到最新一个块的所有交易信息,然后根据条件筛选即可达到我们要的目的了.这里注意两点:一是json-rpc的请求格式,二是json-rpc提供的endpoint,我这里使用的是infrua提供的.其实metamask也是使用的这个端点,所以使用web3的时候会让你提供provider,其实就是提供的这个端点</li>\n</ol>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>填完坑后,给出个结论   </p>\n</blockquote>\n<blockquote>\n<ul>\n<li>区块链从来不会主动推送消息给各位同学的</li>\n<li>所有的数据都是在区块里面的,只要在区块链发生的所有操作,均可以通过查询区块得到结果.</li>\n<li>至于web3或者是其他库提供的监听的功能,实际上是封装了这个轮询的过程</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>本篇文章还是属于inline action的范畴.就是如何在合约中进行eos的交易</p>\n</blockquote>\n<h4 id=\"在合约中交易eos\"><a href=\"#在合约中交易eos\" class=\"headerlink\" title=\"在合约中交易eos\"></a>在合约中交易eos</h4><ol>\n<li><p>直接调用eosjs提供的api,这种方式比较简单,也不是我要说的重点(这里使用的是scatter官网提供的这个例子)</p>\n<pre><code>const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\n    eos.transfer(account.name, &apos;helloworld&apos;, &apos;1.0000 EOS&apos;, &apos;memo&apos;, transactionOptions).then(trx =&gt; {\n        // That&apos;s it!\n        console.log(`Transaction ID: ${trx.transaction_id}`);\n    }).catch(error =&gt; {\n        console.error(error);\n    });\n</code></pre></li>\n<li><p>这里有一种需求,就是在执行某个action的时候,需要预先支付一定费用的eos,当达到某种条件时候,再返回给调用者一定的量的eos.</p>\n</li>\n<li>根据需求我们写出了如下的代码,(注意asset这个类型,必须这样传入,关于它的更详细的用法得去看看api了哈;二是now()这个函数返回当前的时间戳,真实环境中这都是固定的,不能用来产生随机数).</li>\n<li>还记得之前的权限操作吗? 如果要在合约中转账,必须给合约添加eosio.code的权限,我这个合约现在部署在shaokun11113中的,那么就要给shaokun11113添加eosio.code权限.</li>\n<li>添加了权限之后,我们使用shaokun11112来调用这个合约,可以看到当shaokun11113向shaokun11112转账可以成功,但是shaokun11112向shaokun11113转账是没有权限的.</li>\n<li>那么,我们在shaokun11112中给shaokun11113添加eosio.code的权限</li>\n<li>添加权限后,可以看到一切转账成功了</li>\n<li>那么就实现了在合约中进行transfer eos的操作</li>\n</ol>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n#include &lt;eosiolib/asset.hpp&gt;    \nusing namespace eosio;\n\nclass [[eosio::contract]] lucky : eosio::contract {\n\npublic:\n    using contract::contract;\n    lucky(name r,name c, datastream&lt;const char*&gt; ds):contract(r,c,ds){}\n\n[[eosio::action]]\nvoid play(name player, const asset&amp; quantity) {\n    require_auth(player);\n    if(now() % 2 == 1){\n        action(\n    permission_level{get_self(),&quot;active&quot;_n},  //所需要的权限结构\n    &quot;eosio.token&quot;_n,                          // 调用的合约名称\n    &quot;transfer&quot;_n,                              // 合约的方法\n    std::make_tuple(get_self(),player, quantity, std::string(&quot;shao kun game&quot;)) // 传递的参数\n        ).send();\n    } else {\n        action(\n        permission_level{player,&quot;active&quot;_n},\n        &quot;eosio.token&quot;_n,\n        &quot;transfer&quot;_n,\n        std::make_tuple(player,get_self(), quantity, std::string(&quot;shao kun game&quot;))\n        ).send();\n    }\n};\n};\nEOSIO_DISPATCH(lucky,(play))\n</code></pre><p><img src=\"/eosinline/inline3.gif\" alt=\"shaokun\"></p>\n<h4 id=\"以太坊中eth使用合约进行交易\"><a href=\"#以太坊中eth使用合约进行交易\" class=\"headerlink\" title=\"以太坊中eth使用合约进行交易\"></a>以太坊中eth使用合约进行交易</h4><ul>\n<li>在以太坊中,如果某个方法要接收eth,必须给这个方法加上payable的关键字即可,合约中可以通过msg.value获取到交易的金额.如果此方法不加上payable而调用时传递了金额,那么调用此方法会失败  </li>\n<li><p>如果要在初始化的时候传入eth,必须给构造方法加上payable</p>\n<pre><code>contract Test4 {\n\nconstructor() public payable {\n\n}\n\nfunction withPayable() public payable {\n    if(now % 2 == 0 ){\n        msg.sender.transfer(msg.value * 2);\n    }\n}\n\n function withoutPayable() public {\n\n }\n}\n</code></pre><p><img src=\"/eosinline/inline4.gif\" alt=\"shaokun\"></p>\n</li>\n</ul>\n<h4 id=\"源码与总结\"><a href=\"#源码与总结\" class=\"headerlink\" title=\"源码与总结\"></a>源码与总结</h4><ul>\n<li><a href=\"https://github.com/shaokun11/eosabout/tree/eos-transfer\" target=\"_blank\" rel=\"noopener\">合约transfer</a></li>\n<li>相对于eth来说,个人觉得eos中在合约中转账过于麻烦,这需要用户手动去给合约设置转账权限</li>\n<li>如果哪位同学有更好的关于转账的方法,请告知一下,个人觉得在合约中进行转账还是很常见的需求</li>\n<li>官方的eos dice合约现在已经移除了,但是可以在历史中找到<a href=\"https://github.com/EOSIO/eos/blob/v1.0.0/contracts/dice/dice.cpp\" target=\"_blank\" rel=\"noopener\">eos dice</a> 有兴趣的同学可以研究一下</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#117;&#110;&#x6e;&#x79;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#117;&#110;&#x6e;&#x79;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><p> 这里填一个一直以来对于我来说的一个坑,也在之前的文章的文章误导了大家关于这个event.   </p>\n<ol>\n<li>之前我说以太坊区块链会主动通知我们当有数据发生变化,这是经过几天的琢磨发现使用了web3.js库造成的错觉.</li>\n<li>也正是由于这样,我没有在eos中找到类似的方法,所以去看看了web3.js的源码,发现它是才用轮询最新区块的内容而进行的事件的匹配然后产生的回调.  </li>\n<li><p><a href=\"https://github.com/ethereum/web3.js/blob/develop/lib/web3/requestmanager.js\" target=\"_blank\" rel=\"noopener\">requestmanager.js</a>,如果你感兴趣,可以看看这个文件就大概知道了,更加进一步,你可以发现一些更有趣并且非常熟悉的东西,那就是在<a href=\"https://github.com/ethereum/web3.js/blob/develop/lib/web3/methods/eth.js\" target=\"_blank\" rel=\"noopener\">methods.js</a>这个文件中 </p>\n</li>\n<li><p>这是web3提供的方法,既然这样,那我们是不是不调用web3的方法也可以得到同样的效果呢?答案肯定是可以的.通过以上的两个文件,那我们用node也来写一个监听最新块的方法</p>\n<pre><code>const axios = require(&apos;axios&apos;)\nconst obj = { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;eth_getBlockByNumber&quot;, &quot;params&quot;: [&quot;latest&quot;, true], &quot;id&quot;: 1 }\n\ngetBlockInfo()\n\nfunction getBlockInfo() {\n    axios.request(&apos;https://mainnet.infura.io/v3/e8947e207ac142519554d382200e663b&apos;, {\n        method: &apos;post&apos;,\n        header: {\n            &apos;Content-type&apos;: &apos;application/json&apos;\n        },\n        data: JSON.stringify(obj)\n    }).then(response =&gt; response.data).then(res =&gt; {\n            console.log(res)\n        })\n}\n</code></pre></li>\n<li>上面的方式可以监听到最新一个块的所有交易信息,然后根据条件筛选即可达到我们要的目的了.这里注意两点:一是json-rpc的请求格式,二是json-rpc提供的endpoint,我这里使用的是infrua提供的.其实metamask也是使用的这个端点,所以使用web3的时候会让你提供provider,其实就是提供的这个端点</li>\n</ol>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>填完坑后,给出个结论   </p>\n</blockquote>\n<blockquote>\n<ul>\n<li>区块链从来不会主动推送消息给各位同学的</li>\n<li>所有的数据都是在区块里面的,只要在区块链发生的所有操作,均可以通过查询区块得到结果.</li>\n<li>至于web3或者是其他库提供的监听的功能,实际上是封装了这个轮询的过程</li>\n</ul>\n</blockquote>\n<blockquote>\n<p>本篇文章还是属于inline action的范畴.就是如何在合约中进行eos的交易</p>\n</blockquote>\n<h4 id=\"在合约中交易eos\"><a href=\"#在合约中交易eos\" class=\"headerlink\" title=\"在合约中交易eos\"></a>在合约中交易eos</h4><ol>\n<li><p>直接调用eosjs提供的api,这种方式比较简单,也不是我要说的重点(这里使用的是scatter官网提供的这个例子)</p>\n<pre><code>const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\n    eos.transfer(account.name, &apos;helloworld&apos;, &apos;1.0000 EOS&apos;, &apos;memo&apos;, transactionOptions).then(trx =&gt; {\n        // That&apos;s it!\n        console.log(`Transaction ID: ${trx.transaction_id}`);\n    }).catch(error =&gt; {\n        console.error(error);\n    });\n</code></pre></li>\n<li><p>这里有一种需求,就是在执行某个action的时候,需要预先支付一定费用的eos,当达到某种条件时候,再返回给调用者一定的量的eos.</p>\n</li>\n<li>根据需求我们写出了如下的代码,(注意asset这个类型,必须这样传入,关于它的更详细的用法得去看看api了哈;二是now()这个函数返回当前的时间戳,真实环境中这都是固定的,不能用来产生随机数).</li>\n<li>还记得之前的权限操作吗? 如果要在合约中转账,必须给合约添加eosio.code的权限,我这个合约现在部署在shaokun11113中的,那么就要给shaokun11113添加eosio.code权限.</li>\n<li>添加了权限之后,我们使用shaokun11112来调用这个合约,可以看到当shaokun11113向shaokun11112转账可以成功,但是shaokun11112向shaokun11113转账是没有权限的.</li>\n<li>那么,我们在shaokun11112中给shaokun11113添加eosio.code的权限</li>\n<li>添加权限后,可以看到一切转账成功了</li>\n<li>那么就实现了在合约中进行transfer eos的操作</li>\n</ol>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n#include &lt;eosiolib/asset.hpp&gt;    \nusing namespace eosio;\n\nclass [[eosio::contract]] lucky : eosio::contract {\n\npublic:\n    using contract::contract;\n    lucky(name r,name c, datastream&lt;const char*&gt; ds):contract(r,c,ds){}\n\n[[eosio::action]]\nvoid play(name player, const asset&amp; quantity) {\n    require_auth(player);\n    if(now() % 2 == 1){\n        action(\n    permission_level{get_self(),&quot;active&quot;_n},  //所需要的权限结构\n    &quot;eosio.token&quot;_n,                          // 调用的合约名称\n    &quot;transfer&quot;_n,                              // 合约的方法\n    std::make_tuple(get_self(),player, quantity, std::string(&quot;shao kun game&quot;)) // 传递的参数\n        ).send();\n    } else {\n        action(\n        permission_level{player,&quot;active&quot;_n},\n        &quot;eosio.token&quot;_n,\n        &quot;transfer&quot;_n,\n        std::make_tuple(player,get_self(), quantity, std::string(&quot;shao kun game&quot;))\n        ).send();\n    }\n};\n};\nEOSIO_DISPATCH(lucky,(play))\n</code></pre><p><img src=\"/eosinline/inline3.gif\" alt=\"shaokun\"></p>\n<h4 id=\"以太坊中eth使用合约进行交易\"><a href=\"#以太坊中eth使用合约进行交易\" class=\"headerlink\" title=\"以太坊中eth使用合约进行交易\"></a>以太坊中eth使用合约进行交易</h4><ul>\n<li>在以太坊中,如果某个方法要接收eth,必须给这个方法加上payable的关键字即可,合约中可以通过msg.value获取到交易的金额.如果此方法不加上payable而调用时传递了金额,那么调用此方法会失败  </li>\n<li><p>如果要在初始化的时候传入eth,必须给构造方法加上payable</p>\n<pre><code>contract Test4 {\n\nconstructor() public payable {\n\n}\n\nfunction withPayable() public payable {\n    if(now % 2 == 0 ){\n        msg.sender.transfer(msg.value * 2);\n    }\n}\n\n function withoutPayable() public {\n\n }\n}\n</code></pre><p><img src=\"/eosinline/inline4.gif\" alt=\"shaokun\"></p>\n</li>\n</ul>\n<h4 id=\"源码与总结\"><a href=\"#源码与总结\" class=\"headerlink\" title=\"源码与总结\"></a>源码与总结</h4><ul>\n<li><a href=\"https://github.com/shaokun11/eosabout/tree/eos-transfer\" target=\"_blank\" rel=\"noopener\">合约transfer</a></li>\n<li>相对于eth来说,个人觉得eos中在合约中转账过于麻烦,这需要用户手动去给合约设置转账权限</li>\n<li>如果哪位同学有更好的关于转账的方法,请告知一下,个人觉得在合约中进行转账还是很常见的需求</li>\n<li>官方的eos dice合约现在已经移除了,但是可以在历史中找到<a href=\"https://github.com/EOSIO/eos/blob/v1.0.0/contracts/dice/dice.cpp\" target=\"_blank\" rel=\"noopener\">eos dice</a> 有兴趣的同学可以研究一下</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#117;&#110;&#x6e;&#x79;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#117;&#110;&#x6e;&#x79;&#64;&#x31;&#x36;&#51;&#x2e;&#x63;&#x6f;&#x6d;</a></p>\n"},{"title":"eos的dispatcher的使用(2)","date":"2019-01-19T12:25:13.000Z","_content":"\n#### 前言\n > 希望阅读本篇文章的同学去看一下上一篇文章,不然思路断了接不上就有点麻烦了    \n \n#### 多说两句\n * 话说以太坊的分叉计划又延期了,而此次的升级主要是针对底层的安全机制,所以可见写智能合约的最关键点还是安全第一吧,\n * eos一直被攻击,从未被停止.最近的eos因为一个derferred action的问题的漏洞又被黑客利用了,哎... 受伤的总是开发者\n * 大家写的合约还有一个点,就是安全.这里一个朋友已经开发了一款应用,也已经上线到主网,各种测试也做了,什么逻辑,压力,数据,前端页面的跳转等等... 然而当项目上线后,他找到我对我说,别人可以绕过前端代码直接调用的它的合约...  我只能说,这就是智能合约,你所写的合约是全世界的人(当然,如果你的项目很成功,那么黑客也是由兴趣来光顾的)都可以调用的,除非你做一些权限的验证.在eos上还好,可以通过升级合约来弥补,而且code还不用开源.但是在eth,code is law,code还要开源,所以各位同学想想这个合约安全的重要性.eos底层虽然还有bug,我们无法避免,但是我们还是应该对我们的应用层的逻辑进行严格的测试,这样开发的智能合约才经得住世界人民的考验,你说是不是呢?\n\n#### 自定义dispatcher 方式2\n>按照上篇文章的做法,那么我们实现了自己定义apply函数来取代EOSIO_DISPATCHER,但是实现的功能是一模一样的,那我们这样做的目的是什么呢?\n\n* 那么接下来我们继续按照官方的教程走,通过另外一种方式来实现.\n* 那么此种方式相对于上一中方式有什么区别呢?\n\n```\nThis pattern provides more control over security at the expense of maintainability. Utilizing if...else if statements as opposed to a switch inherently provides more granularity.\n此模式以可维护性为代价提供了对安全性的更多控制。利用if ... else if语句而不是switch提供更精细的控制。\n```\n好吧,既然看起来优点这么多,那么我们就看看是怎么样实现的吧\n\n```\nextern \"C\" {\n  void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n    addressbook _addressbook(receiver);\n    if(code==receiver && action==name(\"upsert\").value) {\n      execute_action(name(receiver), name(code), &addressbook::upsert );\n    }\n    else if(code==receiver && action==name(\"notify\").value) {\n      execute_action(name(receiver), name(code), &addressbook::notify );\n    }\n    else if(code==receiver && action==name(\"erase\").value) {\n      execute_action(name(receiver), name(code), &addressbook::erase );\n    }\n    else if(code==name(\"eosio.token\").value && action==name(\"transfer\").value) {\n      execute_action(name(receiver), name(code), &addressbook::transfer );\n    }\n  }\n};\n```\n* 初看和上一篇文章简直是一模一样,就是把switch换成了if...else,看来官方真实说的大实话呢\n* 不过,最后一个else多了一个判断,addressbook去调用transfer方法,可是我们没有啊,既然是这样,那我们就依样画葫芦,待会写一个吧\n* 第二点,最后一个else判断变成了code == eosio.token,这就是我们上篇文章说的这个code的意义了.而eosio.token是系统的账号,当发生eos或者其他代币时才会调用这个方法呢,那么我猜测一下这个判断是当发生eosio.token执行transfer的时候,将会执行我们合约transfer方法\n\n#### 结果验证\n>按照上面说的,我们就按照我们得思路先写一个吧,那么就加一个transfer方法如下.\n\n```\n void transfer(uint64_t receiver, uint64_t code){\n    send_summary(name(code), \"eosio.token transfer\");\n  }\n```\n* 很简单,当发生transfer时,我们出发一个inline action来记录一下数据\n* 那我们看下结果,结果报错了???? \n* why? 我们仅仅是转账啊,自己转出去或者别人转进来,现在都失败了\n\n#### 结果分析\n*Authorization failure with inline action sent to self*\n\n* 权限不允许给自己发送内联action?\n* 这是什么情况?给自己发送内联action还要权限?\n* 想想想... 对了,要让自己的合约调用其他合约需要给eosio.code发送权限,那我们接下来试试看看是不是这个原因呢\n\n![shaokun](/img_eos1/eos_react9.gif)\n\n#### 再次验证分析结果\n* 使用owner权限,给eosio.code授予active权限\n* 执行相互转账\n* 查看是否能够出发我们自定义的内联action(经过上一步的操作,和我们之前的经验,它应该是调用了我们得inline action,不过还是得看事实说话呢)\n* 去kylin,确实达到了我们的结果,无论转账转出或者转入,那么我们都发送了一个inline action  \n![shaokun](/img_eos1/eos_react10.gif)\n\n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-02)  \n\n* 这里说一下这个源码,我已经编译好的abi和wasm文件,各位同学可以直接部署,如果要修改源码,就得自己编译了.不同的编译版本可能会有不同的eos语法,我这里用的是cdt1.3.2\n* 还有,部署的时候,最好文件夹名字和主合约的名字一样,这样可以可以避免一些想不到的奇奇怪怪的错误.\n\n\n#### 结论\n* 关于上一篇文章开篇提到的类似以太坊中payable关键字的功能,我想各位同学应该知道怎么实现了吧\n* 通过我们目前自己实现apply的方式,不用eosio.code授予权限,我们是可以拒绝或者转出eos的,当然这样的方式达到了目的,但是不够优雅\n* 通过结果,我们发现了我们也可以在合约中检查监听到eos的转出和转入,那么我们是否可以通过此做出相应的动作呢?答案是可以的,具体怎么使用我们以后的文章再说\n* 那么我们怎么优雅的实现拒绝账户eos的交易呢,我觉得最简单的方法就是调用eosio_assert(1==2);哈哈,^_^\n* 问题又来了?如果我不调用inline action,那么是不是我不用授权给eosio.code就可以实现转账呢?答案是可以的,本篇文章主要是为了看到具体的转账结果,所以用了inline action,相当于也给大家复习一下这个权限吧.至于这个不使用inline action的,这个可以交由各位同学自己去实现了哈\n* 问题又来了?那我要怎么拿取转账的信息呢?\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解5.md","raw":"---\ntitle: eos的dispatcher的使用(2)\ndate: 2019-01-19 20:25:13\n---\n\n#### 前言\n > 希望阅读本篇文章的同学去看一下上一篇文章,不然思路断了接不上就有点麻烦了    \n \n#### 多说两句\n * 话说以太坊的分叉计划又延期了,而此次的升级主要是针对底层的安全机制,所以可见写智能合约的最关键点还是安全第一吧,\n * eos一直被攻击,从未被停止.最近的eos因为一个derferred action的问题的漏洞又被黑客利用了,哎... 受伤的总是开发者\n * 大家写的合约还有一个点,就是安全.这里一个朋友已经开发了一款应用,也已经上线到主网,各种测试也做了,什么逻辑,压力,数据,前端页面的跳转等等... 然而当项目上线后,他找到我对我说,别人可以绕过前端代码直接调用的它的合约...  我只能说,这就是智能合约,你所写的合约是全世界的人(当然,如果你的项目很成功,那么黑客也是由兴趣来光顾的)都可以调用的,除非你做一些权限的验证.在eos上还好,可以通过升级合约来弥补,而且code还不用开源.但是在eth,code is law,code还要开源,所以各位同学想想这个合约安全的重要性.eos底层虽然还有bug,我们无法避免,但是我们还是应该对我们的应用层的逻辑进行严格的测试,这样开发的智能合约才经得住世界人民的考验,你说是不是呢?\n\n#### 自定义dispatcher 方式2\n>按照上篇文章的做法,那么我们实现了自己定义apply函数来取代EOSIO_DISPATCHER,但是实现的功能是一模一样的,那我们这样做的目的是什么呢?\n\n* 那么接下来我们继续按照官方的教程走,通过另外一种方式来实现.\n* 那么此种方式相对于上一中方式有什么区别呢?\n\n```\nThis pattern provides more control over security at the expense of maintainability. Utilizing if...else if statements as opposed to a switch inherently provides more granularity.\n此模式以可维护性为代价提供了对安全性的更多控制。利用if ... else if语句而不是switch提供更精细的控制。\n```\n好吧,既然看起来优点这么多,那么我们就看看是怎么样实现的吧\n\n```\nextern \"C\" {\n  void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n    addressbook _addressbook(receiver);\n    if(code==receiver && action==name(\"upsert\").value) {\n      execute_action(name(receiver), name(code), &addressbook::upsert );\n    }\n    else if(code==receiver && action==name(\"notify\").value) {\n      execute_action(name(receiver), name(code), &addressbook::notify );\n    }\n    else if(code==receiver && action==name(\"erase\").value) {\n      execute_action(name(receiver), name(code), &addressbook::erase );\n    }\n    else if(code==name(\"eosio.token\").value && action==name(\"transfer\").value) {\n      execute_action(name(receiver), name(code), &addressbook::transfer );\n    }\n  }\n};\n```\n* 初看和上一篇文章简直是一模一样,就是把switch换成了if...else,看来官方真实说的大实话呢\n* 不过,最后一个else多了一个判断,addressbook去调用transfer方法,可是我们没有啊,既然是这样,那我们就依样画葫芦,待会写一个吧\n* 第二点,最后一个else判断变成了code == eosio.token,这就是我们上篇文章说的这个code的意义了.而eosio.token是系统的账号,当发生eos或者其他代币时才会调用这个方法呢,那么我猜测一下这个判断是当发生eosio.token执行transfer的时候,将会执行我们合约transfer方法\n\n#### 结果验证\n>按照上面说的,我们就按照我们得思路先写一个吧,那么就加一个transfer方法如下.\n\n```\n void transfer(uint64_t receiver, uint64_t code){\n    send_summary(name(code), \"eosio.token transfer\");\n  }\n```\n* 很简单,当发生transfer时,我们出发一个inline action来记录一下数据\n* 那我们看下结果,结果报错了???? \n* why? 我们仅仅是转账啊,自己转出去或者别人转进来,现在都失败了\n\n#### 结果分析\n*Authorization failure with inline action sent to self*\n\n* 权限不允许给自己发送内联action?\n* 这是什么情况?给自己发送内联action还要权限?\n* 想想想... 对了,要让自己的合约调用其他合约需要给eosio.code发送权限,那我们接下来试试看看是不是这个原因呢\n\n![shaokun](/img_eos1/eos_react9.gif)\n\n#### 再次验证分析结果\n* 使用owner权限,给eosio.code授予active权限\n* 执行相互转账\n* 查看是否能够出发我们自定义的内联action(经过上一步的操作,和我们之前的经验,它应该是调用了我们得inline action,不过还是得看事实说话呢)\n* 去kylin,确实达到了我们的结果,无论转账转出或者转入,那么我们都发送了一个inline action  \n![shaokun](/img_eos1/eos_react10.gif)\n\n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-02)  \n\n* 这里说一下这个源码,我已经编译好的abi和wasm文件,各位同学可以直接部署,如果要修改源码,就得自己编译了.不同的编译版本可能会有不同的eos语法,我这里用的是cdt1.3.2\n* 还有,部署的时候,最好文件夹名字和主合约的名字一样,这样可以可以避免一些想不到的奇奇怪怪的错误.\n\n\n#### 结论\n* 关于上一篇文章开篇提到的类似以太坊中payable关键字的功能,我想各位同学应该知道怎么实现了吧\n* 通过我们目前自己实现apply的方式,不用eosio.code授予权限,我们是可以拒绝或者转出eos的,当然这样的方式达到了目的,但是不够优雅\n* 通过结果,我们发现了我们也可以在合约中检查监听到eos的转出和转入,那么我们是否可以通过此做出相应的动作呢?答案是可以的,具体怎么使用我们以后的文章再说\n* 那么我们怎么优雅的实现拒绝账户eos的交易呢,我觉得最简单的方法就是调用eosio_assert(1==2);哈哈,^_^\n* 问题又来了?如果我不调用inline action,那么是不是我不用授权给eosio.code就可以实现转账呢?答案是可以的,本篇文章主要是为了看到具体的转账结果,所以用了inline action,相当于也给大家复习一下这个权限吧.至于这个不使用inline action的,这个可以交由各位同学自己去实现了哈\n* 问题又来了?那我要怎么拿取转账的信息呢?\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解5","published":1,"updated":"2019-02-18T13:13:08.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b51w0008nh7s2i8p5zis","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>希望阅读本篇文章的同学去看一下上一篇文章,不然思路断了接不上就有点麻烦了    </p>\n</blockquote>\n<h4 id=\"多说两句\"><a href=\"#多说两句\" class=\"headerlink\" title=\"多说两句\"></a>多说两句</h4><ul>\n<li>话说以太坊的分叉计划又延期了,而此次的升级主要是针对底层的安全机制,所以可见写智能合约的最关键点还是安全第一吧,</li>\n<li>eos一直被攻击,从未被停止.最近的eos因为一个derferred action的问题的漏洞又被黑客利用了,哎… 受伤的总是开发者</li>\n<li>大家写的合约还有一个点,就是安全.这里一个朋友已经开发了一款应用,也已经上线到主网,各种测试也做了,什么逻辑,压力,数据,前端页面的跳转等等… 然而当项目上线后,他找到我对我说,别人可以绕过前端代码直接调用的它的合约…  我只能说,这就是智能合约,你所写的合约是全世界的人(当然,如果你的项目很成功,那么黑客也是由兴趣来光顾的)都可以调用的,除非你做一些权限的验证.在eos上还好,可以通过升级合约来弥补,而且code还不用开源.但是在eth,code is law,code还要开源,所以各位同学想想这个合约安全的重要性.eos底层虽然还有bug,我们无法避免,但是我们还是应该对我们的应用层的逻辑进行严格的测试,这样开发的智能合约才经得住世界人民的考验,你说是不是呢?</li>\n</ul>\n<h4 id=\"自定义dispatcher-方式2\"><a href=\"#自定义dispatcher-方式2\" class=\"headerlink\" title=\"自定义dispatcher 方式2\"></a>自定义dispatcher 方式2</h4><blockquote>\n<p>按照上篇文章的做法,那么我们实现了自己定义apply函数来取代EOSIO_DISPATCHER,但是实现的功能是一模一样的,那我们这样做的目的是什么呢?</p>\n</blockquote>\n<ul>\n<li>那么接下来我们继续按照官方的教程走,通过另外一种方式来实现.</li>\n<li>那么此种方式相对于上一中方式有什么区别呢?</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This pattern provides more control over security at the expense of maintainability. Utilizing if...else if statements as opposed to a switch inherently provides more granularity.</span><br><span class=\"line\">此模式以可维护性为代价提供了对安全性的更多控制。利用if ... else if语句而不是switch提供更精细的控制。</span><br></pre></td></tr></table></figure>\n<p>好吧,既然看起来优点这么多,那么我们就看看是怎么样实现的吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; &#123;</span><br><span class=\"line\">  void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class=\"line\">    addressbook _addressbook(receiver);</span><br><span class=\"line\">    if(code==receiver &amp;&amp; action==name(&quot;upsert&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::upsert );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==receiver &amp;&amp; action==name(&quot;notify&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::notify );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==receiver &amp;&amp; action==name(&quot;erase&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::erase );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==name(&quot;eosio.token&quot;).value &amp;&amp; action==name(&quot;transfer&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::transfer );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>初看和上一篇文章简直是一模一样,就是把switch换成了if…else,看来官方真实说的大实话呢</li>\n<li>不过,最后一个else多了一个判断,addressbook去调用transfer方法,可是我们没有啊,既然是这样,那我们就依样画葫芦,待会写一个吧</li>\n<li>第二点,最后一个else判断变成了code == eosio.token,这就是我们上篇文章说的这个code的意义了.而eosio.token是系统的账号,当发生eos或者其他代币时才会调用这个方法呢,那么我猜测一下这个判断是当发生eosio.token执行transfer的时候,将会执行我们合约transfer方法</li>\n</ul>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><blockquote>\n<p>按照上面说的,我们就按照我们得思路先写一个吧,那么就加一个transfer方法如下.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void transfer(uint64_t receiver, uint64_t code)&#123;</span><br><span class=\"line\">   send_summary(name(code), &quot;eosio.token transfer&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>很简单,当发生transfer时,我们出发一个inline action来记录一下数据</li>\n<li>那我们看下结果,结果报错了???? </li>\n<li>why? 我们仅仅是转账啊,自己转出去或者别人转进来,现在都失败了</li>\n</ul>\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><p><em>Authorization failure with inline action sent to self</em></p>\n<ul>\n<li>权限不允许给自己发送内联action?</li>\n<li>这是什么情况?给自己发送内联action还要权限?</li>\n<li>想想想… 对了,要让自己的合约调用其他合约需要给eosio.code发送权限,那我们接下来试试看看是不是这个原因呢</li>\n</ul>\n<p><img src=\"/img_eos1/eos_react9.gif\" alt=\"shaokun\"></p>\n<h4 id=\"再次验证分析结果\"><a href=\"#再次验证分析结果\" class=\"headerlink\" title=\"再次验证分析结果\"></a>再次验证分析结果</h4><ul>\n<li>使用owner权限,给eosio.code授予active权限</li>\n<li>执行相互转账</li>\n<li>查看是否能够出发我们自定义的内联action(经过上一步的操作,和我们之前的经验,它应该是调用了我们得inline action,不过还是得看事实说话呢)</li>\n<li>去kylin,确实达到了我们的结果,无论转账转出或者转入,那么我们都发送了一个inline action<br><img src=\"/img_eos1/eos_react10.gif\" alt=\"shaokun\"></li>\n</ul>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-02\" target=\"_blank\" rel=\"noopener\">本课源码</a>  </p>\n<ul>\n<li>这里说一下这个源码,我已经编译好的abi和wasm文件,各位同学可以直接部署,如果要修改源码,就得自己编译了.不同的编译版本可能会有不同的eos语法,我这里用的是cdt1.3.2</li>\n<li>还有,部署的时候,最好文件夹名字和主合约的名字一样,这样可以可以避免一些想不到的奇奇怪怪的错误.</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><ul>\n<li>关于上一篇文章开篇提到的类似以太坊中payable关键字的功能,我想各位同学应该知道怎么实现了吧</li>\n<li>通过我们目前自己实现apply的方式,不用eosio.code授予权限,我们是可以拒绝或者转出eos的,当然这样的方式达到了目的,但是不够优雅</li>\n<li>通过结果,我们发现了我们也可以在合约中检查监听到eos的转出和转入,那么我们是否可以通过此做出相应的动作呢?答案是可以的,具体怎么使用我们以后的文章再说</li>\n<li>那么我们怎么优雅的实现拒绝账户eos的交易呢,我觉得最简单的方法就是调用eosio_assert(1==2);哈哈,^_^</li>\n<li>问题又来了?如果我不调用inline action,那么是不是我不用授权给eosio.code就可以实现转账呢?答案是可以的,本篇文章主要是为了看到具体的转账结果,所以用了inline action,相当于也给大家复习一下这个权限吧.至于这个不使用inline action的,这个可以交由各位同学自己去实现了哈</li>\n<li>问题又来了?那我要怎么拿取转账的信息呢?</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>希望阅读本篇文章的同学去看一下上一篇文章,不然思路断了接不上就有点麻烦了    </p>\n</blockquote>\n<h4 id=\"多说两句\"><a href=\"#多说两句\" class=\"headerlink\" title=\"多说两句\"></a>多说两句</h4><ul>\n<li>话说以太坊的分叉计划又延期了,而此次的升级主要是针对底层的安全机制,所以可见写智能合约的最关键点还是安全第一吧,</li>\n<li>eos一直被攻击,从未被停止.最近的eos因为一个derferred action的问题的漏洞又被黑客利用了,哎… 受伤的总是开发者</li>\n<li>大家写的合约还有一个点,就是安全.这里一个朋友已经开发了一款应用,也已经上线到主网,各种测试也做了,什么逻辑,压力,数据,前端页面的跳转等等… 然而当项目上线后,他找到我对我说,别人可以绕过前端代码直接调用的它的合约…  我只能说,这就是智能合约,你所写的合约是全世界的人(当然,如果你的项目很成功,那么黑客也是由兴趣来光顾的)都可以调用的,除非你做一些权限的验证.在eos上还好,可以通过升级合约来弥补,而且code还不用开源.但是在eth,code is law,code还要开源,所以各位同学想想这个合约安全的重要性.eos底层虽然还有bug,我们无法避免,但是我们还是应该对我们的应用层的逻辑进行严格的测试,这样开发的智能合约才经得住世界人民的考验,你说是不是呢?</li>\n</ul>\n<h4 id=\"自定义dispatcher-方式2\"><a href=\"#自定义dispatcher-方式2\" class=\"headerlink\" title=\"自定义dispatcher 方式2\"></a>自定义dispatcher 方式2</h4><blockquote>\n<p>按照上篇文章的做法,那么我们实现了自己定义apply函数来取代EOSIO_DISPATCHER,但是实现的功能是一模一样的,那我们这样做的目的是什么呢?</p>\n</blockquote>\n<ul>\n<li>那么接下来我们继续按照官方的教程走,通过另外一种方式来实现.</li>\n<li>那么此种方式相对于上一中方式有什么区别呢?</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This pattern provides more control over security at the expense of maintainability. Utilizing if...else if statements as opposed to a switch inherently provides more granularity.</span><br><span class=\"line\">此模式以可维护性为代价提供了对安全性的更多控制。利用if ... else if语句而不是switch提供更精细的控制。</span><br></pre></td></tr></table></figure>\n<p>好吧,既然看起来优点这么多,那么我们就看看是怎么样实现的吧</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; &#123;</span><br><span class=\"line\">  void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class=\"line\">    addressbook _addressbook(receiver);</span><br><span class=\"line\">    if(code==receiver &amp;&amp; action==name(&quot;upsert&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::upsert );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==receiver &amp;&amp; action==name(&quot;notify&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::notify );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==receiver &amp;&amp; action==name(&quot;erase&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::erase );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else if(code==name(&quot;eosio.token&quot;).value &amp;&amp; action==name(&quot;transfer&quot;).value) &#123;</span><br><span class=\"line\">      execute_action(name(receiver), name(code), &amp;addressbook::transfer );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>初看和上一篇文章简直是一模一样,就是把switch换成了if…else,看来官方真实说的大实话呢</li>\n<li>不过,最后一个else多了一个判断,addressbook去调用transfer方法,可是我们没有啊,既然是这样,那我们就依样画葫芦,待会写一个吧</li>\n<li>第二点,最后一个else判断变成了code == eosio.token,这就是我们上篇文章说的这个code的意义了.而eosio.token是系统的账号,当发生eos或者其他代币时才会调用这个方法呢,那么我猜测一下这个判断是当发生eosio.token执行transfer的时候,将会执行我们合约transfer方法</li>\n</ul>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><blockquote>\n<p>按照上面说的,我们就按照我们得思路先写一个吧,那么就加一个transfer方法如下.</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">void transfer(uint64_t receiver, uint64_t code)&#123;</span><br><span class=\"line\">   send_summary(name(code), &quot;eosio.token transfer&quot;);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>很简单,当发生transfer时,我们出发一个inline action来记录一下数据</li>\n<li>那我们看下结果,结果报错了???? </li>\n<li>why? 我们仅仅是转账啊,自己转出去或者别人转进来,现在都失败了</li>\n</ul>\n<h4 id=\"结果分析\"><a href=\"#结果分析\" class=\"headerlink\" title=\"结果分析\"></a>结果分析</h4><p><em>Authorization failure with inline action sent to self</em></p>\n<ul>\n<li>权限不允许给自己发送内联action?</li>\n<li>这是什么情况?给自己发送内联action还要权限?</li>\n<li>想想想… 对了,要让自己的合约调用其他合约需要给eosio.code发送权限,那我们接下来试试看看是不是这个原因呢</li>\n</ul>\n<p><img src=\"/img_eos1/eos_react9.gif\" alt=\"shaokun\"></p>\n<h4 id=\"再次验证分析结果\"><a href=\"#再次验证分析结果\" class=\"headerlink\" title=\"再次验证分析结果\"></a>再次验证分析结果</h4><ul>\n<li>使用owner权限,给eosio.code授予active权限</li>\n<li>执行相互转账</li>\n<li>查看是否能够出发我们自定义的内联action(经过上一步的操作,和我们之前的经验,它应该是调用了我们得inline action,不过还是得看事实说话呢)</li>\n<li>去kylin,确实达到了我们的结果,无论转账转出或者转入,那么我们都发送了一个inline action<br><img src=\"/img_eos1/eos_react10.gif\" alt=\"shaokun\"></li>\n</ul>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-02\" target=\"_blank\" rel=\"noopener\">本课源码</a>  </p>\n<ul>\n<li>这里说一下这个源码,我已经编译好的abi和wasm文件,各位同学可以直接部署,如果要修改源码,就得自己编译了.不同的编译版本可能会有不同的eos语法,我这里用的是cdt1.3.2</li>\n<li>还有,部署的时候,最好文件夹名字和主合约的名字一样,这样可以可以避免一些想不到的奇奇怪怪的错误.</li>\n</ul>\n<h4 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h4><ul>\n<li>关于上一篇文章开篇提到的类似以太坊中payable关键字的功能,我想各位同学应该知道怎么实现了吧</li>\n<li>通过我们目前自己实现apply的方式,不用eosio.code授予权限,我们是可以拒绝或者转出eos的,当然这样的方式达到了目的,但是不够优雅</li>\n<li>通过结果,我们发现了我们也可以在合约中检查监听到eos的转出和转入,那么我们是否可以通过此做出相应的动作呢?答案是可以的,具体怎么使用我们以后的文章再说</li>\n<li>那么我们怎么优雅的实现拒绝账户eos的交易呢,我觉得最简单的方法就是调用eosio_assert(1==2);哈哈,^_^</li>\n<li>问题又来了?如果我不调用inline action,那么是不是我不用授权给eosio.code就可以实现转账呢?答案是可以的,本篇文章主要是为了看到具体的转账结果,所以用了inline action,相当于也给大家复习一下这个权限吧.至于这个不使用inline action的,这个可以交由各位同学自己去实现了哈</li>\n<li>问题又来了?那我要怎么拿取转账的信息呢?</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#103;&#64;&#x67;&#109;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#110;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#99;&#x6f;&#x6d;</a></p>\n"},{"title":"结合scatter学习eos dapp开发，看这篇就够了（上）--补充","date":"2018-10-13T15:23:17.000Z","_content":" \n#### eos智能合约开发 在jungle上创建account 续\n>之前由于网络的原因，导致中断了，那我们继续接着来。自带梯子最重要\n\n![jungle](/images/jungle03.png)   \n打开网站，输入之前的信息如图所示,点击左下角create  \n![jungle](/images/jungle4.png)   \n创建成功后，会返回这样的信息，看见最下面有绿色的应该就是成功了吧\n接下来我们查看一下我们创建的account的信息，回到主页，选择account info，输入刚才创建的account ，我这里输入shaokun11113 ,点击 get  \n![jungle](/images/jungle5.png)\n![jungle](/images/jungle6.png)  \n可以看到返回了我们创建账号的信息:    \n \n* balance  什么都没有   \n* activity key 和 owner key为我们刚才创建账户的时候输入的key  \n* RAM 目前账号的RAM情况，这里可以看到刚创建账号就已经消耗了一部分的RAM,为什么呢？ 因为你的账号信息要占用内存啊，所以说，创建账号得找到一个有eos的账号的用户帮你创建，他要为你支付这部分费用\n* net Bandwidth 存了100个eos,目前没有使用\n* cpu Bandwidth 存了100个eos，目前没有使用\n\n由于作为dapp开发者，那么我们得准备点eos,那么接下来我们再去获取一点eos吧   \n回到主页，选择 faucet，输入 你的账号，如图所示，通过验证，选择send coins 就好  \n![jungle](/images/jungle7.png)  \n返回的结果如上所示，有兴趣的同学可以仔细看看这些内容。  \n那么我们如何知道我们是否收到了eos呢？  \n还是回到主页，进入 account info查询就好\n\n![jungle](/images/jungle8.png) \n \n 这里注意一下 balance 那一项就好，可以看到已经有100个eos和100个jungle token了\n\n#### eos智能合约开发 导入Account到scatter中\n>经过上一步骤，我们已经创建好了账户，接下来就讲账户导入到scatter中吧。在scatter中，这里叫做identity（身份）\n\n![jungle](/images/scatter17.png)   \n进入scatter，选择身份。点击左下角的编辑的icon    \n如果你关闭过浏览器，请输入最开始的密码进入就好，如果忘记了，请输入助记词找回，如果丢了，就从头来一遍就好.  \n![jungle](/images/scatter18.png)   \n这里我们注意一下 账户选项中的内容就好     \n![jungle](/images/scatter19.png)   \n这里都是选择题，账户的第一项勾选我们创建网络时输入的名字，第二项勾选我们生成密匙对的名字就好，点击导入  \n![jungle](/images/scatter23.png)   \n如果你看到了这个结果，不好意思，我也不知道你哪一步有问题。你可以从头开始再来一遍就好  \n![jungle](/images/scatter20.png) \n当然，我希望的是你看到的这个界面，通常我们选择active账号，然后点击右上角保存按钮   \n![jungle](/images/scatter21.png)   \n回到这个界面，可以看到我们刚才创建的账户已经导入成功了，这里多一步的设置，把此账户设置为scatter的默认账户，这样以后调用scatter的时候就会默认选择此账户进行智能合约的调用了  勾选左下角的那个小圆圈的icon  \n![jungle](/images/scatter22.png) \n我们就可以看到我们账户的信息啦\n\n**文章允许转载，但请注明出处，谢谢**\n\n**这样一点点的敲下来，内容还是蛮多的。本打算一次写完，结果遇到网络的问题，暂停了一会，这篇文章算是对第一篇的补充吧。到目前为止，我们只是创建好了账户，还没有涉及到dapp的开发，接下来的具体怎么开发dapp估计要等到下周了吧。**\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>\n","source":"_posts/基于eos连接scatter开发dapp(上)--补充 23.18.52.md","raw":"---\ntitle: 结合scatter学习eos dapp开发，看这篇就够了（上）--补充  \ndate: 2018-10-13 23:23:17\n---\n \n#### eos智能合约开发 在jungle上创建account 续\n>之前由于网络的原因，导致中断了，那我们继续接着来。自带梯子最重要\n\n![jungle](/images/jungle03.png)   \n打开网站，输入之前的信息如图所示,点击左下角create  \n![jungle](/images/jungle4.png)   \n创建成功后，会返回这样的信息，看见最下面有绿色的应该就是成功了吧\n接下来我们查看一下我们创建的account的信息，回到主页，选择account info，输入刚才创建的account ，我这里输入shaokun11113 ,点击 get  \n![jungle](/images/jungle5.png)\n![jungle](/images/jungle6.png)  \n可以看到返回了我们创建账号的信息:    \n \n* balance  什么都没有   \n* activity key 和 owner key为我们刚才创建账户的时候输入的key  \n* RAM 目前账号的RAM情况，这里可以看到刚创建账号就已经消耗了一部分的RAM,为什么呢？ 因为你的账号信息要占用内存啊，所以说，创建账号得找到一个有eos的账号的用户帮你创建，他要为你支付这部分费用\n* net Bandwidth 存了100个eos,目前没有使用\n* cpu Bandwidth 存了100个eos，目前没有使用\n\n由于作为dapp开发者，那么我们得准备点eos,那么接下来我们再去获取一点eos吧   \n回到主页，选择 faucet，输入 你的账号，如图所示，通过验证，选择send coins 就好  \n![jungle](/images/jungle7.png)  \n返回的结果如上所示，有兴趣的同学可以仔细看看这些内容。  \n那么我们如何知道我们是否收到了eos呢？  \n还是回到主页，进入 account info查询就好\n\n![jungle](/images/jungle8.png) \n \n 这里注意一下 balance 那一项就好，可以看到已经有100个eos和100个jungle token了\n\n#### eos智能合约开发 导入Account到scatter中\n>经过上一步骤，我们已经创建好了账户，接下来就讲账户导入到scatter中吧。在scatter中，这里叫做identity（身份）\n\n![jungle](/images/scatter17.png)   \n进入scatter，选择身份。点击左下角的编辑的icon    \n如果你关闭过浏览器，请输入最开始的密码进入就好，如果忘记了，请输入助记词找回，如果丢了，就从头来一遍就好.  \n![jungle](/images/scatter18.png)   \n这里我们注意一下 账户选项中的内容就好     \n![jungle](/images/scatter19.png)   \n这里都是选择题，账户的第一项勾选我们创建网络时输入的名字，第二项勾选我们生成密匙对的名字就好，点击导入  \n![jungle](/images/scatter23.png)   \n如果你看到了这个结果，不好意思，我也不知道你哪一步有问题。你可以从头开始再来一遍就好  \n![jungle](/images/scatter20.png) \n当然，我希望的是你看到的这个界面，通常我们选择active账号，然后点击右上角保存按钮   \n![jungle](/images/scatter21.png)   \n回到这个界面，可以看到我们刚才创建的账户已经导入成功了，这里多一步的设置，把此账户设置为scatter的默认账户，这样以后调用scatter的时候就会默认选择此账户进行智能合约的调用了  勾选左下角的那个小圆圈的icon  \n![jungle](/images/scatter22.png) \n我们就可以看到我们账户的信息啦\n\n**文章允许转载，但请注明出处，谢谢**\n\n**这样一点点的敲下来，内容还是蛮多的。本打算一次写完，结果遇到网络的问题，暂停了一会，这篇文章算是对第一篇的补充吧。到目前为止，我们只是创建好了账户，还没有涉及到dapp的开发，接下来的具体怎么开发dapp估计要等到下周了吧。**\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>\n","slug":"基于eos连接scatter开发dapp(上)--补充 23.18.52","published":1,"updated":"2019-02-18T13:13:08.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b51y0009nh7sokmaukza","content":"<h4 id=\"eos智能合约开发-在jungle上创建account-续\"><a href=\"#eos智能合约开发-在jungle上创建account-续\" class=\"headerlink\" title=\"eos智能合约开发 在jungle上创建account 续\"></a>eos智能合约开发 在jungle上创建account 续</h4><blockquote>\n<p>之前由于网络的原因，导致中断了，那我们继续接着来。自带梯子最重要</p>\n</blockquote>\n<p><img src=\"/images/jungle03.png\" alt=\"jungle\"><br>打开网站，输入之前的信息如图所示,点击左下角create<br><img src=\"/images/jungle4.png\" alt=\"jungle\"><br>创建成功后，会返回这样的信息，看见最下面有绿色的应该就是成功了吧<br>接下来我们查看一下我们创建的account的信息，回到主页，选择account info，输入刚才创建的account ，我这里输入shaokun11113 ,点击 get<br><img src=\"/images/jungle5.png\" alt=\"jungle\"><br><img src=\"/images/jungle6.png\" alt=\"jungle\"><br>可以看到返回了我们创建账号的信息:    </p>\n<ul>\n<li>balance  什么都没有   </li>\n<li>activity key 和 owner key为我们刚才创建账户的时候输入的key  </li>\n<li>RAM 目前账号的RAM情况，这里可以看到刚创建账号就已经消耗了一部分的RAM,为什么呢？ 因为你的账号信息要占用内存啊，所以说，创建账号得找到一个有eos的账号的用户帮你创建，他要为你支付这部分费用</li>\n<li>net Bandwidth 存了100个eos,目前没有使用</li>\n<li>cpu Bandwidth 存了100个eos，目前没有使用</li>\n</ul>\n<p>由于作为dapp开发者，那么我们得准备点eos,那么接下来我们再去获取一点eos吧<br>回到主页，选择 faucet，输入 你的账号，如图所示，通过验证，选择send coins 就好<br><img src=\"/images/jungle7.png\" alt=\"jungle\"><br>返回的结果如上所示，有兴趣的同学可以仔细看看这些内容。<br>那么我们如何知道我们是否收到了eos呢？<br>还是回到主页，进入 account info查询就好</p>\n<p><img src=\"/images/jungle8.png\" alt=\"jungle\"> </p>\n<p> 这里注意一下 balance 那一项就好，可以看到已经有100个eos和100个jungle token了</p>\n<h4 id=\"eos智能合约开发-导入Account到scatter中\"><a href=\"#eos智能合约开发-导入Account到scatter中\" class=\"headerlink\" title=\"eos智能合约开发 导入Account到scatter中\"></a>eos智能合约开发 导入Account到scatter中</h4><blockquote>\n<p>经过上一步骤，我们已经创建好了账户，接下来就讲账户导入到scatter中吧。在scatter中，这里叫做identity（身份）</p>\n</blockquote>\n<p><img src=\"/images/scatter17.png\" alt=\"jungle\"><br>进入scatter，选择身份。点击左下角的编辑的icon<br>如果你关闭过浏览器，请输入最开始的密码进入就好，如果忘记了，请输入助记词找回，如果丢了，就从头来一遍就好.<br><img src=\"/images/scatter18.png\" alt=\"jungle\"><br>这里我们注意一下 账户选项中的内容就好<br><img src=\"/images/scatter19.png\" alt=\"jungle\"><br>这里都是选择题，账户的第一项勾选我们创建网络时输入的名字，第二项勾选我们生成密匙对的名字就好，点击导入<br><img src=\"/images/scatter23.png\" alt=\"jungle\"><br>如果你看到了这个结果，不好意思，我也不知道你哪一步有问题。你可以从头开始再来一遍就好<br><img src=\"/images/scatter20.png\" alt=\"jungle\"><br>当然，我希望的是你看到的这个界面，通常我们选择active账号，然后点击右上角保存按钮<br><img src=\"/images/scatter21.png\" alt=\"jungle\"><br>回到这个界面，可以看到我们刚才创建的账户已经导入成功了，这里多一步的设置，把此账户设置为scatter的默认账户，这样以后调用scatter的时候就会默认选择此账户进行智能合约的调用了  勾选左下角的那个小圆圈的icon<br><img src=\"/images/scatter22.png\" alt=\"jungle\"><br>我们就可以看到我们账户的信息啦</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p><strong>这样一点点的敲下来，内容还是蛮多的。本打算一次写完，结果遇到网络的问题，暂停了一会，这篇文章算是对第一篇的补充吧。到目前为止，我们只是创建好了账户，还没有涉及到dapp的开发，接下来的具体怎么开发dapp估计要等到下周了吧。</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#x61;&#111;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#x61;&#111;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"eos智能合约开发-在jungle上创建account-续\"><a href=\"#eos智能合约开发-在jungle上创建account-续\" class=\"headerlink\" title=\"eos智能合约开发 在jungle上创建account 续\"></a>eos智能合约开发 在jungle上创建account 续</h4><blockquote>\n<p>之前由于网络的原因，导致中断了，那我们继续接着来。自带梯子最重要</p>\n</blockquote>\n<p><img src=\"/images/jungle03.png\" alt=\"jungle\"><br>打开网站，输入之前的信息如图所示,点击左下角create<br><img src=\"/images/jungle4.png\" alt=\"jungle\"><br>创建成功后，会返回这样的信息，看见最下面有绿色的应该就是成功了吧<br>接下来我们查看一下我们创建的account的信息，回到主页，选择account info，输入刚才创建的account ，我这里输入shaokun11113 ,点击 get<br><img src=\"/images/jungle5.png\" alt=\"jungle\"><br><img src=\"/images/jungle6.png\" alt=\"jungle\"><br>可以看到返回了我们创建账号的信息:    </p>\n<ul>\n<li>balance  什么都没有   </li>\n<li>activity key 和 owner key为我们刚才创建账户的时候输入的key  </li>\n<li>RAM 目前账号的RAM情况，这里可以看到刚创建账号就已经消耗了一部分的RAM,为什么呢？ 因为你的账号信息要占用内存啊，所以说，创建账号得找到一个有eos的账号的用户帮你创建，他要为你支付这部分费用</li>\n<li>net Bandwidth 存了100个eos,目前没有使用</li>\n<li>cpu Bandwidth 存了100个eos，目前没有使用</li>\n</ul>\n<p>由于作为dapp开发者，那么我们得准备点eos,那么接下来我们再去获取一点eos吧<br>回到主页，选择 faucet，输入 你的账号，如图所示，通过验证，选择send coins 就好<br><img src=\"/images/jungle7.png\" alt=\"jungle\"><br>返回的结果如上所示，有兴趣的同学可以仔细看看这些内容。<br>那么我们如何知道我们是否收到了eos呢？<br>还是回到主页，进入 account info查询就好</p>\n<p><img src=\"/images/jungle8.png\" alt=\"jungle\"> </p>\n<p> 这里注意一下 balance 那一项就好，可以看到已经有100个eos和100个jungle token了</p>\n<h4 id=\"eos智能合约开发-导入Account到scatter中\"><a href=\"#eos智能合约开发-导入Account到scatter中\" class=\"headerlink\" title=\"eos智能合约开发 导入Account到scatter中\"></a>eos智能合约开发 导入Account到scatter中</h4><blockquote>\n<p>经过上一步骤，我们已经创建好了账户，接下来就讲账户导入到scatter中吧。在scatter中，这里叫做identity（身份）</p>\n</blockquote>\n<p><img src=\"/images/scatter17.png\" alt=\"jungle\"><br>进入scatter，选择身份。点击左下角的编辑的icon<br>如果你关闭过浏览器，请输入最开始的密码进入就好，如果忘记了，请输入助记词找回，如果丢了，就从头来一遍就好.<br><img src=\"/images/scatter18.png\" alt=\"jungle\"><br>这里我们注意一下 账户选项中的内容就好<br><img src=\"/images/scatter19.png\" alt=\"jungle\"><br>这里都是选择题，账户的第一项勾选我们创建网络时输入的名字，第二项勾选我们生成密匙对的名字就好，点击导入<br><img src=\"/images/scatter23.png\" alt=\"jungle\"><br>如果你看到了这个结果，不好意思，我也不知道你哪一步有问题。你可以从头开始再来一遍就好<br><img src=\"/images/scatter20.png\" alt=\"jungle\"><br>当然，我希望的是你看到的这个界面，通常我们选择active账号，然后点击右上角保存按钮<br><img src=\"/images/scatter21.png\" alt=\"jungle\"><br>回到这个界面，可以看到我们刚才创建的账户已经导入成功了，这里多一步的设置，把此账户设置为scatter的默认账户，这样以后调用scatter的时候就会默认选择此账户进行智能合约的调用了  勾选左下角的那个小圆圈的icon<br><img src=\"/images/scatter22.png\" alt=\"jungle\"><br>我们就可以看到我们账户的信息啦</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p><strong>这样一点点的敲下来，内容还是蛮多的。本打算一次写完，结果遇到网络的问题，暂停了一会，这篇文章算是对第一篇的补充吧。到目前为止，我们只是创建好了账户，还没有涉及到dapp的开发，接下来的具体怎么开发dapp估计要等到下周了吧。</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#x61;&#111;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#x61;&#111;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#97;&#105;&#108;&#x2e;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#x63;&#111;&#x6d;</a></p>\n"},{"title":"结合scatter 学习eos dapp开发，看这篇就够了（下）续","date":"2018-11-15T12:38:55.000Z","_content":" \n#### eos智能合约开发 前言\n[学习eos dapp开发，看这篇就够了（下)]\n(https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B))\n\n> 因为有阅读上面这篇文章的同学没看到源码，而我又把之前的源码给删掉了。那我也只好按照我的教程重新写一遍了。本以为copy后就能用，而当时写的时候所使用的旧版的语法，所以改了改，功能不变。  \n> 本篇文章的代码是使用的cdt1.3.2编译的\n\n#### eos智能合约开发 结果展示\n> 功能有添加todo,删除todo,和完成todo，具体看图  \n \n![scatter](/img_eos1/eos_react7.gif)\n#### eos智能合约开发 源码展示\n>这就是最简单的页面了，希望你阅读起来不会有任何问题，项目你直接clone下来可以直接运行的  \n\n[学习eos dapp开发，看这篇就够了（下）续 源码](https://github.com/shaokun11/eos-todolist)\n\n`App.js`\n\n\timport React, { Component } from 'react';\n\timport './App.css';\n\timport ScatterJS from 'scatterjs-core';\n\timport ScatterEOS from 'scatterjs-plugin-eosjs';\n\timport Eos from 'eosjs';\n\t\n\tScatterJS.plugins( new ScatterEOS());\n\t\n\t\n\tconst network = {\n\t    blockchain:'eos',\n\t    protocol:'http',\n\t    host:'jungle.cryptolions.io',\n\t    port:18888,\n\t    chainId:'038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca'\n\t}\n\t\n\tclass App extends Component {\n\t\n\t   state = {\n\t       deleteId:1,\n\t       rows:[],\n\t       competedId:1,\n\t       scatter:null\n\t  }\n\t\n\t    componentDidMount() {\n\t        setTimeout(() => {\n\t            this.init()\n\t        }, 2000)\n\t    }\n\t\n\t    takeAction(action,params){\n\t       console.log(action,params)\n\t        const requiredFields = { accounts:[network] };\n\t        this.state.scatter.getIdentity(requiredFields).then(() => {\n\t            const account = this.state.scatter.identity.accounts.find(x => x.blockchain === 'eos');\n\t            console.log(account)\n\t            const eosOptions = { expireInSeconds:60 };\n\t            const eos = this.state.scatter.eos(network,Eos,eosOptions);\n\t            const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\t             eos.contract(\"shaokun11113\").then(ins => {\n\t                return ins[action](account.name, ...params, transactionOptions)\n\t            }).then(res => {\n\t                console.log(res);\n\t            }).catch(error => {\n\t                console.error(error);\n\t            });\n\t\n\t        }).catch(error => {\n\t            console.error(\"tack action\",error);\n\t        });\n\t    }\n\t\n\t    init() {\n\t        ScatterJS.scatter.connect('todolist').then(connected => {\n\t            if(!connected) return false;\n\t\n\t            const scatter = ScatterJS.scatter;\n\t            this.setState({\n\t                scatter\n\t            });\n\t            alert(\"scatter load success\")\n\t        }).then(err=>{\n\t          console.log(err)\n\t        });\n\t    }\n\t\n\t    showTodo(){\n\t        this.state.scatter.eos(network,Eos).getTableRows({code: \"shaokun11113\", scope: \"shaokun11113\",table: \"tood\", json: true})\n\t        .then(res=>{\n\t            this.setState({\n\t                rows:res.rows\n\t            })\n\t        })\n\t    }\n\t\n\t    render() {\n\t    return (\n\t        <div>\n\t\n\t            <div>\n\t                <button onClick={() => {\n\t                    const num = Math.floor(Math.random() * 100000);\n\t                    this.takeAction(\"create\",[num,\"this is number \"+num])\n\t                }}>create todo</button>\n\t                <button onClick={() => this.takeAction(\"destroy\",[this.state.deleteId])}>destroy todo</button>\n\t                <input type=\"text\" onChange={e => {\n\t                    this.setState({\n\t                        deleteId: Number.parseInt(e.target.value)\n\t                    })\n\t                }}/>\n\t\n\t                <button onClick={() => this.takeAction(\"complete\",[this.state.competedId])}>complete todo</button>\n\t                <input type=\"text\" onChange={e => {\n\t                    this.setState({\n\t                        competedId: Number.parseInt(e.target.value)\n\t                    })\n\t                }}/>\n\t                <button onClick={() => this.showTodo()}>show todo</button>\n\t            </div>\n\t            <div>\n\t                <p>below is data</p>\n\t                <ul>\n\t                    {\n\t                        this.state.rows.map((todo, index) => {\n\t                            return <li key={index}>\n\t                                <p>id : {todo.id}</p>\n\t                                <p>description : {todo.description}</p>\n\t                                <p>completed : {todo.completed}</p>\n\t                            </li>\n\t                        })\n\t                    }\n\t                </ul>\n\t            </div>\n\t        </div>\n\t    );\n\t  }\n\t}\n\t\n\texport default App;\n\n\n`todolist.cpp`\n\n\tinclude <eosiolib/eosio.hpp>  \n\t\n\tusing namespace std;\n\t\n\tclass [[eosio::contract]] todolist : public eosio::contract {  \n\t  public:\n\t      \n\t  todolist(eosio::name reciever, eosio::name code, eosio::datastream<const char*> ds)\n\t                                                        :contract(reciever,code,ds),\n\t                                                         todos(reciever,code.value){};   \n\t\n\t\n\t  [[eosio::action]]   \n\t  void create(eosio::name author, const uint32_t id, const string& description) {\n\t    todos.emplace(author, [&](auto &new_todo) {\n\t        new_todo.id = id;\n\t        new_todo.description = description;\n\t        new_todo.completed = 0;\n\t    });\n\t   }\n\t\n\t  [[eosio::action]]\n\t  void complete(eosio::name author,const uint32_t id)\n\t  {  \n\t      eosio::require_auth(author);\n\t\n\t      auto itr = todos.find(id);\n\t      // 是否用find()方法，去查找这条方法对应的实例\n\t      eosio_assert(itr != todos.end(), \"todo does not exit\");\n\t    // 这里 如果找不到，todos.end() 会返回 null\n\t      todos.modify(itr,author,[&](auto &t) {\n\t          t.completed = 1;\n\t      });\n\t  }\n\t\n\t  [[eosio::action]]\n\t  void destroy(eosio::name author, const uint32_t id){    \n\t     eosio::require_auth(author);\n\t      auto itr = todos.find(id);\n\t      if(itr != todos.end()){\n\t         todos.erase(itr);\n\t      }\n\t  }\n\t\n\t  private:\n\t  struct [[eosio::table]] todo {\n\t      uint64_t id;\n\t      string description;\n\t      uint64_t completed;\n\t\n\t      uint64_t primary_key() const {\n\t          return id;\n\t      }\n\t  };\n\t\n\t  typedef eosio::multi_index<\"tood\"_n, todo> todo_index;\n\t  todo_index todos;\n\t};\n\t\n\tEOSIO_DISPATCH(todolist, (create)(complete)(destroy))\n\n>* 这里有一点要说明，貌似一个账号只能部署一个智能合约，希望这个结论是正确的\n>* 上面的todo这个table，由于我的笔误，生成表名的时候写成了 tood,哈哈\n>* 合约比较简单了，交互也比较简单，细心点，仔细点，相信你也可以步入eos dapp开发的大门了\n\n#### eos智能合约开发 总结\n>* 请一定耐心的看完文章，中间漏了一点也会造成失败  \n>* 最开始的文章截图使用的分辨率较高，图片显示较大，如若对你阅读造成阅读困难，可以适当缩小页面进行阅读\n\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/基于eos连接scatter开发dapp(下) 续.md","raw":"---\ntitle: 结合scatter 学习eos dapp开发，看这篇就够了（下）续\ndate: 2018-11-15 20:38:55\n---\n \n#### eos智能合约开发 前言\n[学习eos dapp开发，看这篇就够了（下)]\n(https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B))\n\n> 因为有阅读上面这篇文章的同学没看到源码，而我又把之前的源码给删掉了。那我也只好按照我的教程重新写一遍了。本以为copy后就能用，而当时写的时候所使用的旧版的语法，所以改了改，功能不变。  \n> 本篇文章的代码是使用的cdt1.3.2编译的\n\n#### eos智能合约开发 结果展示\n> 功能有添加todo,删除todo,和完成todo，具体看图  \n \n![scatter](/img_eos1/eos_react7.gif)\n#### eos智能合约开发 源码展示\n>这就是最简单的页面了，希望你阅读起来不会有任何问题，项目你直接clone下来可以直接运行的  \n\n[学习eos dapp开发，看这篇就够了（下）续 源码](https://github.com/shaokun11/eos-todolist)\n\n`App.js`\n\n\timport React, { Component } from 'react';\n\timport './App.css';\n\timport ScatterJS from 'scatterjs-core';\n\timport ScatterEOS from 'scatterjs-plugin-eosjs';\n\timport Eos from 'eosjs';\n\t\n\tScatterJS.plugins( new ScatterEOS());\n\t\n\t\n\tconst network = {\n\t    blockchain:'eos',\n\t    protocol:'http',\n\t    host:'jungle.cryptolions.io',\n\t    port:18888,\n\t    chainId:'038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca'\n\t}\n\t\n\tclass App extends Component {\n\t\n\t   state = {\n\t       deleteId:1,\n\t       rows:[],\n\t       competedId:1,\n\t       scatter:null\n\t  }\n\t\n\t    componentDidMount() {\n\t        setTimeout(() => {\n\t            this.init()\n\t        }, 2000)\n\t    }\n\t\n\t    takeAction(action,params){\n\t       console.log(action,params)\n\t        const requiredFields = { accounts:[network] };\n\t        this.state.scatter.getIdentity(requiredFields).then(() => {\n\t            const account = this.state.scatter.identity.accounts.find(x => x.blockchain === 'eos');\n\t            console.log(account)\n\t            const eosOptions = { expireInSeconds:60 };\n\t            const eos = this.state.scatter.eos(network,Eos,eosOptions);\n\t            const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n\t             eos.contract(\"shaokun11113\").then(ins => {\n\t                return ins[action](account.name, ...params, transactionOptions)\n\t            }).then(res => {\n\t                console.log(res);\n\t            }).catch(error => {\n\t                console.error(error);\n\t            });\n\t\n\t        }).catch(error => {\n\t            console.error(\"tack action\",error);\n\t        });\n\t    }\n\t\n\t    init() {\n\t        ScatterJS.scatter.connect('todolist').then(connected => {\n\t            if(!connected) return false;\n\t\n\t            const scatter = ScatterJS.scatter;\n\t            this.setState({\n\t                scatter\n\t            });\n\t            alert(\"scatter load success\")\n\t        }).then(err=>{\n\t          console.log(err)\n\t        });\n\t    }\n\t\n\t    showTodo(){\n\t        this.state.scatter.eos(network,Eos).getTableRows({code: \"shaokun11113\", scope: \"shaokun11113\",table: \"tood\", json: true})\n\t        .then(res=>{\n\t            this.setState({\n\t                rows:res.rows\n\t            })\n\t        })\n\t    }\n\t\n\t    render() {\n\t    return (\n\t        <div>\n\t\n\t            <div>\n\t                <button onClick={() => {\n\t                    const num = Math.floor(Math.random() * 100000);\n\t                    this.takeAction(\"create\",[num,\"this is number \"+num])\n\t                }}>create todo</button>\n\t                <button onClick={() => this.takeAction(\"destroy\",[this.state.deleteId])}>destroy todo</button>\n\t                <input type=\"text\" onChange={e => {\n\t                    this.setState({\n\t                        deleteId: Number.parseInt(e.target.value)\n\t                    })\n\t                }}/>\n\t\n\t                <button onClick={() => this.takeAction(\"complete\",[this.state.competedId])}>complete todo</button>\n\t                <input type=\"text\" onChange={e => {\n\t                    this.setState({\n\t                        competedId: Number.parseInt(e.target.value)\n\t                    })\n\t                }}/>\n\t                <button onClick={() => this.showTodo()}>show todo</button>\n\t            </div>\n\t            <div>\n\t                <p>below is data</p>\n\t                <ul>\n\t                    {\n\t                        this.state.rows.map((todo, index) => {\n\t                            return <li key={index}>\n\t                                <p>id : {todo.id}</p>\n\t                                <p>description : {todo.description}</p>\n\t                                <p>completed : {todo.completed}</p>\n\t                            </li>\n\t                        })\n\t                    }\n\t                </ul>\n\t            </div>\n\t        </div>\n\t    );\n\t  }\n\t}\n\t\n\texport default App;\n\n\n`todolist.cpp`\n\n\tinclude <eosiolib/eosio.hpp>  \n\t\n\tusing namespace std;\n\t\n\tclass [[eosio::contract]] todolist : public eosio::contract {  \n\t  public:\n\t      \n\t  todolist(eosio::name reciever, eosio::name code, eosio::datastream<const char*> ds)\n\t                                                        :contract(reciever,code,ds),\n\t                                                         todos(reciever,code.value){};   \n\t\n\t\n\t  [[eosio::action]]   \n\t  void create(eosio::name author, const uint32_t id, const string& description) {\n\t    todos.emplace(author, [&](auto &new_todo) {\n\t        new_todo.id = id;\n\t        new_todo.description = description;\n\t        new_todo.completed = 0;\n\t    });\n\t   }\n\t\n\t  [[eosio::action]]\n\t  void complete(eosio::name author,const uint32_t id)\n\t  {  \n\t      eosio::require_auth(author);\n\t\n\t      auto itr = todos.find(id);\n\t      // 是否用find()方法，去查找这条方法对应的实例\n\t      eosio_assert(itr != todos.end(), \"todo does not exit\");\n\t    // 这里 如果找不到，todos.end() 会返回 null\n\t      todos.modify(itr,author,[&](auto &t) {\n\t          t.completed = 1;\n\t      });\n\t  }\n\t\n\t  [[eosio::action]]\n\t  void destroy(eosio::name author, const uint32_t id){    \n\t     eosio::require_auth(author);\n\t      auto itr = todos.find(id);\n\t      if(itr != todos.end()){\n\t         todos.erase(itr);\n\t      }\n\t  }\n\t\n\t  private:\n\t  struct [[eosio::table]] todo {\n\t      uint64_t id;\n\t      string description;\n\t      uint64_t completed;\n\t\n\t      uint64_t primary_key() const {\n\t          return id;\n\t      }\n\t  };\n\t\n\t  typedef eosio::multi_index<\"tood\"_n, todo> todo_index;\n\t  todo_index todos;\n\t};\n\t\n\tEOSIO_DISPATCH(todolist, (create)(complete)(destroy))\n\n>* 这里有一点要说明，貌似一个账号只能部署一个智能合约，希望这个结论是正确的\n>* 上面的todo这个table，由于我的笔误，生成表名的时候写成了 tood,哈哈\n>* 合约比较简单了，交互也比较简单，细心点，仔细点，相信你也可以步入eos dapp开发的大门了\n\n#### eos智能合约开发 总结\n>* 请一定耐心的看完文章，中间漏了一点也会造成失败  \n>* 最开始的文章截图使用的分辨率较高，图片显示较大，如若对你阅读造成阅读困难，可以适当缩小页面进行阅读\n\n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"基于eos连接scatter开发dapp(下) 续","published":1,"updated":"2019-02-18T13:13:08.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b521000anh7shclt1606","content":"<h4 id=\"eos智能合约开发-前言\"><a href=\"#eos智能合约开发-前言\" class=\"headerlink\" title=\"eos智能合约开发 前言\"></a>eos智能合约开发 前言</h4><p>[学习eos dapp开发，看这篇就够了（下)]<br>(<a href=\"https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)\" target=\"_blank\" rel=\"noopener\">https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)</a>)</p>\n<blockquote>\n<p>因为有阅读上面这篇文章的同学没看到源码，而我又把之前的源码给删掉了。那我也只好按照我的教程重新写一遍了。本以为copy后就能用，而当时写的时候所使用的旧版的语法，所以改了改，功能不变。<br>本篇文章的代码是使用的cdt1.3.2编译的</p>\n</blockquote>\n<h4 id=\"eos智能合约开发-结果展示\"><a href=\"#eos智能合约开发-结果展示\" class=\"headerlink\" title=\"eos智能合约开发 结果展示\"></a>eos智能合约开发 结果展示</h4><blockquote>\n<p>功能有添加todo,删除todo,和完成todo，具体看图  </p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react7.gif\" alt=\"scatter\"></p>\n<h4 id=\"eos智能合约开发-源码展示\"><a href=\"#eos智能合约开发-源码展示\" class=\"headerlink\" title=\"eos智能合约开发 源码展示\"></a>eos智能合约开发 源码展示</h4><blockquote>\n<p>这就是最简单的页面了，希望你阅读起来不会有任何问题，项目你直接clone下来可以直接运行的  </p>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eos-todolist\" target=\"_blank\" rel=\"noopener\">学习eos dapp开发，看这篇就够了（下）续 源码</a></p>\n<p><code>App.js</code></p>\n<pre><code>import React, { Component } from &apos;react&apos;;\nimport &apos;./App.css&apos;;\nimport ScatterJS from &apos;scatterjs-core&apos;;\nimport ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;\nimport Eos from &apos;eosjs&apos;;\n\nScatterJS.plugins( new ScatterEOS());\n\n\nconst network = {\n    blockchain:&apos;eos&apos;,\n    protocol:&apos;http&apos;,\n    host:&apos;jungle.cryptolions.io&apos;,\n    port:18888,\n    chainId:&apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;\n}\n\nclass App extends Component {\n\n   state = {\n       deleteId:1,\n       rows:[],\n       competedId:1,\n       scatter:null\n  }\n\n    componentDidMount() {\n        setTimeout(() =&gt; {\n            this.init()\n        }, 2000)\n    }\n\n    takeAction(action,params){\n       console.log(action,params)\n        const requiredFields = { accounts:[network] };\n        this.state.scatter.getIdentity(requiredFields).then(() =&gt; {\n            const account = this.state.scatter.identity.accounts.find(x =&gt; x.blockchain === &apos;eos&apos;);\n            console.log(account)\n            const eosOptions = { expireInSeconds:60 };\n            const eos = this.state.scatter.eos(network,Eos,eosOptions);\n            const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n             eos.contract(&quot;shaokun11113&quot;).then(ins =&gt; {\n                return ins[action](account.name, ...params, transactionOptions)\n            }).then(res =&gt; {\n                console.log(res);\n            }).catch(error =&gt; {\n                console.error(error);\n            });\n\n        }).catch(error =&gt; {\n            console.error(&quot;tack action&quot;,error);\n        });\n    }\n\n    init() {\n        ScatterJS.scatter.connect(&apos;todolist&apos;).then(connected =&gt; {\n            if(!connected) return false;\n\n            const scatter = ScatterJS.scatter;\n            this.setState({\n                scatter\n            });\n            alert(&quot;scatter load success&quot;)\n        }).then(err=&gt;{\n          console.log(err)\n        });\n    }\n\n    showTodo(){\n        this.state.scatter.eos(network,Eos).getTableRows({code: &quot;shaokun11113&quot;, scope: &quot;shaokun11113&quot;,table: &quot;tood&quot;, json: true})\n        .then(res=&gt;{\n            this.setState({\n                rows:res.rows\n            })\n        })\n    }\n\n    render() {\n    return (\n        &lt;div&gt;\n\n            &lt;div&gt;\n                &lt;button onClick={() =&gt; {\n                    const num = Math.floor(Math.random() * 100000);\n                    this.takeAction(&quot;create&quot;,[num,&quot;this is number &quot;+num])\n                }}&gt;create todo&lt;/button&gt;\n                &lt;button onClick={() =&gt; this.takeAction(&quot;destroy&quot;,[this.state.deleteId])}&gt;destroy todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        deleteId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n\n                &lt;button onClick={() =&gt; this.takeAction(&quot;complete&quot;,[this.state.competedId])}&gt;complete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        competedId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n                &lt;button onClick={() =&gt; this.showTodo()}&gt;show todo&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;p&gt;below is data&lt;/p&gt;\n                &lt;ul&gt;\n                    {\n                        this.state.rows.map((todo, index) =&gt; {\n                            return &lt;li key={index}&gt;\n                                &lt;p&gt;id : {todo.id}&lt;/p&gt;\n                                &lt;p&gt;description : {todo.description}&lt;/p&gt;\n                                &lt;p&gt;completed : {todo.completed}&lt;/p&gt;\n                            &lt;/li&gt;\n                        })\n                    }\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;\n</code></pre><p><code>todolist.cpp</code></p>\n<pre><code>include &lt;eosiolib/eosio.hpp&gt;  \n\nusing namespace std;\n\nclass [[eosio::contract]] todolist : public eosio::contract {  \n  public:\n\n  todolist(eosio::name reciever, eosio::name code, eosio::datastream&lt;const char*&gt; ds)\n                                                        :contract(reciever,code,ds),\n                                                         todos(reciever,code.value){};   \n\n\n  [[eosio::action]]   \n  void create(eosio::name author, const uint32_t id, const string&amp; description) {\n    todos.emplace(author, [&amp;](auto &amp;new_todo) {\n        new_todo.id = id;\n        new_todo.description = description;\n        new_todo.completed = 0;\n    });\n   }\n\n  [[eosio::action]]\n  void complete(eosio::name author,const uint32_t id)\n  {  \n      eosio::require_auth(author);\n\n      auto itr = todos.find(id);\n      // 是否用find()方法，去查找这条方法对应的实例\n      eosio_assert(itr != todos.end(), &quot;todo does not exit&quot;);\n    // 这里 如果找不到，todos.end() 会返回 null\n      todos.modify(itr,author,[&amp;](auto &amp;t) {\n          t.completed = 1;\n      });\n  }\n\n  [[eosio::action]]\n  void destroy(eosio::name author, const uint32_t id){    \n     eosio::require_auth(author);\n      auto itr = todos.find(id);\n      if(itr != todos.end()){\n         todos.erase(itr);\n      }\n  }\n\n  private:\n  struct [[eosio::table]] todo {\n      uint64_t id;\n      string description;\n      uint64_t completed;\n\n      uint64_t primary_key() const {\n          return id;\n      }\n  };\n\n  typedef eosio::multi_index&lt;&quot;tood&quot;_n, todo&gt; todo_index;\n  todo_index todos;\n};\n\nEOSIO_DISPATCH(todolist, (create)(complete)(destroy))\n</code></pre><blockquote>\n<ul>\n<li>这里有一点要说明，貌似一个账号只能部署一个智能合约，希望这个结论是正确的</li>\n<li>上面的todo这个table，由于我的笔误，生成表名的时候写成了 tood,哈哈</li>\n<li>合约比较简单了，交互也比较简单，细心点，仔细点，相信你也可以步入eos dapp开发的大门了</li>\n</ul>\n</blockquote>\n<h4 id=\"eos智能合约开发-总结\"><a href=\"#eos智能合约开发-总结\" class=\"headerlink\" title=\"eos智能合约开发 总结\"></a>eos智能合约开发 总结</h4><blockquote>\n<ul>\n<li>请一定耐心的看完文章，中间漏了一点也会造成失败  </li>\n<li>最开始的文章截图使用的分辨率较高，图片显示较大，如若对你阅读造成阅读困难，可以适当缩小页面进行阅读</li>\n</ul>\n</blockquote>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#110;&#110;&#x79;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#110;&#110;&#x79;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"eos智能合约开发-前言\"><a href=\"#eos智能合约开发-前言\" class=\"headerlink\" title=\"eos智能合约开发 前言\"></a>eos智能合约开发 前言</h4><p>[学习eos dapp开发，看这篇就够了（下)]<br>(<a href=\"https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)\" target=\"_blank\" rel=\"noopener\">https://shaokun11.github.io/2018/10/14/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)</a>)</p>\n<blockquote>\n<p>因为有阅读上面这篇文章的同学没看到源码，而我又把之前的源码给删掉了。那我也只好按照我的教程重新写一遍了。本以为copy后就能用，而当时写的时候所使用的旧版的语法，所以改了改，功能不变。<br>本篇文章的代码是使用的cdt1.3.2编译的</p>\n</blockquote>\n<h4 id=\"eos智能合约开发-结果展示\"><a href=\"#eos智能合约开发-结果展示\" class=\"headerlink\" title=\"eos智能合约开发 结果展示\"></a>eos智能合约开发 结果展示</h4><blockquote>\n<p>功能有添加todo,删除todo,和完成todo，具体看图  </p>\n</blockquote>\n<p><img src=\"/img_eos1/eos_react7.gif\" alt=\"scatter\"></p>\n<h4 id=\"eos智能合约开发-源码展示\"><a href=\"#eos智能合约开发-源码展示\" class=\"headerlink\" title=\"eos智能合约开发 源码展示\"></a>eos智能合约开发 源码展示</h4><blockquote>\n<p>这就是最简单的页面了，希望你阅读起来不会有任何问题，项目你直接clone下来可以直接运行的  </p>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eos-todolist\" target=\"_blank\" rel=\"noopener\">学习eos dapp开发，看这篇就够了（下）续 源码</a></p>\n<p><code>App.js</code></p>\n<pre><code>import React, { Component } from &apos;react&apos;;\nimport &apos;./App.css&apos;;\nimport ScatterJS from &apos;scatterjs-core&apos;;\nimport ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;\nimport Eos from &apos;eosjs&apos;;\n\nScatterJS.plugins( new ScatterEOS());\n\n\nconst network = {\n    blockchain:&apos;eos&apos;,\n    protocol:&apos;http&apos;,\n    host:&apos;jungle.cryptolions.io&apos;,\n    port:18888,\n    chainId:&apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;\n}\n\nclass App extends Component {\n\n   state = {\n       deleteId:1,\n       rows:[],\n       competedId:1,\n       scatter:null\n  }\n\n    componentDidMount() {\n        setTimeout(() =&gt; {\n            this.init()\n        }, 2000)\n    }\n\n    takeAction(action,params){\n       console.log(action,params)\n        const requiredFields = { accounts:[network] };\n        this.state.scatter.getIdentity(requiredFields).then(() =&gt; {\n            const account = this.state.scatter.identity.accounts.find(x =&gt; x.blockchain === &apos;eos&apos;);\n            console.log(account)\n            const eosOptions = { expireInSeconds:60 };\n            const eos = this.state.scatter.eos(network,Eos,eosOptions);\n            const transactionOptions = { authorization:[`${account.name}@${account.authority}`] };\n             eos.contract(&quot;shaokun11113&quot;).then(ins =&gt; {\n                return ins[action](account.name, ...params, transactionOptions)\n            }).then(res =&gt; {\n                console.log(res);\n            }).catch(error =&gt; {\n                console.error(error);\n            });\n\n        }).catch(error =&gt; {\n            console.error(&quot;tack action&quot;,error);\n        });\n    }\n\n    init() {\n        ScatterJS.scatter.connect(&apos;todolist&apos;).then(connected =&gt; {\n            if(!connected) return false;\n\n            const scatter = ScatterJS.scatter;\n            this.setState({\n                scatter\n            });\n            alert(&quot;scatter load success&quot;)\n        }).then(err=&gt;{\n          console.log(err)\n        });\n    }\n\n    showTodo(){\n        this.state.scatter.eos(network,Eos).getTableRows({code: &quot;shaokun11113&quot;, scope: &quot;shaokun11113&quot;,table: &quot;tood&quot;, json: true})\n        .then(res=&gt;{\n            this.setState({\n                rows:res.rows\n            })\n        })\n    }\n\n    render() {\n    return (\n        &lt;div&gt;\n\n            &lt;div&gt;\n                &lt;button onClick={() =&gt; {\n                    const num = Math.floor(Math.random() * 100000);\n                    this.takeAction(&quot;create&quot;,[num,&quot;this is number &quot;+num])\n                }}&gt;create todo&lt;/button&gt;\n                &lt;button onClick={() =&gt; this.takeAction(&quot;destroy&quot;,[this.state.deleteId])}&gt;destroy todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        deleteId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n\n                &lt;button onClick={() =&gt; this.takeAction(&quot;complete&quot;,[this.state.competedId])}&gt;complete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        competedId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n                &lt;button onClick={() =&gt; this.showTodo()}&gt;show todo&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;p&gt;below is data&lt;/p&gt;\n                &lt;ul&gt;\n                    {\n                        this.state.rows.map((todo, index) =&gt; {\n                            return &lt;li key={index}&gt;\n                                &lt;p&gt;id : {todo.id}&lt;/p&gt;\n                                &lt;p&gt;description : {todo.description}&lt;/p&gt;\n                                &lt;p&gt;completed : {todo.completed}&lt;/p&gt;\n                            &lt;/li&gt;\n                        })\n                    }\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n  }\n}\n\nexport default App;\n</code></pre><p><code>todolist.cpp</code></p>\n<pre><code>include &lt;eosiolib/eosio.hpp&gt;  \n\nusing namespace std;\n\nclass [[eosio::contract]] todolist : public eosio::contract {  \n  public:\n\n  todolist(eosio::name reciever, eosio::name code, eosio::datastream&lt;const char*&gt; ds)\n                                                        :contract(reciever,code,ds),\n                                                         todos(reciever,code.value){};   \n\n\n  [[eosio::action]]   \n  void create(eosio::name author, const uint32_t id, const string&amp; description) {\n    todos.emplace(author, [&amp;](auto &amp;new_todo) {\n        new_todo.id = id;\n        new_todo.description = description;\n        new_todo.completed = 0;\n    });\n   }\n\n  [[eosio::action]]\n  void complete(eosio::name author,const uint32_t id)\n  {  \n      eosio::require_auth(author);\n\n      auto itr = todos.find(id);\n      // 是否用find()方法，去查找这条方法对应的实例\n      eosio_assert(itr != todos.end(), &quot;todo does not exit&quot;);\n    // 这里 如果找不到，todos.end() 会返回 null\n      todos.modify(itr,author,[&amp;](auto &amp;t) {\n          t.completed = 1;\n      });\n  }\n\n  [[eosio::action]]\n  void destroy(eosio::name author, const uint32_t id){    \n     eosio::require_auth(author);\n      auto itr = todos.find(id);\n      if(itr != todos.end()){\n         todos.erase(itr);\n      }\n  }\n\n  private:\n  struct [[eosio::table]] todo {\n      uint64_t id;\n      string description;\n      uint64_t completed;\n\n      uint64_t primary_key() const {\n          return id;\n      }\n  };\n\n  typedef eosio::multi_index&lt;&quot;tood&quot;_n, todo&gt; todo_index;\n  todo_index todos;\n};\n\nEOSIO_DISPATCH(todolist, (create)(complete)(destroy))\n</code></pre><blockquote>\n<ul>\n<li>这里有一点要说明，貌似一个账号只能部署一个智能合约，希望这个结论是正确的</li>\n<li>上面的todo这个table，由于我的笔误，生成表名的时候写成了 tood,哈哈</li>\n<li>合约比较简单了，交互也比较简单，细心点，仔细点，相信你也可以步入eos dapp开发的大门了</li>\n</ul>\n</blockquote>\n<h4 id=\"eos智能合约开发-总结\"><a href=\"#eos智能合约开发-总结\" class=\"headerlink\" title=\"eos智能合约开发 总结\"></a>eos智能合约开发 总结</h4><blockquote>\n<ul>\n<li>请一定耐心的看完文章，中间漏了一点也会造成失败  </li>\n<li>最开始的文章截图使用的分辨率较高，图片显示较大，如若对你阅读造成阅读困难，可以适当缩小页面进行阅读</li>\n</ul>\n</blockquote>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x68;&#x61;&#111;&#x6b;&#117;&#110;&#105;&#x6e;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#x63;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#110;&#110;&#x79;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#110;&#110;&#x79;&#x40;&#x31;&#54;&#51;&#46;&#x63;&#111;&#109;</a></p>\n"},{"title":"结合scatter 学习eos dapp开发, 看这篇就够了（上）","date":"2018-10-13T07:14:24.000Z","_content":" \n#### eos安装 方式1\n[eos安装1](https://developers.eos.io/eosio-home/docs/setting-up-your-environment)  \n这是eos官网推荐的安装方式。\n\n官网推荐docker，可以减少不必要的麻烦 ，而且步骤超级详细，超级详细，要是安装不成功的话，请确认是否使用mac电脑或者官网推荐的其他操作系统，千万不要使用Windows系统来玩eos,因为官方说过不支持的哈。\n\n#### eos安装 方式2\n\n[eos 安装2](https://developers.eos.io/eosio-nodeos/docs/getting-the-code) \n \n\tgit clone https://github.com/EOSIO/eos --recursive\n\tcd eos\n\t./eosio_build.sh\n\t./eosio_install.sh\n\t// 从源码编译 准备好梯子很重要\n\t\n#### eoscdt安装  \n[eosio.cdt 安装1](https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit) 这里遵循官网的步骤\n \n\tgit clone --recursive https://github.com/eosio/eosio.cdt --branch \tv1.2.1 --single-branch\n\tcd eosio.cdt \n\t./build.sh eos\n\tsudo ./install.sh\n\t//这是新的生成wasm 和 abi的工具，以后官方会维护的，之前方式会在后续被移除 \n[eosio.cdt 安装2](https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit) 这里是最新的步骤\n#### eos安装 方式总结\n简单，超级简单。  \n但是，受限于我们得环境，自备梯子是成功的第一步，第二步就是要一个适合的硬件，两者缺一不可。\n\n#### eos智能合约开发 开发体会\n最好的学习资料就是官方提供的资料了，而且eos官方的资料具详细，在此送上  \n[eos官网](https://developers.eos.io/)\n\n安装不是我要说的重点，过程艰辛就不说了，有问题Google或者度娘吧，我这里主要想要与大家分享的是如何使用scatter连接eos的测试网或者主网进行dapp的开发。  \n  \n上面的环境安装了可以启动本地的节点来进行测试，官网也是如此，而现在我能够搜索到的文章基本上也是基于本地节点使用命令行来进行开发，这样只能保证你学习开发eos的流程，但是具体怎样开发dapp你可能还是不清楚，因为你不知道如何连接scatter，如何与智能合约进行交互，所以这篇文章重点解决的问题是在这里。\n\n这里再区分一下钱包开发和dapp的开发。钱包开发需要用户提供他的私钥给你，或者你创建好给用户。而我们此处所要使用的是官方的钱包scatter来进行开发dapp，不需要用户提供私钥给我们，他只需要接入官方提供的scatter就好，如果你有以太坊的经验，这就是metamask\n\n#### eos智能合约开发 scatter安装\n\nscatter，官方提供的eos钱包，这样用户才会放心把他们的密钥放进去，所以先安装它吧  \nscatter是chrome的插件，所以你先得安装它[chrome浏览器下载](https://www.google.com/chrome/)    \n接下来把scatter 插件安装上 [scatter Chrome插件](https://chrome.google.com/webstore/search/scatter?hl=zh-CN)  \n\n\n![scatter](/images/scatter00.png)  \n搜索scatter安装就好，我这里是安装好的界面  \n* \t![scatter](/images/scatter0.png)     \n点击插件的scatter图标弹出如图界面，输入你的钱包密码然后点击生成钱包就好   \n* \t![scatter](/images/scatter1.png)   \n助记词，抄写下来吧，以后恢复钱包用的   \n* \t![scatter](/images/scatter2.png)   \n这里我选择skip basic setup，后续再来设置也是可行的  \n*  ![scatter](/images/scatter3.png)     \n这个界面，点击右上角的⚙图标  \n*  ![scatter](/images/scatter4.png)    \n这个界面，选择language，设置语言  \n*  ![scatter](/images/scatter5.png)  \n设置好后，切换回来，成功了  \n#### eos智能合约开发 使用scatter生成密匙对\n1. 经过以上的步骤，scatter已经安装好了，也就是我们创建了钱包，但是我们的钱包还没有内容的，为什么呢？这里我还是看看官网的这张图吧   \n ![eos钱包关系](/images/eosio2.png)\n2. 基于上张图的方式，我们得创建一对密匙，那就按照接下来的方式做吧\n\t*  ![scatter](/images/scatter6.png)  \n\t点击密匙对，点击新建\n\t*  ![scatter](/images/scatter7.png)  \n\t点击生成密匙对  \n\t*  ![scatter](/images/scatter8.png)  \n\t重点，记住这里的步骤不能省略  \n\t重点，记住这里的步骤不能省略  \n\t重点，记住这里的步骤不能省略  \n\t点击   复制  \n\t*  ![scatter](/images/scatter9.png)    \n\t新开一个文本文档，点击粘贴，这样就把生成好的密匙对保存下来了，待会要用的  \n\t*  ![scatter](/images/scatter10.png)  \n\t为这个密匙对取个名字，随便写，随意几好 \n\t*  ![scatter](/images/scatter11.png)  \n\t完成了这些步骤，你应该能够看到上面的信息，如果没有，就再从头来一遍了。  \n\t这样我们的密匙对就创建好了，但是只是在本地创建好了的啊，怎么连接到测试网络和主网络呢？  \n\t\n#### eos智能合约开发 设置scatter连接 jungle test net \n*  ![scatter net setting](/images/scatter5.png)  \n 回到这个界面，选择设置图标，选择\n*  ![scatter net setting](/images/scatter12.png)  \n这个界面选择网络  \n*  ![scatter net setting](/images/scatter13.png)  \n这里可以看到已经有一个eos和eth的主网的网络节点，那么我们来把我们的测试网络的节点加入进去，点击右上角的新建  \n*  ![scatter net setting](/images/scatter14.png)  \n这个界面就是设置网络所需要的一些必要信息，我们一个一个来填  \n\t1. 由于我们是连接eos网络，所以这里第一项默认不变，下拉框可以选择eth,以后还可以支持tron\n\t2. 名称： 随便写一个，你自己记得住就好  \n\t3. 改成http,因为我们测试网络的endpoint就是用的这个协议，照改就好。\n\t4. 域名或ip地址：jungle.cryptolions.io\t\n\t5. 端口 ：18888\n\t6. chaninId:  038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca\n\t7. 如果你对以上填入的这些信息想知道为什么，那么可以补一下rpc协议，不想了解直接填入就好，以后就懂了  \n*  ![scatter net setting](/images/scatter15.png)  \n按照上述的步骤填完后，信息如上，点击右上角保存  \n*  ![scatter net setting](/images/scatter16.png)  \n没有问题的话，会看到如上红框的显示内容，代表我们得测试网络已经设置好了\n\n#### eos智能合约开发 在jungle测试网络上创建account\n>为什么要创建账户呢？这就是eos的一大特点。BM说，你创建了一个密匙对，谁记得住呢，所以就设计了一个这样的账户系统，这个账户 长12位，只能由a-z12345这些字符组成。简而言之，方便记忆。\n\n* [jungle net account ](http://jungle.cryptolions.io/#home)  \n打开jungle测试网络地址\n* ![jungle net account ](/images/jungle1.png)  \n来到jungle的主页，点击 Create Account  \n* ![jungle net account ](/images/jungle2.png)  \n\t1. \tAccount name : 看清楚要求 *小写字母 加上12345，总共12个字符*   \n\t这里我写作 shaokun11113\n\t2. owner public key : 将我们用scatter生成的那个密匙对的公钥填入这里\n\t3. active public key: 将我们用scatter生成的那个密匙对的公钥填入这里\n\t4. 我这里用一对就好，在主网申请账号的时候建议使用两对密匙对。想要知道为什么？可以看看eos第二版的白皮书\n* ![jungle net account ](/images/jungle03.png)  \n这次我就这样填写，然后人机验证，通过后点击左下角的create,确保网络质量优良  \n\n**文章允许转载，但请注明出处，谢谢**\n\n**这里我的网络质量太差了。。。先写到这里，，， 请继续关注第二篇**  \n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png)          \n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/基于eos连接scatter开发dapp.md","raw":"---\ntitle: 结合scatter 学习eos dapp开发, 看这篇就够了（上）\ndate: 2018-10-13 15:14:24\n---\n \n#### eos安装 方式1\n[eos安装1](https://developers.eos.io/eosio-home/docs/setting-up-your-environment)  \n这是eos官网推荐的安装方式。\n\n官网推荐docker，可以减少不必要的麻烦 ，而且步骤超级详细，超级详细，要是安装不成功的话，请确认是否使用mac电脑或者官网推荐的其他操作系统，千万不要使用Windows系统来玩eos,因为官方说过不支持的哈。\n\n#### eos安装 方式2\n\n[eos 安装2](https://developers.eos.io/eosio-nodeos/docs/getting-the-code) \n \n\tgit clone https://github.com/EOSIO/eos --recursive\n\tcd eos\n\t./eosio_build.sh\n\t./eosio_install.sh\n\t// 从源码编译 准备好梯子很重要\n\t\n#### eoscdt安装  \n[eosio.cdt 安装1](https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit) 这里遵循官网的步骤\n \n\tgit clone --recursive https://github.com/eosio/eosio.cdt --branch \tv1.2.1 --single-branch\n\tcd eosio.cdt \n\t./build.sh eos\n\tsudo ./install.sh\n\t//这是新的生成wasm 和 abi的工具，以后官方会维护的，之前方式会在后续被移除 \n[eosio.cdt 安装2](https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit) 这里是最新的步骤\n#### eos安装 方式总结\n简单，超级简单。  \n但是，受限于我们得环境，自备梯子是成功的第一步，第二步就是要一个适合的硬件，两者缺一不可。\n\n#### eos智能合约开发 开发体会\n最好的学习资料就是官方提供的资料了，而且eos官方的资料具详细，在此送上  \n[eos官网](https://developers.eos.io/)\n\n安装不是我要说的重点，过程艰辛就不说了，有问题Google或者度娘吧，我这里主要想要与大家分享的是如何使用scatter连接eos的测试网或者主网进行dapp的开发。  \n  \n上面的环境安装了可以启动本地的节点来进行测试，官网也是如此，而现在我能够搜索到的文章基本上也是基于本地节点使用命令行来进行开发，这样只能保证你学习开发eos的流程，但是具体怎样开发dapp你可能还是不清楚，因为你不知道如何连接scatter，如何与智能合约进行交互，所以这篇文章重点解决的问题是在这里。\n\n这里再区分一下钱包开发和dapp的开发。钱包开发需要用户提供他的私钥给你，或者你创建好给用户。而我们此处所要使用的是官方的钱包scatter来进行开发dapp，不需要用户提供私钥给我们，他只需要接入官方提供的scatter就好，如果你有以太坊的经验，这就是metamask\n\n#### eos智能合约开发 scatter安装\n\nscatter，官方提供的eos钱包，这样用户才会放心把他们的密钥放进去，所以先安装它吧  \nscatter是chrome的插件，所以你先得安装它[chrome浏览器下载](https://www.google.com/chrome/)    \n接下来把scatter 插件安装上 [scatter Chrome插件](https://chrome.google.com/webstore/search/scatter?hl=zh-CN)  \n\n\n![scatter](/images/scatter00.png)  \n搜索scatter安装就好，我这里是安装好的界面  \n* \t![scatter](/images/scatter0.png)     \n点击插件的scatter图标弹出如图界面，输入你的钱包密码然后点击生成钱包就好   \n* \t![scatter](/images/scatter1.png)   \n助记词，抄写下来吧，以后恢复钱包用的   \n* \t![scatter](/images/scatter2.png)   \n这里我选择skip basic setup，后续再来设置也是可行的  \n*  ![scatter](/images/scatter3.png)     \n这个界面，点击右上角的⚙图标  \n*  ![scatter](/images/scatter4.png)    \n这个界面，选择language，设置语言  \n*  ![scatter](/images/scatter5.png)  \n设置好后，切换回来，成功了  \n#### eos智能合约开发 使用scatter生成密匙对\n1. 经过以上的步骤，scatter已经安装好了，也就是我们创建了钱包，但是我们的钱包还没有内容的，为什么呢？这里我还是看看官网的这张图吧   \n ![eos钱包关系](/images/eosio2.png)\n2. 基于上张图的方式，我们得创建一对密匙，那就按照接下来的方式做吧\n\t*  ![scatter](/images/scatter6.png)  \n\t点击密匙对，点击新建\n\t*  ![scatter](/images/scatter7.png)  \n\t点击生成密匙对  \n\t*  ![scatter](/images/scatter8.png)  \n\t重点，记住这里的步骤不能省略  \n\t重点，记住这里的步骤不能省略  \n\t重点，记住这里的步骤不能省略  \n\t点击   复制  \n\t*  ![scatter](/images/scatter9.png)    \n\t新开一个文本文档，点击粘贴，这样就把生成好的密匙对保存下来了，待会要用的  \n\t*  ![scatter](/images/scatter10.png)  \n\t为这个密匙对取个名字，随便写，随意几好 \n\t*  ![scatter](/images/scatter11.png)  \n\t完成了这些步骤，你应该能够看到上面的信息，如果没有，就再从头来一遍了。  \n\t这样我们的密匙对就创建好了，但是只是在本地创建好了的啊，怎么连接到测试网络和主网络呢？  \n\t\n#### eos智能合约开发 设置scatter连接 jungle test net \n*  ![scatter net setting](/images/scatter5.png)  \n 回到这个界面，选择设置图标，选择\n*  ![scatter net setting](/images/scatter12.png)  \n这个界面选择网络  \n*  ![scatter net setting](/images/scatter13.png)  \n这里可以看到已经有一个eos和eth的主网的网络节点，那么我们来把我们的测试网络的节点加入进去，点击右上角的新建  \n*  ![scatter net setting](/images/scatter14.png)  \n这个界面就是设置网络所需要的一些必要信息，我们一个一个来填  \n\t1. 由于我们是连接eos网络，所以这里第一项默认不变，下拉框可以选择eth,以后还可以支持tron\n\t2. 名称： 随便写一个，你自己记得住就好  \n\t3. 改成http,因为我们测试网络的endpoint就是用的这个协议，照改就好。\n\t4. 域名或ip地址：jungle.cryptolions.io\t\n\t5. 端口 ：18888\n\t6. chaninId:  038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca\n\t7. 如果你对以上填入的这些信息想知道为什么，那么可以补一下rpc协议，不想了解直接填入就好，以后就懂了  \n*  ![scatter net setting](/images/scatter15.png)  \n按照上述的步骤填完后，信息如上，点击右上角保存  \n*  ![scatter net setting](/images/scatter16.png)  \n没有问题的话，会看到如上红框的显示内容，代表我们得测试网络已经设置好了\n\n#### eos智能合约开发 在jungle测试网络上创建account\n>为什么要创建账户呢？这就是eos的一大特点。BM说，你创建了一个密匙对，谁记得住呢，所以就设计了一个这样的账户系统，这个账户 长12位，只能由a-z12345这些字符组成。简而言之，方便记忆。\n\n* [jungle net account ](http://jungle.cryptolions.io/#home)  \n打开jungle测试网络地址\n* ![jungle net account ](/images/jungle1.png)  \n来到jungle的主页，点击 Create Account  \n* ![jungle net account ](/images/jungle2.png)  \n\t1. \tAccount name : 看清楚要求 *小写字母 加上12345，总共12个字符*   \n\t这里我写作 shaokun11113\n\t2. owner public key : 将我们用scatter生成的那个密匙对的公钥填入这里\n\t3. active public key: 将我们用scatter生成的那个密匙对的公钥填入这里\n\t4. 我这里用一对就好，在主网申请账号的时候建议使用两对密匙对。想要知道为什么？可以看看eos第二版的白皮书\n* ![jungle net account ](/images/jungle03.png)  \n这次我就这样填写，然后人机验证，通过后点击左下角的create,确保网络质量优良  \n\n**文章允许转载，但请注明出处，谢谢**\n\n**这里我的网络质量太差了。。。先写到这里，，， 请继续关注第二篇**  \n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png)          \n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"基于eos连接scatter开发dapp","published":1,"updated":"2019-02-18T13:13:08.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b522000bnh7sf5ceplok","content":"<h4 id=\"eos安装-方式1\"><a href=\"#eos安装-方式1\" class=\"headerlink\" title=\"eos安装 方式1\"></a>eos安装 方式1</h4><p><a href=\"https://developers.eos.io/eosio-home/docs/setting-up-your-environment\" target=\"_blank\" rel=\"noopener\">eos安装1</a><br>这是eos官网推荐的安装方式。</p>\n<p>官网推荐docker，可以减少不必要的麻烦 ，而且步骤超级详细，超级详细，要是安装不成功的话，请确认是否使用mac电脑或者官网推荐的其他操作系统，千万不要使用Windows系统来玩eos,因为官方说过不支持的哈。</p>\n<h4 id=\"eos安装-方式2\"><a href=\"#eos安装-方式2\" class=\"headerlink\" title=\"eos安装 方式2\"></a>eos安装 方式2</h4><p><a href=\"https://developers.eos.io/eosio-nodeos/docs/getting-the-code\" target=\"_blank\" rel=\"noopener\">eos 安装2</a> </p>\n<pre><code>git clone https://github.com/EOSIO/eos --recursive\ncd eos\n./eosio_build.sh\n./eosio_install.sh\n// 从源码编译 准备好梯子很重要\n</code></pre><h4 id=\"eoscdt安装\"><a href=\"#eoscdt安装\" class=\"headerlink\" title=\"eoscdt安装\"></a>eoscdt安装</h4><p><a href=\"https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit\" target=\"_blank\" rel=\"noopener\">eosio.cdt 安装1</a> 这里遵循官网的步骤</p>\n<pre><code>git clone --recursive https://github.com/eosio/eosio.cdt --branch     v1.2.1 --single-branch\ncd eosio.cdt \n./build.sh eos\nsudo ./install.sh\n//这是新的生成wasm 和 abi的工具，以后官方会维护的，之前方式会在后续被移除 \n</code></pre><p><a href=\"https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit\" target=\"_blank\" rel=\"noopener\">eosio.cdt 安装2</a> 这里是最新的步骤</p>\n<h4 id=\"eos安装-方式总结\"><a href=\"#eos安装-方式总结\" class=\"headerlink\" title=\"eos安装 方式总结\"></a>eos安装 方式总结</h4><p>简单，超级简单。<br>但是，受限于我们得环境，自备梯子是成功的第一步，第二步就是要一个适合的硬件，两者缺一不可。</p>\n<h4 id=\"eos智能合约开发-开发体会\"><a href=\"#eos智能合约开发-开发体会\" class=\"headerlink\" title=\"eos智能合约开发 开发体会\"></a>eos智能合约开发 开发体会</h4><p>最好的学习资料就是官方提供的资料了，而且eos官方的资料具详细，在此送上<br><a href=\"https://developers.eos.io/\" target=\"_blank\" rel=\"noopener\">eos官网</a></p>\n<p>安装不是我要说的重点，过程艰辛就不说了，有问题Google或者度娘吧，我这里主要想要与大家分享的是如何使用scatter连接eos的测试网或者主网进行dapp的开发。  </p>\n<p>上面的环境安装了可以启动本地的节点来进行测试，官网也是如此，而现在我能够搜索到的文章基本上也是基于本地节点使用命令行来进行开发，这样只能保证你学习开发eos的流程，但是具体怎样开发dapp你可能还是不清楚，因为你不知道如何连接scatter，如何与智能合约进行交互，所以这篇文章重点解决的问题是在这里。</p>\n<p>这里再区分一下钱包开发和dapp的开发。钱包开发需要用户提供他的私钥给你，或者你创建好给用户。而我们此处所要使用的是官方的钱包scatter来进行开发dapp，不需要用户提供私钥给我们，他只需要接入官方提供的scatter就好，如果你有以太坊的经验，这就是metamask</p>\n<h4 id=\"eos智能合约开发-scatter安装\"><a href=\"#eos智能合约开发-scatter安装\" class=\"headerlink\" title=\"eos智能合约开发 scatter安装\"></a>eos智能合约开发 scatter安装</h4><p>scatter，官方提供的eos钱包，这样用户才会放心把他们的密钥放进去，所以先安装它吧<br>scatter是chrome的插件，所以你先得安装它<a href=\"https://www.google.com/chrome/\" target=\"_blank\" rel=\"noopener\">chrome浏览器下载</a><br>接下来把scatter 插件安装上 <a href=\"https://chrome.google.com/webstore/search/scatter?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">scatter Chrome插件</a>  </p>\n<p><img src=\"/images/scatter00.png\" alt=\"scatter\"><br>搜索scatter安装就好，我这里是安装好的界面  </p>\n<ul>\n<li><img src=\"/images/scatter0.png\" alt=\"scatter\"><br>点击插件的scatter图标弹出如图界面，输入你的钱包密码然后点击生成钱包就好   </li>\n<li><img src=\"/images/scatter1.png\" alt=\"scatter\"><br>助记词，抄写下来吧，以后恢复钱包用的   </li>\n<li><img src=\"/images/scatter2.png\" alt=\"scatter\"><br>这里我选择skip basic setup，后续再来设置也是可行的  </li>\n<li><img src=\"/images/scatter3.png\" alt=\"scatter\"><br>这个界面，点击右上角的⚙图标  </li>\n<li><img src=\"/images/scatter4.png\" alt=\"scatter\"><br>这个界面，选择language，设置语言  </li>\n<li><img src=\"/images/scatter5.png\" alt=\"scatter\"><br>设置好后，切换回来，成功了  <h4 id=\"eos智能合约开发-使用scatter生成密匙对\"><a href=\"#eos智能合约开发-使用scatter生成密匙对\" class=\"headerlink\" title=\"eos智能合约开发 使用scatter生成密匙对\"></a>eos智能合约开发 使用scatter生成密匙对</h4></li>\n</ul>\n<ol>\n<li>经过以上的步骤，scatter已经安装好了，也就是我们创建了钱包，但是我们的钱包还没有内容的，为什么呢？这里我还是看看官网的这张图吧<br><img src=\"/images/eosio2.png\" alt=\"eos钱包关系\"></li>\n<li>基于上张图的方式，我们得创建一对密匙，那就按照接下来的方式做吧<ul>\n<li><img src=\"/images/scatter6.png\" alt=\"scatter\"><br>点击密匙对，点击新建</li>\n<li><img src=\"/images/scatter7.png\" alt=\"scatter\"><br>点击生成密匙对  </li>\n<li><img src=\"/images/scatter8.png\" alt=\"scatter\"><br>重点，记住这里的步骤不能省略<br>重点，记住这里的步骤不能省略<br>重点，记住这里的步骤不能省略<br>点击   复制  </li>\n<li><img src=\"/images/scatter9.png\" alt=\"scatter\"><br>新开一个文本文档，点击粘贴，这样就把生成好的密匙对保存下来了，待会要用的  </li>\n<li><img src=\"/images/scatter10.png\" alt=\"scatter\"><br>为这个密匙对取个名字，随便写，随意几好 </li>\n<li><img src=\"/images/scatter11.png\" alt=\"scatter\"><br>完成了这些步骤，你应该能够看到上面的信息，如果没有，就再从头来一遍了。<br>这样我们的密匙对就创建好了，但是只是在本地创建好了的啊，怎么连接到测试网络和主网络呢？  </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"eos智能合约开发-设置scatter连接-jungle-test-net\"><a href=\"#eos智能合约开发-设置scatter连接-jungle-test-net\" class=\"headerlink\" title=\"eos智能合约开发 设置scatter连接 jungle test net\"></a>eos智能合约开发 设置scatter连接 jungle test net</h4><ul>\n<li><img src=\"/images/scatter5.png\" alt=\"scatter net setting\"><br>回到这个界面，选择设置图标，选择</li>\n<li><img src=\"/images/scatter12.png\" alt=\"scatter net setting\"><br>这个界面选择网络  </li>\n<li><img src=\"/images/scatter13.png\" alt=\"scatter net setting\"><br>这里可以看到已经有一个eos和eth的主网的网络节点，那么我们来把我们的测试网络的节点加入进去，点击右上角的新建  </li>\n<li><img src=\"/images/scatter14.png\" alt=\"scatter net setting\"><br>这个界面就是设置网络所需要的一些必要信息，我们一个一个来填  <ol>\n<li>由于我们是连接eos网络，所以这里第一项默认不变，下拉框可以选择eth,以后还可以支持tron</li>\n<li>名称： 随便写一个，你自己记得住就好  </li>\n<li>改成http,因为我们测试网络的endpoint就是用的这个协议，照改就好。</li>\n<li>域名或ip地址：jungle.cryptolions.io    </li>\n<li>端口 ：18888</li>\n<li>chaninId:  038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca</li>\n<li>如果你对以上填入的这些信息想知道为什么，那么可以补一下rpc协议，不想了解直接填入就好，以后就懂了  </li>\n</ol>\n</li>\n<li><img src=\"/images/scatter15.png\" alt=\"scatter net setting\"><br>按照上述的步骤填完后，信息如上，点击右上角保存  </li>\n<li><img src=\"/images/scatter16.png\" alt=\"scatter net setting\"><br>没有问题的话，会看到如上红框的显示内容，代表我们得测试网络已经设置好了</li>\n</ul>\n<h4 id=\"eos智能合约开发-在jungle测试网络上创建account\"><a href=\"#eos智能合约开发-在jungle测试网络上创建account\" class=\"headerlink\" title=\"eos智能合约开发 在jungle测试网络上创建account\"></a>eos智能合约开发 在jungle测试网络上创建account</h4><blockquote>\n<p>为什么要创建账户呢？这就是eos的一大特点。BM说，你创建了一个密匙对，谁记得住呢，所以就设计了一个这样的账户系统，这个账户 长12位，只能由a-z12345这些字符组成。简而言之，方便记忆。</p>\n</blockquote>\n<ul>\n<li><a href=\"http://jungle.cryptolions.io/#home\" target=\"_blank\" rel=\"noopener\">jungle net account </a><br>打开jungle测试网络地址</li>\n<li><img src=\"/images/jungle1.png\" alt=\"jungle net account \"><br>来到jungle的主页，点击 Create Account  </li>\n<li><img src=\"/images/jungle2.png\" alt=\"jungle net account \">  <ol>\n<li>Account name : 看清楚要求 <em>小写字母 加上12345，总共12个字符</em><br>这里我写作 shaokun11113</li>\n<li>owner public key : 将我们用scatter生成的那个密匙对的公钥填入这里</li>\n<li>active public key: 将我们用scatter生成的那个密匙对的公钥填入这里</li>\n<li>我这里用一对就好，在主网申请账号的时候建议使用两对密匙对。想要知道为什么？可以看看eos第二版的白皮书</li>\n</ol>\n</li>\n<li><img src=\"/images/jungle03.png\" alt=\"jungle net account \"><br>这次我就这样填写，然后人机验证，通过后点击左下角的create,确保网络质量优良  </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p><strong>这里我的网络质量太差了。。。先写到这里，，， 请继续关注第二篇</strong>  </p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"><br>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#x6f;&#x6b;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#x6f;&#x6b;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"eos安装-方式1\"><a href=\"#eos安装-方式1\" class=\"headerlink\" title=\"eos安装 方式1\"></a>eos安装 方式1</h4><p><a href=\"https://developers.eos.io/eosio-home/docs/setting-up-your-environment\" target=\"_blank\" rel=\"noopener\">eos安装1</a><br>这是eos官网推荐的安装方式。</p>\n<p>官网推荐docker，可以减少不必要的麻烦 ，而且步骤超级详细，超级详细，要是安装不成功的话，请确认是否使用mac电脑或者官网推荐的其他操作系统，千万不要使用Windows系统来玩eos,因为官方说过不支持的哈。</p>\n<h4 id=\"eos安装-方式2\"><a href=\"#eos安装-方式2\" class=\"headerlink\" title=\"eos安装 方式2\"></a>eos安装 方式2</h4><p><a href=\"https://developers.eos.io/eosio-nodeos/docs/getting-the-code\" target=\"_blank\" rel=\"noopener\">eos 安装2</a> </p>\n<pre><code>git clone https://github.com/EOSIO/eos --recursive\ncd eos\n./eosio_build.sh\n./eosio_install.sh\n// 从源码编译 准备好梯子很重要\n</code></pre><h4 id=\"eoscdt安装\"><a href=\"#eoscdt安装\" class=\"headerlink\" title=\"eoscdt安装\"></a>eoscdt安装</h4><p><a href=\"https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit\" target=\"_blank\" rel=\"noopener\">eosio.cdt 安装1</a> 这里遵循官网的步骤</p>\n<pre><code>git clone --recursive https://github.com/eosio/eosio.cdt --branch     v1.2.1 --single-branch\ncd eosio.cdt \n./build.sh eos\nsudo ./install.sh\n//这是新的生成wasm 和 abi的工具，以后官方会维护的，之前方式会在后续被移除 \n</code></pre><p><a href=\"https://developers.eos.io/eosio-home/docs/installing-the-contract-development-toolkit\" target=\"_blank\" rel=\"noopener\">eosio.cdt 安装2</a> 这里是最新的步骤</p>\n<h4 id=\"eos安装-方式总结\"><a href=\"#eos安装-方式总结\" class=\"headerlink\" title=\"eos安装 方式总结\"></a>eos安装 方式总结</h4><p>简单，超级简单。<br>但是，受限于我们得环境，自备梯子是成功的第一步，第二步就是要一个适合的硬件，两者缺一不可。</p>\n<h4 id=\"eos智能合约开发-开发体会\"><a href=\"#eos智能合约开发-开发体会\" class=\"headerlink\" title=\"eos智能合约开发 开发体会\"></a>eos智能合约开发 开发体会</h4><p>最好的学习资料就是官方提供的资料了，而且eos官方的资料具详细，在此送上<br><a href=\"https://developers.eos.io/\" target=\"_blank\" rel=\"noopener\">eos官网</a></p>\n<p>安装不是我要说的重点，过程艰辛就不说了，有问题Google或者度娘吧，我这里主要想要与大家分享的是如何使用scatter连接eos的测试网或者主网进行dapp的开发。  </p>\n<p>上面的环境安装了可以启动本地的节点来进行测试，官网也是如此，而现在我能够搜索到的文章基本上也是基于本地节点使用命令行来进行开发，这样只能保证你学习开发eos的流程，但是具体怎样开发dapp你可能还是不清楚，因为你不知道如何连接scatter，如何与智能合约进行交互，所以这篇文章重点解决的问题是在这里。</p>\n<p>这里再区分一下钱包开发和dapp的开发。钱包开发需要用户提供他的私钥给你，或者你创建好给用户。而我们此处所要使用的是官方的钱包scatter来进行开发dapp，不需要用户提供私钥给我们，他只需要接入官方提供的scatter就好，如果你有以太坊的经验，这就是metamask</p>\n<h4 id=\"eos智能合约开发-scatter安装\"><a href=\"#eos智能合约开发-scatter安装\" class=\"headerlink\" title=\"eos智能合约开发 scatter安装\"></a>eos智能合约开发 scatter安装</h4><p>scatter，官方提供的eos钱包，这样用户才会放心把他们的密钥放进去，所以先安装它吧<br>scatter是chrome的插件，所以你先得安装它<a href=\"https://www.google.com/chrome/\" target=\"_blank\" rel=\"noopener\">chrome浏览器下载</a><br>接下来把scatter 插件安装上 <a href=\"https://chrome.google.com/webstore/search/scatter?hl=zh-CN\" target=\"_blank\" rel=\"noopener\">scatter Chrome插件</a>  </p>\n<p><img src=\"/images/scatter00.png\" alt=\"scatter\"><br>搜索scatter安装就好，我这里是安装好的界面  </p>\n<ul>\n<li><img src=\"/images/scatter0.png\" alt=\"scatter\"><br>点击插件的scatter图标弹出如图界面，输入你的钱包密码然后点击生成钱包就好   </li>\n<li><img src=\"/images/scatter1.png\" alt=\"scatter\"><br>助记词，抄写下来吧，以后恢复钱包用的   </li>\n<li><img src=\"/images/scatter2.png\" alt=\"scatter\"><br>这里我选择skip basic setup，后续再来设置也是可行的  </li>\n<li><img src=\"/images/scatter3.png\" alt=\"scatter\"><br>这个界面，点击右上角的⚙图标  </li>\n<li><img src=\"/images/scatter4.png\" alt=\"scatter\"><br>这个界面，选择language，设置语言  </li>\n<li><img src=\"/images/scatter5.png\" alt=\"scatter\"><br>设置好后，切换回来，成功了  <h4 id=\"eos智能合约开发-使用scatter生成密匙对\"><a href=\"#eos智能合约开发-使用scatter生成密匙对\" class=\"headerlink\" title=\"eos智能合约开发 使用scatter生成密匙对\"></a>eos智能合约开发 使用scatter生成密匙对</h4></li>\n</ul>\n<ol>\n<li>经过以上的步骤，scatter已经安装好了，也就是我们创建了钱包，但是我们的钱包还没有内容的，为什么呢？这里我还是看看官网的这张图吧<br><img src=\"/images/eosio2.png\" alt=\"eos钱包关系\"></li>\n<li>基于上张图的方式，我们得创建一对密匙，那就按照接下来的方式做吧<ul>\n<li><img src=\"/images/scatter6.png\" alt=\"scatter\"><br>点击密匙对，点击新建</li>\n<li><img src=\"/images/scatter7.png\" alt=\"scatter\"><br>点击生成密匙对  </li>\n<li><img src=\"/images/scatter8.png\" alt=\"scatter\"><br>重点，记住这里的步骤不能省略<br>重点，记住这里的步骤不能省略<br>重点，记住这里的步骤不能省略<br>点击   复制  </li>\n<li><img src=\"/images/scatter9.png\" alt=\"scatter\"><br>新开一个文本文档，点击粘贴，这样就把生成好的密匙对保存下来了，待会要用的  </li>\n<li><img src=\"/images/scatter10.png\" alt=\"scatter\"><br>为这个密匙对取个名字，随便写，随意几好 </li>\n<li><img src=\"/images/scatter11.png\" alt=\"scatter\"><br>完成了这些步骤，你应该能够看到上面的信息，如果没有，就再从头来一遍了。<br>这样我们的密匙对就创建好了，但是只是在本地创建好了的啊，怎么连接到测试网络和主网络呢？  </li>\n</ul>\n</li>\n</ol>\n<h4 id=\"eos智能合约开发-设置scatter连接-jungle-test-net\"><a href=\"#eos智能合约开发-设置scatter连接-jungle-test-net\" class=\"headerlink\" title=\"eos智能合约开发 设置scatter连接 jungle test net\"></a>eos智能合约开发 设置scatter连接 jungle test net</h4><ul>\n<li><img src=\"/images/scatter5.png\" alt=\"scatter net setting\"><br>回到这个界面，选择设置图标，选择</li>\n<li><img src=\"/images/scatter12.png\" alt=\"scatter net setting\"><br>这个界面选择网络  </li>\n<li><img src=\"/images/scatter13.png\" alt=\"scatter net setting\"><br>这里可以看到已经有一个eos和eth的主网的网络节点，那么我们来把我们的测试网络的节点加入进去，点击右上角的新建  </li>\n<li><img src=\"/images/scatter14.png\" alt=\"scatter net setting\"><br>这个界面就是设置网络所需要的一些必要信息，我们一个一个来填  <ol>\n<li>由于我们是连接eos网络，所以这里第一项默认不变，下拉框可以选择eth,以后还可以支持tron</li>\n<li>名称： 随便写一个，你自己记得住就好  </li>\n<li>改成http,因为我们测试网络的endpoint就是用的这个协议，照改就好。</li>\n<li>域名或ip地址：jungle.cryptolions.io    </li>\n<li>端口 ：18888</li>\n<li>chaninId:  038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca</li>\n<li>如果你对以上填入的这些信息想知道为什么，那么可以补一下rpc协议，不想了解直接填入就好，以后就懂了  </li>\n</ol>\n</li>\n<li><img src=\"/images/scatter15.png\" alt=\"scatter net setting\"><br>按照上述的步骤填完后，信息如上，点击右上角保存  </li>\n<li><img src=\"/images/scatter16.png\" alt=\"scatter net setting\"><br>没有问题的话，会看到如上红框的显示内容，代表我们得测试网络已经设置好了</li>\n</ul>\n<h4 id=\"eos智能合约开发-在jungle测试网络上创建account\"><a href=\"#eos智能合约开发-在jungle测试网络上创建account\" class=\"headerlink\" title=\"eos智能合约开发 在jungle测试网络上创建account\"></a>eos智能合约开发 在jungle测试网络上创建account</h4><blockquote>\n<p>为什么要创建账户呢？这就是eos的一大特点。BM说，你创建了一个密匙对，谁记得住呢，所以就设计了一个这样的账户系统，这个账户 长12位，只能由a-z12345这些字符组成。简而言之，方便记忆。</p>\n</blockquote>\n<ul>\n<li><a href=\"http://jungle.cryptolions.io/#home\" target=\"_blank\" rel=\"noopener\">jungle net account </a><br>打开jungle测试网络地址</li>\n<li><img src=\"/images/jungle1.png\" alt=\"jungle net account \"><br>来到jungle的主页，点击 Create Account  </li>\n<li><img src=\"/images/jungle2.png\" alt=\"jungle net account \">  <ol>\n<li>Account name : 看清楚要求 <em>小写字母 加上12345，总共12个字符</em><br>这里我写作 shaokun11113</li>\n<li>owner public key : 将我们用scatter生成的那个密匙对的公钥填入这里</li>\n<li>active public key: 将我们用scatter生成的那个密匙对的公钥填入这里</li>\n<li>我这里用一对就好，在主网申请账号的时候建议使用两对密匙对。想要知道为什么？可以看看eos第二版的白皮书</li>\n</ol>\n</li>\n<li><img src=\"/images/jungle03.png\" alt=\"jungle net account \"><br>这次我就这样填写，然后人机验证，通过后点击左下角的create,确保网络质量优良  </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p><strong>这里我的网络质量太差了。。。先写到这里，，， 请继续关注第二篇</strong>  </p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"><br>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#x6f;&#x6b;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#x6f;&#x6b;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#x67;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#x6e;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#109;</a></p>\n"},{"title":"一步一步教你在eos主网上发行自己的tokens","date":"2019-02-23T05:33:56.000Z","_content":"\n#### 前言\n* 2019年来了,祝大家新年快乐\n* 新的一年我们得继续努力呢,当然我也得继续来填坑\n* 接着上篇文章来,本篇文章会带着你一步一步在测试网(主网要真金白银呢)上发行自己的token\n* 本来官网的教程中已经有教怎么样发行自己的token了 [eosio token issue](https://developers.eos.io/eosio-home/docs/token-contract),为什么我还要再写一遍呢?\n* 我觉得在我学习的过程中遇到了以下两个问题:\n\t1. 我没有eosio.token的账号呢,我怎么发行token呢? \n\t2. 那我就用自己的account进行发布,那这样的token可以使用吗?\n\t3. 发布token的合约是怎么样的呢?\n* 请自备有足够ram的kylin的账号呢,不然后面没法走哈\n\n#### 获取token源码\n* 相信跟着官网走得同学都是在本地的目录中去看源码的,这个源码版本目前只能使用eosiocpp编译,而我目前需要使用cdt来编译呢.\n* 所以我们得来这里获取支持cdt的源码[eosio.contracts](https://github.com/EOSIO/eosio.contracts),这里存了系统的的contract源码,我们需要eosio.token的合约源码,我们第一步先把它download下来\n* 建议不用修改,除非增加新的业务逻辑\n\n#### token源码分析\n* 文中有注释就不啰嗦了,各位同学自己看就好\n* 如果有同学看过旧版token的合约,可以发现还有有些变化的.不过我们不用care之前的旧版token合约,使用新版的就好\n* token中主要有两个table,account 和 currency_stats  \n\t 1. account主要负责记录用户的余额,这个table储存余额很有趣. 使用owner作为scope(这里可以理解为在这个就是一个单独的小table),然后在里面找有没有对应的symbol(前提这symbol得通过currency_stats table的检查,即已经create的)\n\t 2. currency_stats主要负责记录发行的token的信息,主要包括最大发行量,和已经在市面上流通的token数量\n* token合约中含有create,issue,retire,transfer,open,close六个action,和get_balance,get_supply两个静态方法.其中创建一个token,只有create, issue, transfer是必须的,其他的可根据需求进行增添\n\t1. retire 燃烧自己的自己的token,这里token燃烧后总量不会变,相当于又返回给issuer了,如果需要此功能建议减少totalSupply而不是suppy\n\t2. open和close这两个方法我猜测是为了当issuer token给新账号的时候,可以设置这笔费用,个人觉得没什么鸟用\n\t3. get_balance和get_supply可以直接获取账户余额和已经issue的token\n\n#### 编译,部署,验证\n* 编译,部署\n* 购买ram\n* craete SHAOKUN token,总量10000个,比较值钱哈\n* issue 900个给eostoday1235,然后在retire掉(可以理解为销毁,不要这个action也可以) \n* 后续再转账,都可以在浏览器上查到对应的结果\n* ![演示结果](/img_eos1/eos_gif_2.gif)\n* [源码](https://github.com/shaokun11/eosabout/tree/create-token)\n\n#### 总结\n* 按照上面的步骤,我们已经发行了一种token,注意是使用我们自己的账号\n* 回想一下dispatcher的文章,我们为什么要去判断 code == eosio.token的原因呢? 其实就是确保我们这个token是市面上流通的eos代币,而不是其他某个个人发布的token\n* 一个账号可以发行很多token的,只要symbol不一致就可以了,当然,这个账号也可以发行以eos为symbol的token\n* 最终再和以太坊的erc20 token对比一下,其实这都是一个官方的标准,我们如果想直接使用完全不用修改的,直接往主网部署就可以了.\n* 有时候有新的业务需求,我们完全可以根据自己的需求来更改token内部的某些业务逻辑,毕竟它只是一份部署在你账号的一个智能合约而已,而且这个合约你完全有权限随时更改呢\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos测试网发行token.md","raw":"---\ntitle: 一步一步教你在eos主网上发行自己的tokens\ndate: 2019-02-23 13:33:56\n---\n\n#### 前言\n* 2019年来了,祝大家新年快乐\n* 新的一年我们得继续努力呢,当然我也得继续来填坑\n* 接着上篇文章来,本篇文章会带着你一步一步在测试网(主网要真金白银呢)上发行自己的token\n* 本来官网的教程中已经有教怎么样发行自己的token了 [eosio token issue](https://developers.eos.io/eosio-home/docs/token-contract),为什么我还要再写一遍呢?\n* 我觉得在我学习的过程中遇到了以下两个问题:\n\t1. 我没有eosio.token的账号呢,我怎么发行token呢? \n\t2. 那我就用自己的account进行发布,那这样的token可以使用吗?\n\t3. 发布token的合约是怎么样的呢?\n* 请自备有足够ram的kylin的账号呢,不然后面没法走哈\n\n#### 获取token源码\n* 相信跟着官网走得同学都是在本地的目录中去看源码的,这个源码版本目前只能使用eosiocpp编译,而我目前需要使用cdt来编译呢.\n* 所以我们得来这里获取支持cdt的源码[eosio.contracts](https://github.com/EOSIO/eosio.contracts),这里存了系统的的contract源码,我们需要eosio.token的合约源码,我们第一步先把它download下来\n* 建议不用修改,除非增加新的业务逻辑\n\n#### token源码分析\n* 文中有注释就不啰嗦了,各位同学自己看就好\n* 如果有同学看过旧版token的合约,可以发现还有有些变化的.不过我们不用care之前的旧版token合约,使用新版的就好\n* token中主要有两个table,account 和 currency_stats  \n\t 1. account主要负责记录用户的余额,这个table储存余额很有趣. 使用owner作为scope(这里可以理解为在这个就是一个单独的小table),然后在里面找有没有对应的symbol(前提这symbol得通过currency_stats table的检查,即已经create的)\n\t 2. currency_stats主要负责记录发行的token的信息,主要包括最大发行量,和已经在市面上流通的token数量\n* token合约中含有create,issue,retire,transfer,open,close六个action,和get_balance,get_supply两个静态方法.其中创建一个token,只有create, issue, transfer是必须的,其他的可根据需求进行增添\n\t1. retire 燃烧自己的自己的token,这里token燃烧后总量不会变,相当于又返回给issuer了,如果需要此功能建议减少totalSupply而不是suppy\n\t2. open和close这两个方法我猜测是为了当issuer token给新账号的时候,可以设置这笔费用,个人觉得没什么鸟用\n\t3. get_balance和get_supply可以直接获取账户余额和已经issue的token\n\n#### 编译,部署,验证\n* 编译,部署\n* 购买ram\n* craete SHAOKUN token,总量10000个,比较值钱哈\n* issue 900个给eostoday1235,然后在retire掉(可以理解为销毁,不要这个action也可以) \n* 后续再转账,都可以在浏览器上查到对应的结果\n* ![演示结果](/img_eos1/eos_gif_2.gif)\n* [源码](https://github.com/shaokun11/eosabout/tree/create-token)\n\n#### 总结\n* 按照上面的步骤,我们已经发行了一种token,注意是使用我们自己的账号\n* 回想一下dispatcher的文章,我们为什么要去判断 code == eosio.token的原因呢? 其实就是确保我们这个token是市面上流通的eos代币,而不是其他某个个人发布的token\n* 一个账号可以发行很多token的,只要symbol不一致就可以了,当然,这个账号也可以发行以eos为symbol的token\n* 最终再和以太坊的erc20 token对比一下,其实这都是一个官方的标准,我们如果想直接使用完全不用修改的,直接往主网部署就可以了.\n* 有时候有新的业务需求,我们完全可以根据自己的需求来更改token内部的某些业务逻辑,毕竟它只是一份部署在你账号的一个智能合约而已,而且这个合约你完全有权限随时更改呢\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos测试网发行token","published":1,"updated":"2019-02-23T07:28:01.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b524000cnh7sd9ohmqls","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>2019年来了,祝大家新年快乐</li>\n<li>新的一年我们得继续努力呢,当然我也得继续来填坑</li>\n<li>接着上篇文章来,本篇文章会带着你一步一步在测试网(主网要真金白银呢)上发行自己的token</li>\n<li>本来官网的教程中已经有教怎么样发行自己的token了 <a href=\"https://developers.eos.io/eosio-home/docs/token-contract\" target=\"_blank\" rel=\"noopener\">eosio token issue</a>,为什么我还要再写一遍呢?</li>\n<li>我觉得在我学习的过程中遇到了以下两个问题:<ol>\n<li>我没有eosio.token的账号呢,我怎么发行token呢? </li>\n<li>那我就用自己的account进行发布,那这样的token可以使用吗?</li>\n<li>发布token的合约是怎么样的呢?</li>\n</ol>\n</li>\n<li>请自备有足够ram的kylin的账号呢,不然后面没法走哈</li>\n</ul>\n<h4 id=\"获取token源码\"><a href=\"#获取token源码\" class=\"headerlink\" title=\"获取token源码\"></a>获取token源码</h4><ul>\n<li>相信跟着官网走得同学都是在本地的目录中去看源码的,这个源码版本目前只能使用eosiocpp编译,而我目前需要使用cdt来编译呢.</li>\n<li>所以我们得来这里获取支持cdt的源码<a href=\"https://github.com/EOSIO/eosio.contracts\" target=\"_blank\" rel=\"noopener\">eosio.contracts</a>,这里存了系统的的contract源码,我们需要eosio.token的合约源码,我们第一步先把它download下来</li>\n<li>建议不用修改,除非增加新的业务逻辑</li>\n</ul>\n<h4 id=\"token源码分析\"><a href=\"#token源码分析\" class=\"headerlink\" title=\"token源码分析\"></a>token源码分析</h4><ul>\n<li>文中有注释就不啰嗦了,各位同学自己看就好</li>\n<li>如果有同学看过旧版token的合约,可以发现还有有些变化的.不过我们不用care之前的旧版token合约,使用新版的就好</li>\n<li>token中主要有两个table,account 和 currency_stats  <ol>\n<li>account主要负责记录用户的余额,这个table储存余额很有趣. 使用owner作为scope(这里可以理解为在这个就是一个单独的小table),然后在里面找有没有对应的symbol(前提这symbol得通过currency_stats table的检查,即已经create的)</li>\n<li>currency_stats主要负责记录发行的token的信息,主要包括最大发行量,和已经在市面上流通的token数量</li>\n</ol>\n</li>\n<li>token合约中含有create,issue,retire,transfer,open,close六个action,和get_balance,get_supply两个静态方法.其中创建一个token,只有create, issue, transfer是必须的,其他的可根据需求进行增添<ol>\n<li>retire 燃烧自己的自己的token,这里token燃烧后总量不会变,相当于又返回给issuer了,如果需要此功能建议减少totalSupply而不是suppy</li>\n<li>open和close这两个方法我猜测是为了当issuer token给新账号的时候,可以设置这笔费用,个人觉得没什么鸟用</li>\n<li>get_balance和get_supply可以直接获取账户余额和已经issue的token</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"编译-部署-验证\"><a href=\"#编译-部署-验证\" class=\"headerlink\" title=\"编译,部署,验证\"></a>编译,部署,验证</h4><ul>\n<li>编译,部署</li>\n<li>购买ram</li>\n<li>craete SHAOKUN token,总量10000个,比较值钱哈</li>\n<li>issue 900个给eostoday1235,然后在retire掉(可以理解为销毁,不要这个action也可以) </li>\n<li>后续再转账,都可以在浏览器上查到对应的结果</li>\n<li><img src=\"/img_eos1/eos_gif_2.gif\" alt=\"演示结果\"></li>\n<li><a href=\"https://github.com/shaokun11/eosabout/tree/create-token\" target=\"_blank\" rel=\"noopener\">源码</a></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>按照上面的步骤,我们已经发行了一种token,注意是使用我们自己的账号</li>\n<li>回想一下dispatcher的文章,我们为什么要去判断 code == eosio.token的原因呢? 其实就是确保我们这个token是市面上流通的eos代币,而不是其他某个个人发布的token</li>\n<li>一个账号可以发行很多token的,只要symbol不一致就可以了,当然,这个账号也可以发行以eos为symbol的token</li>\n<li>最终再和以太坊的erc20 token对比一下,其实这都是一个官方的标准,我们如果想直接使用完全不用修改的,直接往主网部署就可以了.</li>\n<li>有时候有新的业务需求,我们完全可以根据自己的需求来更改token内部的某些业务逻辑,毕竟它只是一份部署在你账号的一个智能合约而已,而且这个合约你完全有权限随时更改呢</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#x75;&#110;&#105;&#110;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#x75;&#110;&#105;&#110;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>2019年来了,祝大家新年快乐</li>\n<li>新的一年我们得继续努力呢,当然我也得继续来填坑</li>\n<li>接着上篇文章来,本篇文章会带着你一步一步在测试网(主网要真金白银呢)上发行自己的token</li>\n<li>本来官网的教程中已经有教怎么样发行自己的token了 <a href=\"https://developers.eos.io/eosio-home/docs/token-contract\" target=\"_blank\" rel=\"noopener\">eosio token issue</a>,为什么我还要再写一遍呢?</li>\n<li>我觉得在我学习的过程中遇到了以下两个问题:<ol>\n<li>我没有eosio.token的账号呢,我怎么发行token呢? </li>\n<li>那我就用自己的account进行发布,那这样的token可以使用吗?</li>\n<li>发布token的合约是怎么样的呢?</li>\n</ol>\n</li>\n<li>请自备有足够ram的kylin的账号呢,不然后面没法走哈</li>\n</ul>\n<h4 id=\"获取token源码\"><a href=\"#获取token源码\" class=\"headerlink\" title=\"获取token源码\"></a>获取token源码</h4><ul>\n<li>相信跟着官网走得同学都是在本地的目录中去看源码的,这个源码版本目前只能使用eosiocpp编译,而我目前需要使用cdt来编译呢.</li>\n<li>所以我们得来这里获取支持cdt的源码<a href=\"https://github.com/EOSIO/eosio.contracts\" target=\"_blank\" rel=\"noopener\">eosio.contracts</a>,这里存了系统的的contract源码,我们需要eosio.token的合约源码,我们第一步先把它download下来</li>\n<li>建议不用修改,除非增加新的业务逻辑</li>\n</ul>\n<h4 id=\"token源码分析\"><a href=\"#token源码分析\" class=\"headerlink\" title=\"token源码分析\"></a>token源码分析</h4><ul>\n<li>文中有注释就不啰嗦了,各位同学自己看就好</li>\n<li>如果有同学看过旧版token的合约,可以发现还有有些变化的.不过我们不用care之前的旧版token合约,使用新版的就好</li>\n<li>token中主要有两个table,account 和 currency_stats  <ol>\n<li>account主要负责记录用户的余额,这个table储存余额很有趣. 使用owner作为scope(这里可以理解为在这个就是一个单独的小table),然后在里面找有没有对应的symbol(前提这symbol得通过currency_stats table的检查,即已经create的)</li>\n<li>currency_stats主要负责记录发行的token的信息,主要包括最大发行量,和已经在市面上流通的token数量</li>\n</ol>\n</li>\n<li>token合约中含有create,issue,retire,transfer,open,close六个action,和get_balance,get_supply两个静态方法.其中创建一个token,只有create, issue, transfer是必须的,其他的可根据需求进行增添<ol>\n<li>retire 燃烧自己的自己的token,这里token燃烧后总量不会变,相当于又返回给issuer了,如果需要此功能建议减少totalSupply而不是suppy</li>\n<li>open和close这两个方法我猜测是为了当issuer token给新账号的时候,可以设置这笔费用,个人觉得没什么鸟用</li>\n<li>get_balance和get_supply可以直接获取账户余额和已经issue的token</li>\n</ol>\n</li>\n</ul>\n<h4 id=\"编译-部署-验证\"><a href=\"#编译-部署-验证\" class=\"headerlink\" title=\"编译,部署,验证\"></a>编译,部署,验证</h4><ul>\n<li>编译,部署</li>\n<li>购买ram</li>\n<li>craete SHAOKUN token,总量10000个,比较值钱哈</li>\n<li>issue 900个给eostoday1235,然后在retire掉(可以理解为销毁,不要这个action也可以) </li>\n<li>后续再转账,都可以在浏览器上查到对应的结果</li>\n<li><img src=\"/img_eos1/eos_gif_2.gif\" alt=\"演示结果\"></li>\n<li><a href=\"https://github.com/shaokun11/eosabout/tree/create-token\" target=\"_blank\" rel=\"noopener\">源码</a></li>\n</ul>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>按照上面的步骤,我们已经发行了一种token,注意是使用我们自己的账号</li>\n<li>回想一下dispatcher的文章,我们为什么要去判断 code == eosio.token的原因呢? 其实就是确保我们这个token是市面上流通的eos代币,而不是其他某个个人发布的token</li>\n<li>一个账号可以发行很多token的,只要symbol不一致就可以了,当然,这个账号也可以发行以eos为symbol的token</li>\n<li>最终再和以太坊的erc20 token对比一下,其实这都是一个官方的标准,我们如果想直接使用完全不用修改的,直接往主网部署就可以了.</li>\n<li>有时候有新的业务需求,我们完全可以根据自己的需求来更改token内部的某些业务逻辑,毕竟它只是一份部署在你账号的一个智能合约而已,而且这个合约你完全有权限随时更改呢</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#x75;&#110;&#105;&#110;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#x75;&#110;&#105;&#110;&#x67;&#x40;&#103;&#x6d;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#x6e;&#x79;&#64;&#49;&#x36;&#51;&#x2e;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"全新的加密NTF表现形式---ERC998","date":"2018-09-19T15:05:41.000Z","_content":"##### ERC998\n>在开始之前，你可能需要了解一下区块链，比特币，以太坊，ERC20和ERC721的相关知识,因为整篇文章也是在此基础上的一个应用的开始。\n  \nERC998目前状态Draft,创建于2018/7/7\n具体信息可访问[ERC998](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md)。  \n特性：可组合（composable）。ERC20和ERC721仅仅是单一的物品的应用，而ERC998可以组合不同的ERC721和ERC20，使之产生更丰富的应用。可以类比主机（ERC721） +  显示器（ERC20）+ 外设（ERC721）= 电脑（ERC998）；通过这样的组合我们就能够创建出更加复杂，高级的功能。\n##### ERC998的两种实现\nComposableTopDown和ComposableBottonUp，本次结合我实际的应用只讲介绍前者，具体的不同可以参考官网，当然这里有一篇作者更详细的介绍:  \n[Top-Down and Bottom-Up Composables, What’s the Difference and Which One Should You Use?](https://hackernoon.com/top-down-and-bottom-up-composables-whats-the-difference-and-which-one-should-you-use-db939f6acf1d)\n\n\n##### ERC998接口分析\n原作者已经写得非常详细了，具体就不在具体分析了。这里结合avatar（ERC998的实现的虚拟形象）和clothes（ERC721的实现的衣服）简单的看看ComposableTopDown的实现吧。（ComposableBottonUp的原理也类似）  \n\n*interface ERC998ERC721TopDown*\n\n\n\tevent ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId)\n\n当avatar接收到一件clothes会触发的一个事件\n _from : clothes的原始owner address \n _tokenId : 哪一个avatar来穿这件衣服，即avatar id\n _childContract: clothes contract address    \n_childTokenId:  哪一件衣服，即clothes id  \n\n\n\n\tevent TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\n\n当avatar脱下一件clothes时会发出的一个事件  \ntokenId : 将要脱下clothes的avatar id  \n_to : 接收clothes address,在项目中  \n_childContract： clothes 合约地址  \n_childTokenId： clothes id\n\n\n\n\tfunction rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\n\nrootOwner:获得clothes的owner  address，实际上是调用的下面的这个函数\n返回的是加上ERC998的特殊值加上owner的address，可以通过address（_rootOwner）得到owner的address  \n_tokenId  需要查找的avatar id\n\n\tfunction rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\n  \nrootOwner：cloth对应的owner address  \n这里注意一下，此处返回的 root owner有可能是contract address ，也有可能是user address。根据作者的设计总共有四种可能\n_childContract ： clothes contract address\n_childTokenId ： clothes id\n\n\tfunction ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);  \nparentTokenOwner: 返回的是加上ERC998的特殊值加上owner address  \nparentTokenId : avatar id  \n_childContract: clothes contract address   \n_childTokenId： clothes id\n\n\tfunction onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4);\n\nbytes4: 返回的一个bytes4的值 用于更新其他NTF到avatar时的一个回调方法，告诉avatar转入了这个数据，将此数据添加到avatar的数据中.   \n**这里使用NTF代替其他ERC721 token**  \n_operator: 执行这个操作的address\n_from : 原始NTF 拥有者的 address\n_childTokenId： NTF id\n_data : 附加数据\n\n\tfunction transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\n\tfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\n\tfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external\n\n这是三个重载的方法，加上safe是为了确保转入的合约地址有类似于*onERC721Received*的方法进行回调，确保token不会丢失。如果转入的合约地址没有注册次方法，那么将不会转入成功，从而回退转移操作，保证NTF的安全。  \n如果转入的是user address，那么直接调用第一个方法即可。  \n这些方法均会触发TransferChild这个事件  \n_fromTokenId :  avatar id  \n_to ：接受clothes address  \n_childContract : clothes contract address\n_childTokenId ： 将要进行转出的clothes id  \n\n\tfunction transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external;\n\n如果avatar含有ERC998 ComposableTopDown的token,可以通过这个方法进行转移  \n\n\tfunction getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\n用于用户user自己转入clothes到avatar中，注意与*onERC721Received*进行比较。  \n_from : clothes拥有者的address\n_tokenId ：转进给哪一个avatar，即avatar id  \n_childContract :  clothes contract address   \n_childTokenId ： clothes id\n\n*interface ERC998ERC721TopDownEnumerable*   \n\n\tfunction totalChildContracts(uint256 _tokenId) external view returns (uint256);\n获取avatar下面有多少种类的NFT，目前可以知道我们的项目只有clothes，所以返回1  \n_tokenId : avatar id\n\n\tfunction childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\n获取NFT的contract address。目前我们的Bitizen中，仅有clothes，所以结果只有clothes的contract address   \n_tokenId : avatar id  \n_index :  从0开始的下标\n\n\tfunction totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\n获取NTF的数量，即获取clothes的数量  \n_tokenId : avatar id  \n_childContract :  NTF contract address，即clothes的合约地址\n\n\tfunction childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);\n\n根据*totalChildTokens*的返回值，获取具体的每一个NTF id  \n_tokenId : avatar id  \n_childContract :  NTF contract address，即clothes的合约地址  \n_index ： 从0 开始的索引，小于*totalChildTokens*的返回值\n\n\n\tinterface ERC998ERC20TopDownEnumerable {\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);}\n\tinterface ERC20AndERC223 {\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function transfer(address to, uint value) external returns (bool success);\n    function transfer(address to, uint value, bytes data) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);}\n    \nERC20集成到ERC998的interface，可按照ERC721的理解，就不一一讲解了\n\n\tinterface ERC998ERC721BottomUp {\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;}\n\n声明ComposableBottonUp的接口，用于*transferChildToParent*  \n到此为止，ComposableTopDown的对外开放的接口已经分析完毕了。\n##### ERC998实际运用\n[Bitizens](https://www.bitguild.com/presale/bitizens)在这里，你可以找到第一个基于ERC998创建的一款3D游戏，你可以免费创建一个只属于你自己的bitizen.\n##### 结尾\n这篇文章仅仅分析了ERC998的标准接口，当然其中也涉及到ERC721和ERC20的一些知识，希望能够给将要进入dapp的开发者提供一点点帮助。\n  \n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png)   \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/ERC998接口的理解.md","raw":"---\ntitle: 全新的加密NTF表现形式---ERC998\ndate: 2018-09-19 23:05:41\n---\n##### ERC998\n>在开始之前，你可能需要了解一下区块链，比特币，以太坊，ERC20和ERC721的相关知识,因为整篇文章也是在此基础上的一个应用的开始。\n  \nERC998目前状态Draft,创建于2018/7/7\n具体信息可访问[ERC998](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md)。  \n特性：可组合（composable）。ERC20和ERC721仅仅是单一的物品的应用，而ERC998可以组合不同的ERC721和ERC20，使之产生更丰富的应用。可以类比主机（ERC721） +  显示器（ERC20）+ 外设（ERC721）= 电脑（ERC998）；通过这样的组合我们就能够创建出更加复杂，高级的功能。\n##### ERC998的两种实现\nComposableTopDown和ComposableBottonUp，本次结合我实际的应用只讲介绍前者，具体的不同可以参考官网，当然这里有一篇作者更详细的介绍:  \n[Top-Down and Bottom-Up Composables, What’s the Difference and Which One Should You Use?](https://hackernoon.com/top-down-and-bottom-up-composables-whats-the-difference-and-which-one-should-you-use-db939f6acf1d)\n\n\n##### ERC998接口分析\n原作者已经写得非常详细了，具体就不在具体分析了。这里结合avatar（ERC998的实现的虚拟形象）和clothes（ERC721的实现的衣服）简单的看看ComposableTopDown的实现吧。（ComposableBottonUp的原理也类似）  \n\n*interface ERC998ERC721TopDown*\n\n\n\tevent ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId)\n\n当avatar接收到一件clothes会触发的一个事件\n _from : clothes的原始owner address \n _tokenId : 哪一个avatar来穿这件衣服，即avatar id\n _childContract: clothes contract address    \n_childTokenId:  哪一件衣服，即clothes id  \n\n\n\n\tevent TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\n\n当avatar脱下一件clothes时会发出的一个事件  \ntokenId : 将要脱下clothes的avatar id  \n_to : 接收clothes address,在项目中  \n_childContract： clothes 合约地址  \n_childTokenId： clothes id\n\n\n\n\tfunction rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\n\nrootOwner:获得clothes的owner  address，实际上是调用的下面的这个函数\n返回的是加上ERC998的特殊值加上owner的address，可以通过address（_rootOwner）得到owner的address  \n_tokenId  需要查找的avatar id\n\n\tfunction rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\n  \nrootOwner：cloth对应的owner address  \n这里注意一下，此处返回的 root owner有可能是contract address ，也有可能是user address。根据作者的设计总共有四种可能\n_childContract ： clothes contract address\n_childTokenId ： clothes id\n\n\tfunction ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);  \nparentTokenOwner: 返回的是加上ERC998的特殊值加上owner address  \nparentTokenId : avatar id  \n_childContract: clothes contract address   \n_childTokenId： clothes id\n\n\tfunction onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4);\n\nbytes4: 返回的一个bytes4的值 用于更新其他NTF到avatar时的一个回调方法，告诉avatar转入了这个数据，将此数据添加到avatar的数据中.   \n**这里使用NTF代替其他ERC721 token**  \n_operator: 执行这个操作的address\n_from : 原始NTF 拥有者的 address\n_childTokenId： NTF id\n_data : 附加数据\n\n\tfunction transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\n\tfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\n\tfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external\n\n这是三个重载的方法，加上safe是为了确保转入的合约地址有类似于*onERC721Received*的方法进行回调，确保token不会丢失。如果转入的合约地址没有注册次方法，那么将不会转入成功，从而回退转移操作，保证NTF的安全。  \n如果转入的是user address，那么直接调用第一个方法即可。  \n这些方法均会触发TransferChild这个事件  \n_fromTokenId :  avatar id  \n_to ：接受clothes address  \n_childContract : clothes contract address\n_childTokenId ： 将要进行转出的clothes id  \n\n\tfunction transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external;\n\n如果avatar含有ERC998 ComposableTopDown的token,可以通过这个方法进行转移  \n\n\tfunction getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\n用于用户user自己转入clothes到avatar中，注意与*onERC721Received*进行比较。  \n_from : clothes拥有者的address\n_tokenId ：转进给哪一个avatar，即avatar id  \n_childContract :  clothes contract address   \n_childTokenId ： clothes id\n\n*interface ERC998ERC721TopDownEnumerable*   \n\n\tfunction totalChildContracts(uint256 _tokenId) external view returns (uint256);\n获取avatar下面有多少种类的NFT，目前可以知道我们的项目只有clothes，所以返回1  \n_tokenId : avatar id\n\n\tfunction childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\n获取NFT的contract address。目前我们的Bitizen中，仅有clothes，所以结果只有clothes的contract address   \n_tokenId : avatar id  \n_index :  从0开始的下标\n\n\tfunction totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\n获取NTF的数量，即获取clothes的数量  \n_tokenId : avatar id  \n_childContract :  NTF contract address，即clothes的合约地址\n\n\tfunction childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);\n\n根据*totalChildTokens*的返回值，获取具体的每一个NTF id  \n_tokenId : avatar id  \n_childContract :  NTF contract address，即clothes的合约地址  \n_index ： 从0 开始的索引，小于*totalChildTokens*的返回值\n\n\n\tinterface ERC998ERC20TopDownEnumerable {\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);}\n\tinterface ERC20AndERC223 {\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\n    function transfer(address to, uint value) external returns (bool success);\n    function transfer(address to, uint value, bytes data) external returns (bool success);\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);}\n    \nERC20集成到ERC998的interface，可按照ERC721的理解，就不一一讲解了\n\n\tinterface ERC998ERC721BottomUp {\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;}\n\n声明ComposableBottonUp的接口，用于*transferChildToParent*  \n到此为止，ComposableTopDown的对外开放的接口已经分析完毕了。\n##### ERC998实际运用\n[Bitizens](https://www.bitguild.com/presale/bitizens)在这里，你可以找到第一个基于ERC998创建的一款3D游戏，你可以免费创建一个只属于你自己的bitizen.\n##### 结尾\n这篇文章仅仅分析了ERC998的标准接口，当然其中也涉及到ERC721和ERC20的一些知识，希望能够给将要进入dapp的开发者提供一点点帮助。\n  \n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png)   \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"ERC998接口的理解","published":1,"updated":"2019-02-18T13:13:08.305Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b525000dnh7saujl0eqv","content":"<h5 id=\"ERC998\"><a href=\"#ERC998\" class=\"headerlink\" title=\"ERC998\"></a>ERC998</h5><blockquote>\n<p>在开始之前，你可能需要了解一下区块链，比特币，以太坊，ERC20和ERC721的相关知识,因为整篇文章也是在此基础上的一个应用的开始。</p>\n</blockquote>\n<p>ERC998目前状态Draft,创建于2018/7/7<br>具体信息可访问<a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md\" target=\"_blank\" rel=\"noopener\">ERC998</a>。<br>特性：可组合（composable）。ERC20和ERC721仅仅是单一的物品的应用，而ERC998可以组合不同的ERC721和ERC20，使之产生更丰富的应用。可以类比主机（ERC721） +  显示器（ERC20）+ 外设（ERC721）= 电脑（ERC998）；通过这样的组合我们就能够创建出更加复杂，高级的功能。</p>\n<h5 id=\"ERC998的两种实现\"><a href=\"#ERC998的两种实现\" class=\"headerlink\" title=\"ERC998的两种实现\"></a>ERC998的两种实现</h5><p>ComposableTopDown和ComposableBottonUp，本次结合我实际的应用只讲介绍前者，具体的不同可以参考官网，当然这里有一篇作者更详细的介绍:<br><a href=\"https://hackernoon.com/top-down-and-bottom-up-composables-whats-the-difference-and-which-one-should-you-use-db939f6acf1d\" target=\"_blank\" rel=\"noopener\">Top-Down and Bottom-Up Composables, What’s the Difference and Which One Should You Use?</a></p>\n<h5 id=\"ERC998接口分析\"><a href=\"#ERC998接口分析\" class=\"headerlink\" title=\"ERC998接口分析\"></a>ERC998接口分析</h5><p>原作者已经写得非常详细了，具体就不在具体分析了。这里结合avatar（ERC998的实现的虚拟形象）和clothes（ERC721的实现的衣服）简单的看看ComposableTopDown的实现吧。（ComposableBottonUp的原理也类似）  </p>\n<p><em>interface ERC998ERC721TopDown</em></p>\n<pre><code>event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId)\n</code></pre><p>当avatar接收到一件clothes会触发的一个事件<br> _from : clothes的原始owner address<br> _tokenId : 哪一个avatar来穿这件衣服，即avatar id<br> _childContract: clothes contract address<br>_childTokenId:  哪一件衣服，即clothes id  </p>\n<pre><code>event TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\n</code></pre><p>当avatar脱下一件clothes时会发出的一个事件<br>tokenId : 将要脱下clothes的avatar id<br>_to : 接收clothes address,在项目中<br>_childContract： clothes 合约地址<br>_childTokenId： clothes id</p>\n<pre><code>function rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\n</code></pre><p>rootOwner:获得clothes的owner  address，实际上是调用的下面的这个函数<br>返回的是加上ERC998的特殊值加上owner的address，可以通过address（_rootOwner）得到owner的address<br>_tokenId  需要查找的avatar id</p>\n<pre><code>function rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\n</code></pre><p>rootOwner：cloth对应的owner address<br>这里注意一下，此处返回的 root owner有可能是contract address ，也有可能是user address。根据作者的设计总共有四种可能<br>_childContract ： clothes contract address<br>_childTokenId ： clothes id</p>\n<pre><code>function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);  \n</code></pre><p>parentTokenOwner: 返回的是加上ERC998的特殊值加上owner address<br>parentTokenId : avatar id<br>_childContract: clothes contract address<br>_childTokenId： clothes id</p>\n<pre><code>function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4);\n</code></pre><p>bytes4: 返回的一个bytes4的值 用于更新其他NTF到avatar时的一个回调方法，告诉avatar转入了这个数据，将此数据添加到avatar的数据中.<br><strong>这里使用NTF代替其他ERC721 token</strong><br>_operator: 执行这个操作的address<br>_from : 原始NTF 拥有者的 address<br>_childTokenId： NTF id<br>_data : 附加数据</p>\n<pre><code>function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\nfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\nfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external\n</code></pre><p>这是三个重载的方法，加上safe是为了确保转入的合约地址有类似于<em>onERC721Received</em>的方法进行回调，确保token不会丢失。如果转入的合约地址没有注册次方法，那么将不会转入成功，从而回退转移操作，保证NTF的安全。<br>如果转入的是user address，那么直接调用第一个方法即可。<br>这些方法均会触发TransferChild这个事件<br>_fromTokenId :  avatar id<br>_to ：接受clothes address<br>_childContract : clothes contract address<br>_childTokenId ： 将要进行转出的clothes id  </p>\n<pre><code>function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external;\n</code></pre><p>如果avatar含有ERC998 ComposableTopDown的token,可以通过这个方法进行转移  </p>\n<pre><code>function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\n</code></pre><p>用于用户user自己转入clothes到avatar中，注意与<em>onERC721Received</em>进行比较。<br>_from : clothes拥有者的address<br>_tokenId ：转进给哪一个avatar，即avatar id<br>_childContract :  clothes contract address<br>_childTokenId ： clothes id</p>\n<p><em>interface ERC998ERC721TopDownEnumerable</em>   </p>\n<pre><code>function totalChildContracts(uint256 _tokenId) external view returns (uint256);\n</code></pre><p>获取avatar下面有多少种类的NFT，目前可以知道我们的项目只有clothes，所以返回1<br>_tokenId : avatar id</p>\n<pre><code>function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\n</code></pre><p>获取NFT的contract address。目前我们的Bitizen中，仅有clothes，所以结果只有clothes的contract address<br>_tokenId : avatar id<br>_index :  从0开始的下标</p>\n<pre><code>function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\n</code></pre><p>获取NTF的数量，即获取clothes的数量<br>_tokenId : avatar id<br>_childContract :  NTF contract address，即clothes的合约地址</p>\n<pre><code>function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);\n</code></pre><p>根据<em>totalChildTokens</em>的返回值，获取具体的每一个NTF id<br>_tokenId : avatar id<br>_childContract :  NTF contract address，即clothes的合约地址<br>_index ： 从0 开始的索引，小于<em>totalChildTokens</em>的返回值</p>\n<pre><code>interface ERC998ERC20TopDownEnumerable {\nfunction totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\nfunction erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);}\ninterface ERC20AndERC223 {\nfunction transferFrom(address _from, address _to, uint _value) external returns (bool success);\nfunction transfer(address to, uint value) external returns (bool success);\nfunction transfer(address to, uint value, bytes data) external returns (bool success);\nfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);}\n</code></pre><p>ERC20集成到ERC998的interface，可按照ERC721的理解，就不一一讲解了</p>\n<pre><code>interface ERC998ERC721BottomUp {\nfunction transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;}\n</code></pre><p>声明ComposableBottonUp的接口，用于<em>transferChildToParent</em><br>到此为止，ComposableTopDown的对外开放的接口已经分析完毕了。</p>\n<h5 id=\"ERC998实际运用\"><a href=\"#ERC998实际运用\" class=\"headerlink\" title=\"ERC998实际运用\"></a>ERC998实际运用</h5><p><a href=\"https://www.bitguild.com/presale/bitizens\" target=\"_blank\" rel=\"noopener\">Bitizens</a>在这里，你可以找到第一个基于ERC998创建的一款3D游戏，你可以免费创建一个只属于你自己的bitizen.</p>\n<h5 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h5><p>这篇文章仅仅分析了ERC998的标准接口，当然其中也涉及到ERC721和ERC20的一些知识，希望能够给将要进入dapp的开发者提供一点点帮助。</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"><br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#x6b;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#x6b;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"ERC998\"><a href=\"#ERC998\" class=\"headerlink\" title=\"ERC998\"></a>ERC998</h5><blockquote>\n<p>在开始之前，你可能需要了解一下区块链，比特币，以太坊，ERC20和ERC721的相关知识,因为整篇文章也是在此基础上的一个应用的开始。</p>\n</blockquote>\n<p>ERC998目前状态Draft,创建于2018/7/7<br>具体信息可访问<a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-998.md\" target=\"_blank\" rel=\"noopener\">ERC998</a>。<br>特性：可组合（composable）。ERC20和ERC721仅仅是单一的物品的应用，而ERC998可以组合不同的ERC721和ERC20，使之产生更丰富的应用。可以类比主机（ERC721） +  显示器（ERC20）+ 外设（ERC721）= 电脑（ERC998）；通过这样的组合我们就能够创建出更加复杂，高级的功能。</p>\n<h5 id=\"ERC998的两种实现\"><a href=\"#ERC998的两种实现\" class=\"headerlink\" title=\"ERC998的两种实现\"></a>ERC998的两种实现</h5><p>ComposableTopDown和ComposableBottonUp，本次结合我实际的应用只讲介绍前者，具体的不同可以参考官网，当然这里有一篇作者更详细的介绍:<br><a href=\"https://hackernoon.com/top-down-and-bottom-up-composables-whats-the-difference-and-which-one-should-you-use-db939f6acf1d\" target=\"_blank\" rel=\"noopener\">Top-Down and Bottom-Up Composables, What’s the Difference and Which One Should You Use?</a></p>\n<h5 id=\"ERC998接口分析\"><a href=\"#ERC998接口分析\" class=\"headerlink\" title=\"ERC998接口分析\"></a>ERC998接口分析</h5><p>原作者已经写得非常详细了，具体就不在具体分析了。这里结合avatar（ERC998的实现的虚拟形象）和clothes（ERC721的实现的衣服）简单的看看ComposableTopDown的实现吧。（ComposableBottonUp的原理也类似）  </p>\n<p><em>interface ERC998ERC721TopDown</em></p>\n<pre><code>event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId)\n</code></pre><p>当avatar接收到一件clothes会触发的一个事件<br> _from : clothes的原始owner address<br> _tokenId : 哪一个avatar来穿这件衣服，即avatar id<br> _childContract: clothes contract address<br>_childTokenId:  哪一件衣服，即clothes id  </p>\n<pre><code>event TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\n</code></pre><p>当avatar脱下一件clothes时会发出的一个事件<br>tokenId : 将要脱下clothes的avatar id<br>_to : 接收clothes address,在项目中<br>_childContract： clothes 合约地址<br>_childTokenId： clothes id</p>\n<pre><code>function rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\n</code></pre><p>rootOwner:获得clothes的owner  address，实际上是调用的下面的这个函数<br>返回的是加上ERC998的特殊值加上owner的address，可以通过address（_rootOwner）得到owner的address<br>_tokenId  需要查找的avatar id</p>\n<pre><code>function rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\n</code></pre><p>rootOwner：cloth对应的owner address<br>这里注意一下，此处返回的 root owner有可能是contract address ，也有可能是user address。根据作者的设计总共有四种可能<br>_childContract ： clothes contract address<br>_childTokenId ： clothes id</p>\n<pre><code>function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);  \n</code></pre><p>parentTokenOwner: 返回的是加上ERC998的特殊值加上owner address<br>parentTokenId : avatar id<br>_childContract: clothes contract address<br>_childTokenId： clothes id</p>\n<pre><code>function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4);\n</code></pre><p>bytes4: 返回的一个bytes4的值 用于更新其他NTF到avatar时的一个回调方法，告诉avatar转入了这个数据，将此数据添加到avatar的数据中.<br><strong>这里使用NTF代替其他ERC721 token</strong><br>_operator: 执行这个操作的address<br>_from : 原始NTF 拥有者的 address<br>_childTokenId： NTF id<br>_data : 附加数据</p>\n<pre><code>function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\nfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\nfunction safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external\n</code></pre><p>这是三个重载的方法，加上safe是为了确保转入的合约地址有类似于<em>onERC721Received</em>的方法进行回调，确保token不会丢失。如果转入的合约地址没有注册次方法，那么将不会转入成功，从而回退转移操作，保证NTF的安全。<br>如果转入的是user address，那么直接调用第一个方法即可。<br>这些方法均会触发TransferChild这个事件<br>_fromTokenId :  avatar id<br>_to ：接受clothes address<br>_childContract : clothes contract address<br>_childTokenId ： 将要进行转出的clothes id  </p>\n<pre><code>function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external;\n</code></pre><p>如果avatar含有ERC998 ComposableTopDown的token,可以通过这个方法进行转移  </p>\n<pre><code>function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\n</code></pre><p>用于用户user自己转入clothes到avatar中，注意与<em>onERC721Received</em>进行比较。<br>_from : clothes拥有者的address<br>_tokenId ：转进给哪一个avatar，即avatar id<br>_childContract :  clothes contract address<br>_childTokenId ： clothes id</p>\n<p><em>interface ERC998ERC721TopDownEnumerable</em>   </p>\n<pre><code>function totalChildContracts(uint256 _tokenId) external view returns (uint256);\n</code></pre><p>获取avatar下面有多少种类的NFT，目前可以知道我们的项目只有clothes，所以返回1<br>_tokenId : avatar id</p>\n<pre><code>function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\n</code></pre><p>获取NFT的contract address。目前我们的Bitizen中，仅有clothes，所以结果只有clothes的contract address<br>_tokenId : avatar id<br>_index :  从0开始的下标</p>\n<pre><code>function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\n</code></pre><p>获取NTF的数量，即获取clothes的数量<br>_tokenId : avatar id<br>_childContract :  NTF contract address，即clothes的合约地址</p>\n<pre><code>function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);\n</code></pre><p>根据<em>totalChildTokens</em>的返回值，获取具体的每一个NTF id<br>_tokenId : avatar id<br>_childContract :  NTF contract address，即clothes的合约地址<br>_index ： 从0 开始的索引，小于<em>totalChildTokens</em>的返回值</p>\n<pre><code>interface ERC998ERC20TopDownEnumerable {\nfunction totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\nfunction erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);}\ninterface ERC20AndERC223 {\nfunction transferFrom(address _from, address _to, uint _value) external returns (bool success);\nfunction transfer(address to, uint value) external returns (bool success);\nfunction transfer(address to, uint value, bytes data) external returns (bool success);\nfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);}\n</code></pre><p>ERC20集成到ERC998的interface，可按照ERC721的理解，就不一一讲解了</p>\n<pre><code>interface ERC998ERC721BottomUp {\nfunction transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;}\n</code></pre><p>声明ComposableBottonUp的接口，用于<em>transferChildToParent</em><br>到此为止，ComposableTopDown的对外开放的接口已经分析完毕了。</p>\n<h5 id=\"ERC998实际运用\"><a href=\"#ERC998实际运用\" class=\"headerlink\" title=\"ERC998实际运用\"></a>ERC998实际运用</h5><p><a href=\"https://www.bitguild.com/presale/bitizens\" target=\"_blank\" rel=\"noopener\">Bitizens</a>在这里，你可以找到第一个基于ERC998创建的一款3D游戏，你可以免费创建一个只属于你自己的bitizen.</p>\n<h5 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h5><p>这篇文章仅仅分析了ERC998的标准接口，当然其中也涉及到ERC721和ERC20的一些知识，希望能够给将要进入dapp的开发者提供一点点帮助。</p>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"><br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#x6b;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#x6b;&#117;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#117;&#x6e;&#110;&#121;&#64;&#49;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"eos dapp开发学习 第四课","date":"2018-11-02T13:02:05.000Z","_content":"#### 前言\n>官方又发布新版本了，目前写的合约也部署不上了，新版本的语法变了确实蛮多的，目前仅按照官网的教程把流程过一遍了\n> 很幸运，目前的官方的游戏第一次和第二次已经被我玩了，这里也把第二次的游戏流程分享给大家，对于接下来编写代码心里有点底，因为本课主要是智能合约的编写。  \n> Elemental Battles是一款单人纸牌游戏，其中包括元素之间的战斗。对手将通过在EOSIO上运行的智能合约来代表。  \n![eos](/img_eos1/eos_react5.gif)\n\n#### 学习目标\n>在本课中，我们将准备我们的游戏。我们还将在智能合约中构建startgame和playcard动作，并从前端触发。在本课程结束时，您将能够开始玩元素战斗并迈出第一步！  \n\n#### 合约编写\n> 这里我暂时无法部署上去，只能先把代码放在这里了。看了上面的游戏玩法，各位同学结合注释应该看得明白了。\n> 玩家和ai进行卡片游戏对战，都从各自的待选17张牌中选出四张，每张牌有不同的攻击力。根据攻击力进行判断一次对决的胜负，各有5条命，输一次减少一条命，谁先到达0谁就输了。游戏简单，主要是了解一下智能合约的开发流程   \n> 这里并没有成功布置到链上，以后补上了 \n[第四课源码](https://github.com/shaokun11/eoslearning/tree/eos-dev4)\n\n`cardgame.hpp`\n\n\t#include <eosiolib/eosio.hpp>\n\tusing namespace std;\n\tclass cardgame : public eosio::contract {\n\t// 继承contract\n\t  public:\n\t    //构造方法,并实例化了multi_index表users\n\t    cardgame( account_name self):contract(self),\n\t                                _users(self,self),\n\t                                _seed(self,self){};\n\t\n\t    // table和action 必须加上@abi 的注解，这样才能生存对应的abi，\n\t    // 在eosio.cdt中，使用 [[eosio::action]] 更加简洁 \n\t    [[eosio::action]]\n\t    void login(account_name user);\n\t\n\t    // 开始游戏，分发手里牌\n\t    [[eosio::action]]\n\t    void startgame(account_name user);\n\t\n\t    //从手上牌选择卡片进行对战\n\t    [[eosio::action]]\n\t    void playcard(account_name user,uint8_t player_card_index);\n\t\n\t  private:\n\t    enum game_status:int8_t\n\t    {\n\t      ONGOING = 0,      // 游戏正在进行中\n\t      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n\t      PLAYER_LOST = -1 // 游戏结束， 完结失败\n\t    };\n\t    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n\t    {\n\t      EMPTY = 0,    // 不存在的卡片\n\t      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n\t      VOID = 5      // 平局属性       共计力为0 总共1张\n\t    };\n\t    struct card\n\t    {\n\t      uint8_t type;   // 卡片类型\n\t      uint8_t attack_point; // 卡片的攻击力\n\t    };\n\t    typedef uint8_t card_id;\n\t    const map<card_id,card> card_dict = {\n\t        {0 , {EMPTY , 0}},\n\t        {1 , {EMPTY , 1}},\n\t        {2 , {EMPTY , 1}},\n\t        {3 , {EMPTY , 2}},\n\t        {4 , {EMPTY , 2}},\n\t        {5 , {EMPTY , 3}},\n\t        {6 , {EMPTY , 1}},\n\t        {7 , {EMPTY , 1}},\n\t        {8 , {EMPTY , 2}},\n\t        {9 , {EMPTY , 2}},\n\t        {10 , {EMPTY , 3}},\n\t        {11 , {EMPTY , 1}},\n\t        {12 , {EMPTY , 1}},\n\t        {13 , {EMPTY , 2}},\n\t        {14 , {EMPTY , 2}},\n\t        {15 , {EMPTY , 3}},\n\t        {16 , {EMPTY , 3}},\n\t        {17 , {EMPTY , 0}},\n\t    };\n\t    struct game\n\t    {\n\t     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n\t     int8_t life_player = 5;    // 游戏玩家 5条生命\n\t     int8_t ai_player = 5;      // 游戏玩家 5条生命\n\t     vector<card_id>  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n\t     vector<card_id> deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n\t     vector<card_id> hand_player = {0,0,0,0}; // 玩家的手里牌\n\t     vector<card_id> hand_ai = {0,0,0,0};     // ai的手里牌\n\t     card_id selected_card_player = 0;          // 从待选牌中选中的牌\n\t     card_id selected_card_ai = 0;              // 从待选牌中选中的牌\n\t    };\n\t\n\t  \t[[eosio::table]]\n\t  \tstruct userinfo\n\t  \t{\n\t  \t\taccount_name name;\t\t\t//玩家的名字    account_name 是uint64_t的一个别名\n\t  \t\tuint16_t win_count = 0;\t\t\n\t  \t\tuint16_t lost_count = 0;\n\t      game game_data;         // game \n\t\n\t  \t\tauto primary_key() const {return name;}  \n\t  \t\t//多索引表查找名为primary_key（）的getter函数。这必须使用结构中的第一个字段，编译器将使用它来添加主键。让我们定义这个功能。\n\t  \t};\n\t    [[eosio::table]]\n\t    struct seed // 这个是用来生成随机数的，全局储存，只要有人玩就会改变，没办法，eos里只能用table来持久化数据在链上\n\t    {\n\t      uint64_t key = 1;\n\t      uint32_t value = 1;\n\t\n\t      auto primary_key(){return key;};\n\t    }\n\t\n\t  \ttypedef eosio::multi_index<N(userinfo),userinfo> user_index;\n\t  \t//多索引表定义，它有两个参数： 表名 \n\t  \t//\t\t\t\t\t\t 结构定义了我们打算在多索引表中存储的数据。 \n\t  \t// 新类型名称作为我们的多索引表定义的别名\n\t  \t// \n\t  \t// 多索引表中的数据由四条信息标识： code（account_name） \n\t  \t// \t\t\t\t\t\t\t scop \n\t  \t// \t\t\t\t\t\t\t table name\n\t  \t// \t\t\t\t\t\t\t primary key \n\t    typedef multi_index<N(seed),seed> seed_index;\n\t    user_index _users; //声明表的实例\n\t    seed_index _seed;\n\t\n\t    int random(const int range);\n\t    void draw_one_card(vector<uint8_t>& deck,vector<uint8_t>& hand);\n\t};\t\n\n\n\n`cardgame.cpp` \n \n\t#include \"cardgame.hpp\"\n\tvoid cardgame::login(account_name user)\n\t{\n\t\trequire_auth(user); \n\t\t//确保这个用户已经被授权\n\t\t// 这里我理解了很久，把我的想法记录在这里\n\t\t// 这里是调用此合约的account name，即提供私钥的account，这里传入的这个account必须拥有它的active权限，\n\t\t// 当然，这里还可以要求有其他的权限，这样就可以给特殊的账号特殊的权限\n\t\tauto user_iterator = _users.find(user);  // 查找\n\t\tif (user_iterator == _users.end()) {\n\t\t\tuser_iterator = _users.emplace(user, [&](auto& new_user){\n\t\t\t\tnew_user.name = user;\n\t\t\t});\n\t\t}\n\t\t// 这里使用multi_index的find 和 emplace(插入)两种方法，\n\t\t// 这些方法的形式都是一样的，记住就好，可以去官网查看详细的方法说明\n\t}\n\t\n\tvoid cardgame::startgame(account_name name) {\n\t\trequire_auth(name);\n\t\tauto& info = _users.get(name, \"user not exist\");\n\t\t_users.modify(info,name,[&](auto& _to_modify_user){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_one_card(game_data.deck_player,game_data.hand_player);\n\t\t\t\tdraw_one_card(game_data.deck_ai,game_data.hand_ai);\n\t\t\t}\n\t\t\t_to_modify_user.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::playcard(account_name user,uint8_t player_card_index){\n\t\trequire_auth(user);\n\t\teosio.assert(player_card_index < 4,\"invalid hand index\"); // 手上牌最多四张\n\t\t// 通过user找到数据表中数据\n\t\tauto& player = _users.get(user,\"User not exist\");\n\t\teosio_assert(player.game_data.status == ONGONING,\"game have ended\"); // 确保本轮游戏没有结束\n\t\teosio_assert(player.game_data.selected_card_player == 0,\"the player have selected car in this turn\"); // 确保手上没有选牌\n\t\t// 修改数据表\n\t\t_users.modify(player,user,[&](auto& _to_modify_user){\n\t\t\tgame& game_data = _to_modify_user.game_data;\n\t\t\t// 设定选中的卡片id\n\t\t\tgame_data.selected_card_player = game_data.hand_player[player_card_index];\n\t\t\t// 将手中卡片对应位置置位empty\n\t\t\tgame_data.hand_player[player_card_index] = 0;\n\t\t});\n\t}\n\tEOSIO_ABI(cardgame,(login)(playcard))\n\n`gameplay.cpp`\n\n\t#include \"cardgame.hpp\"\n\tint cardgame::random(const int range) {\n\t\tauto seed_itr = _seed.begin();\n\t\tif (seed_itr  == _seed.end())\n\t\t{\t// 如果没有随机数据，就用默认值初始化\n\t\t\tseed_itr = _seed.emplace(_self,[&](auto& seed){})\n\t\t};\n\t\tint prime = 65535;\n\t\t// 新值得范围 0 ~ 65535\n\t\tauto new_seed_value = (seed_itr.value + now()) % prime;\n\t\t_seed.modify(seed_itr,_self,[&](auto& s){\n\t\t\t\ts.value = new_seed_value;\n\t\t});\n\t\t// 随机范围  0 ~ range\n\t\tint random_res = new_seed_value % range;\n\t\treturn random_res;\n\t}\n\t// 根据待选卡片和手上已有的卡片，随机进行选择新的卡片\n\tvoid cardgame::draw_one_card(vector<uint8_t> &deck,vector<uint8_t> &hand){\n\t\t// 0 ~ 16\n\t \tint deck_card_index = random(deck.size());\n\t \tint first_emprty_slot = -1;\n\t \tfor (int i = 0; i < hand.size; ++i)\n\t \t{\t\n\t \t\tauto id = hand[i];\n\t \t\tif (card_dict.at(id).type == EMPTY){\n\t \t\t\tfirst_emprty_slot = i;\n\t \t\t\tbreak;\n\t \t\t}\n\t \t}\n\t \teosio_assert(first_emprty_slot !=- 1, \"No empty slot in the players hand\");\n\t \t// 如果手上的牌 有空位，进行随机赋值\n\t \thand[first_emprty_slot] = deck[deck_card_index];\n\t \t// 待选牌中移除掉已经被赋值给手上的牌\n\t \tdeck.erase(deck.began() + deck_card_index);\n\t }\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos dapp开发 官方教程学习5.md","raw":"---\ntitle: eos dapp开发学习 第四课\ndate: 2018-11-02 21:02:05\n---\n#### 前言\n>官方又发布新版本了，目前写的合约也部署不上了，新版本的语法变了确实蛮多的，目前仅按照官网的教程把流程过一遍了\n> 很幸运，目前的官方的游戏第一次和第二次已经被我玩了，这里也把第二次的游戏流程分享给大家，对于接下来编写代码心里有点底，因为本课主要是智能合约的编写。  \n> Elemental Battles是一款单人纸牌游戏，其中包括元素之间的战斗。对手将通过在EOSIO上运行的智能合约来代表。  \n![eos](/img_eos1/eos_react5.gif)\n\n#### 学习目标\n>在本课中，我们将准备我们的游戏。我们还将在智能合约中构建startgame和playcard动作，并从前端触发。在本课程结束时，您将能够开始玩元素战斗并迈出第一步！  \n\n#### 合约编写\n> 这里我暂时无法部署上去，只能先把代码放在这里了。看了上面的游戏玩法，各位同学结合注释应该看得明白了。\n> 玩家和ai进行卡片游戏对战，都从各自的待选17张牌中选出四张，每张牌有不同的攻击力。根据攻击力进行判断一次对决的胜负，各有5条命，输一次减少一条命，谁先到达0谁就输了。游戏简单，主要是了解一下智能合约的开发流程   \n> 这里并没有成功布置到链上，以后补上了 \n[第四课源码](https://github.com/shaokun11/eoslearning/tree/eos-dev4)\n\n`cardgame.hpp`\n\n\t#include <eosiolib/eosio.hpp>\n\tusing namespace std;\n\tclass cardgame : public eosio::contract {\n\t// 继承contract\n\t  public:\n\t    //构造方法,并实例化了multi_index表users\n\t    cardgame( account_name self):contract(self),\n\t                                _users(self,self),\n\t                                _seed(self,self){};\n\t\n\t    // table和action 必须加上@abi 的注解，这样才能生存对应的abi，\n\t    // 在eosio.cdt中，使用 [[eosio::action]] 更加简洁 \n\t    [[eosio::action]]\n\t    void login(account_name user);\n\t\n\t    // 开始游戏，分发手里牌\n\t    [[eosio::action]]\n\t    void startgame(account_name user);\n\t\n\t    //从手上牌选择卡片进行对战\n\t    [[eosio::action]]\n\t    void playcard(account_name user,uint8_t player_card_index);\n\t\n\t  private:\n\t    enum game_status:int8_t\n\t    {\n\t      ONGOING = 0,      // 游戏正在进行中\n\t      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n\t      PLAYER_LOST = -1 // 游戏结束， 完结失败\n\t    };\n\t    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n\t    {\n\t      EMPTY = 0,    // 不存在的卡片\n\t      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n\t      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n\t      VOID = 5      // 平局属性       共计力为0 总共1张\n\t    };\n\t    struct card\n\t    {\n\t      uint8_t type;   // 卡片类型\n\t      uint8_t attack_point; // 卡片的攻击力\n\t    };\n\t    typedef uint8_t card_id;\n\t    const map<card_id,card> card_dict = {\n\t        {0 , {EMPTY , 0}},\n\t        {1 , {EMPTY , 1}},\n\t        {2 , {EMPTY , 1}},\n\t        {3 , {EMPTY , 2}},\n\t        {4 , {EMPTY , 2}},\n\t        {5 , {EMPTY , 3}},\n\t        {6 , {EMPTY , 1}},\n\t        {7 , {EMPTY , 1}},\n\t        {8 , {EMPTY , 2}},\n\t        {9 , {EMPTY , 2}},\n\t        {10 , {EMPTY , 3}},\n\t        {11 , {EMPTY , 1}},\n\t        {12 , {EMPTY , 1}},\n\t        {13 , {EMPTY , 2}},\n\t        {14 , {EMPTY , 2}},\n\t        {15 , {EMPTY , 3}},\n\t        {16 , {EMPTY , 3}},\n\t        {17 , {EMPTY , 0}},\n\t    };\n\t    struct game\n\t    {\n\t     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n\t     int8_t life_player = 5;    // 游戏玩家 5条生命\n\t     int8_t ai_player = 5;      // 游戏玩家 5条生命\n\t     vector<card_id>  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n\t     vector<card_id> deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n\t     vector<card_id> hand_player = {0,0,0,0}; // 玩家的手里牌\n\t     vector<card_id> hand_ai = {0,0,0,0};     // ai的手里牌\n\t     card_id selected_card_player = 0;          // 从待选牌中选中的牌\n\t     card_id selected_card_ai = 0;              // 从待选牌中选中的牌\n\t    };\n\t\n\t  \t[[eosio::table]]\n\t  \tstruct userinfo\n\t  \t{\n\t  \t\taccount_name name;\t\t\t//玩家的名字    account_name 是uint64_t的一个别名\n\t  \t\tuint16_t win_count = 0;\t\t\n\t  \t\tuint16_t lost_count = 0;\n\t      game game_data;         // game \n\t\n\t  \t\tauto primary_key() const {return name;}  \n\t  \t\t//多索引表查找名为primary_key（）的getter函数。这必须使用结构中的第一个字段，编译器将使用它来添加主键。让我们定义这个功能。\n\t  \t};\n\t    [[eosio::table]]\n\t    struct seed // 这个是用来生成随机数的，全局储存，只要有人玩就会改变，没办法，eos里只能用table来持久化数据在链上\n\t    {\n\t      uint64_t key = 1;\n\t      uint32_t value = 1;\n\t\n\t      auto primary_key(){return key;};\n\t    }\n\t\n\t  \ttypedef eosio::multi_index<N(userinfo),userinfo> user_index;\n\t  \t//多索引表定义，它有两个参数： 表名 \n\t  \t//\t\t\t\t\t\t 结构定义了我们打算在多索引表中存储的数据。 \n\t  \t// 新类型名称作为我们的多索引表定义的别名\n\t  \t// \n\t  \t// 多索引表中的数据由四条信息标识： code（account_name） \n\t  \t// \t\t\t\t\t\t\t scop \n\t  \t// \t\t\t\t\t\t\t table name\n\t  \t// \t\t\t\t\t\t\t primary key \n\t    typedef multi_index<N(seed),seed> seed_index;\n\t    user_index _users; //声明表的实例\n\t    seed_index _seed;\n\t\n\t    int random(const int range);\n\t    void draw_one_card(vector<uint8_t>& deck,vector<uint8_t>& hand);\n\t};\t\n\n\n\n`cardgame.cpp` \n \n\t#include \"cardgame.hpp\"\n\tvoid cardgame::login(account_name user)\n\t{\n\t\trequire_auth(user); \n\t\t//确保这个用户已经被授权\n\t\t// 这里我理解了很久，把我的想法记录在这里\n\t\t// 这里是调用此合约的account name，即提供私钥的account，这里传入的这个account必须拥有它的active权限，\n\t\t// 当然，这里还可以要求有其他的权限，这样就可以给特殊的账号特殊的权限\n\t\tauto user_iterator = _users.find(user);  // 查找\n\t\tif (user_iterator == _users.end()) {\n\t\t\tuser_iterator = _users.emplace(user, [&](auto& new_user){\n\t\t\t\tnew_user.name = user;\n\t\t\t});\n\t\t}\n\t\t// 这里使用multi_index的find 和 emplace(插入)两种方法，\n\t\t// 这些方法的形式都是一样的，记住就好，可以去官网查看详细的方法说明\n\t}\n\t\n\tvoid cardgame::startgame(account_name name) {\n\t\trequire_auth(name);\n\t\tauto& info = _users.get(name, \"user not exist\");\n\t\t_users.modify(info,name,[&](auto& _to_modify_user){\n\t\t\tgame game_data;\n\t\t\tfor(uint8_t i = 0; i < 4; i++){\n\t\t\t\tdraw_one_card(game_data.deck_player,game_data.hand_player);\n\t\t\t\tdraw_one_card(game_data.deck_ai,game_data.hand_ai);\n\t\t\t}\n\t\t\t_to_modify_user.game_data = game_data;\n\t\t});\n\t}\n\t\n\tvoid cardgame::playcard(account_name user,uint8_t player_card_index){\n\t\trequire_auth(user);\n\t\teosio.assert(player_card_index < 4,\"invalid hand index\"); // 手上牌最多四张\n\t\t// 通过user找到数据表中数据\n\t\tauto& player = _users.get(user,\"User not exist\");\n\t\teosio_assert(player.game_data.status == ONGONING,\"game have ended\"); // 确保本轮游戏没有结束\n\t\teosio_assert(player.game_data.selected_card_player == 0,\"the player have selected car in this turn\"); // 确保手上没有选牌\n\t\t// 修改数据表\n\t\t_users.modify(player,user,[&](auto& _to_modify_user){\n\t\t\tgame& game_data = _to_modify_user.game_data;\n\t\t\t// 设定选中的卡片id\n\t\t\tgame_data.selected_card_player = game_data.hand_player[player_card_index];\n\t\t\t// 将手中卡片对应位置置位empty\n\t\t\tgame_data.hand_player[player_card_index] = 0;\n\t\t});\n\t}\n\tEOSIO_ABI(cardgame,(login)(playcard))\n\n`gameplay.cpp`\n\n\t#include \"cardgame.hpp\"\n\tint cardgame::random(const int range) {\n\t\tauto seed_itr = _seed.begin();\n\t\tif (seed_itr  == _seed.end())\n\t\t{\t// 如果没有随机数据，就用默认值初始化\n\t\t\tseed_itr = _seed.emplace(_self,[&](auto& seed){})\n\t\t};\n\t\tint prime = 65535;\n\t\t// 新值得范围 0 ~ 65535\n\t\tauto new_seed_value = (seed_itr.value + now()) % prime;\n\t\t_seed.modify(seed_itr,_self,[&](auto& s){\n\t\t\t\ts.value = new_seed_value;\n\t\t});\n\t\t// 随机范围  0 ~ range\n\t\tint random_res = new_seed_value % range;\n\t\treturn random_res;\n\t}\n\t// 根据待选卡片和手上已有的卡片，随机进行选择新的卡片\n\tvoid cardgame::draw_one_card(vector<uint8_t> &deck,vector<uint8_t> &hand){\n\t\t// 0 ~ 16\n\t \tint deck_card_index = random(deck.size());\n\t \tint first_emprty_slot = -1;\n\t \tfor (int i = 0; i < hand.size; ++i)\n\t \t{\t\n\t \t\tauto id = hand[i];\n\t \t\tif (card_dict.at(id).type == EMPTY){\n\t \t\t\tfirst_emprty_slot = i;\n\t \t\t\tbreak;\n\t \t\t}\n\t \t}\n\t \teosio_assert(first_emprty_slot !=- 1, \"No empty slot in the players hand\");\n\t \t// 如果手上的牌 有空位，进行随机赋值\n\t \thand[first_emprty_slot] = deck[deck_card_index];\n\t \t// 待选牌中移除掉已经被赋值给手上的牌\n\t \tdeck.erase(deck.began() + deck_card_index);\n\t }\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos dapp开发 官方教程学习5","published":1,"updated":"2019-02-18T13:13:08.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b527000enh7si8krc81r","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>官方又发布新版本了，目前写的合约也部署不上了，新版本的语法变了确实蛮多的，目前仅按照官网的教程把流程过一遍了<br>很幸运，目前的官方的游戏第一次和第二次已经被我玩了，这里也把第二次的游戏流程分享给大家，对于接下来编写代码心里有点底，因为本课主要是智能合约的编写。<br>Elemental Battles是一款单人纸牌游戏，其中包括元素之间的战斗。对手将通过在EOSIO上运行的智能合约来代表。<br><img src=\"/img_eos1/eos_react5.gif\" alt=\"eos\"></p>\n</blockquote>\n<h4 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h4><blockquote>\n<p>在本课中，我们将准备我们的游戏。我们还将在智能合约中构建startgame和playcard动作，并从前端触发。在本课程结束时，您将能够开始玩元素战斗并迈出第一步！  </p>\n</blockquote>\n<h4 id=\"合约编写\"><a href=\"#合约编写\" class=\"headerlink\" title=\"合约编写\"></a>合约编写</h4><blockquote>\n<p>这里我暂时无法部署上去，只能先把代码放在这里了。看了上面的游戏玩法，各位同学结合注释应该看得明白了。<br>玩家和ai进行卡片游戏对战，都从各自的待选17张牌中选出四张，每张牌有不同的攻击力。根据攻击力进行判断一次对决的胜负，各有5条命，输一次减少一条命，谁先到达0谁就输了。游戏简单，主要是了解一下智能合约的开发流程<br>这里并没有成功布置到链上，以后补上了<br><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev4\" target=\"_blank\" rel=\"noopener\">第四课源码</a></p>\n</blockquote>\n<p><code>cardgame.hpp</code></p>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\nusing namespace std;\nclass cardgame : public eosio::contract {\n// 继承contract\n  public:\n    //构造方法,并实例化了multi_index表users\n    cardgame( account_name self):contract(self),\n                                _users(self,self),\n                                _seed(self,self){};\n\n    // table和action 必须加上@abi 的注解，这样才能生存对应的abi，\n    // 在eosio.cdt中，使用 [[eosio::action]] 更加简洁 \n    [[eosio::action]]\n    void login(account_name user);\n\n    // 开始游戏，分发手里牌\n    [[eosio::action]]\n    void startgame(account_name user);\n\n    //从手上牌选择卡片进行对战\n    [[eosio::action]]\n    void playcard(account_name user,uint8_t player_card_index);\n\n  private:\n    enum game_status:int8_t\n    {\n      ONGOING = 0,      // 游戏正在进行中\n      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n      PLAYER_LOST = -1 // 游戏结束， 完结失败\n    };\n    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n    {\n      EMPTY = 0,    // 不存在的卡片\n      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n      VOID = 5      // 平局属性       共计力为0 总共1张\n    };\n    struct card\n    {\n      uint8_t type;   // 卡片类型\n      uint8_t attack_point; // 卡片的攻击力\n    };\n    typedef uint8_t card_id;\n    const map&lt;card_id,card&gt; card_dict = {\n        {0 , {EMPTY , 0}},\n        {1 , {EMPTY , 1}},\n        {2 , {EMPTY , 1}},\n        {3 , {EMPTY , 2}},\n        {4 , {EMPTY , 2}},\n        {5 , {EMPTY , 3}},\n        {6 , {EMPTY , 1}},\n        {7 , {EMPTY , 1}},\n        {8 , {EMPTY , 2}},\n        {9 , {EMPTY , 2}},\n        {10 , {EMPTY , 3}},\n        {11 , {EMPTY , 1}},\n        {12 , {EMPTY , 1}},\n        {13 , {EMPTY , 2}},\n        {14 , {EMPTY , 2}},\n        {15 , {EMPTY , 3}},\n        {16 , {EMPTY , 3}},\n        {17 , {EMPTY , 0}},\n    };\n    struct game\n    {\n     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n     int8_t life_player = 5;    // 游戏玩家 5条生命\n     int8_t ai_player = 5;      // 游戏玩家 5条生命\n     vector&lt;card_id&gt;  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n     vector&lt;card_id&gt; deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n     vector&lt;card_id&gt; hand_player = {0,0,0,0}; // 玩家的手里牌\n     vector&lt;card_id&gt; hand_ai = {0,0,0,0};     // ai的手里牌\n     card_id selected_card_player = 0;          // 从待选牌中选中的牌\n     card_id selected_card_ai = 0;              // 从待选牌中选中的牌\n    };\n\n      [[eosio::table]]\n      struct userinfo\n      {\n          account_name name;            //玩家的名字    account_name 是uint64_t的一个别名\n          uint16_t win_count = 0;        \n          uint16_t lost_count = 0;\n      game game_data;         // game \n\n          auto primary_key() const {return name;}  \n          //多索引表查找名为primary_key（）的getter函数。这必须使用结构中的第一个字段，编译器将使用它来添加主键。让我们定义这个功能。\n      };\n    [[eosio::table]]\n    struct seed // 这个是用来生成随机数的，全局储存，只要有人玩就会改变，没办法，eos里只能用table来持久化数据在链上\n    {\n      uint64_t key = 1;\n      uint32_t value = 1;\n\n      auto primary_key(){return key;};\n    }\n\n      typedef eosio::multi_index&lt;N(userinfo),userinfo&gt; user_index;\n      //多索引表定义，它有两个参数： 表名 \n      //                         结构定义了我们打算在多索引表中存储的数据。 \n      // 新类型名称作为我们的多索引表定义的别名\n      // \n      // 多索引表中的数据由四条信息标识： code（account_name） \n      //                              scop \n      //                              table name\n      //                              primary key \n    typedef multi_index&lt;N(seed),seed&gt; seed_index;\n    user_index _users; //声明表的实例\n    seed_index _seed;\n\n    int random(const int range);\n    void draw_one_card(vector&lt;uint8_t&gt;&amp; deck,vector&lt;uint8_t&gt;&amp; hand);\n};    \n</code></pre><p><code>cardgame.cpp</code> </p>\n<pre><code>#include &quot;cardgame.hpp&quot;\nvoid cardgame::login(account_name user)\n{\n    require_auth(user); \n    //确保这个用户已经被授权\n    // 这里我理解了很久，把我的想法记录在这里\n    // 这里是调用此合约的account name，即提供私钥的account，这里传入的这个account必须拥有它的active权限，\n    // 当然，这里还可以要求有其他的权限，这样就可以给特殊的账号特殊的权限\n    auto user_iterator = _users.find(user);  // 查找\n    if (user_iterator == _users.end()) {\n        user_iterator = _users.emplace(user, [&amp;](auto&amp; new_user){\n            new_user.name = user;\n        });\n    }\n    // 这里使用multi_index的find 和 emplace(插入)两种方法，\n    // 这些方法的形式都是一样的，记住就好，可以去官网查看详细的方法说明\n}\n\nvoid cardgame::startgame(account_name name) {\n    require_auth(name);\n    auto&amp; info = _users.get(name, &quot;user not exist&quot;);\n    _users.modify(info,name,[&amp;](auto&amp; _to_modify_user){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_one_card(game_data.deck_player,game_data.hand_player);\n            draw_one_card(game_data.deck_ai,game_data.hand_ai);\n        }\n        _to_modify_user.game_data = game_data;\n    });\n}\n\nvoid cardgame::playcard(account_name user,uint8_t player_card_index){\n    require_auth(user);\n    eosio.assert(player_card_index &lt; 4,&quot;invalid hand index&quot;); // 手上牌最多四张\n    // 通过user找到数据表中数据\n    auto&amp; player = _users.get(user,&quot;User not exist&quot;);\n    eosio_assert(player.game_data.status == ONGONING,&quot;game have ended&quot;); // 确保本轮游戏没有结束\n    eosio_assert(player.game_data.selected_card_player == 0,&quot;the player have selected car in this turn&quot;); // 确保手上没有选牌\n    // 修改数据表\n    _users.modify(player,user,[&amp;](auto&amp; _to_modify_user){\n        game&amp; game_data = _to_modify_user.game_data;\n        // 设定选中的卡片id\n        game_data.selected_card_player = game_data.hand_player[player_card_index];\n        // 将手中卡片对应位置置位empty\n        game_data.hand_player[player_card_index] = 0;\n    });\n}\nEOSIO_ABI(cardgame,(login)(playcard))\n</code></pre><p><code>gameplay.cpp</code></p>\n<pre><code>#include &quot;cardgame.hpp&quot;\nint cardgame::random(const int range) {\n    auto seed_itr = _seed.begin();\n    if (seed_itr  == _seed.end())\n    {    // 如果没有随机数据，就用默认值初始化\n        seed_itr = _seed.emplace(_self,[&amp;](auto&amp; seed){})\n    };\n    int prime = 65535;\n    // 新值得范围 0 ~ 65535\n    auto new_seed_value = (seed_itr.value + now()) % prime;\n    _seed.modify(seed_itr,_self,[&amp;](auto&amp; s){\n            s.value = new_seed_value;\n    });\n    // 随机范围  0 ~ range\n    int random_res = new_seed_value % range;\n    return random_res;\n}\n// 根据待选卡片和手上已有的卡片，随机进行选择新的卡片\nvoid cardgame::draw_one_card(vector&lt;uint8_t&gt; &amp;deck,vector&lt;uint8_t&gt; &amp;hand){\n    // 0 ~ 16\n     int deck_card_index = random(deck.size());\n     int first_emprty_slot = -1;\n     for (int i = 0; i &lt; hand.size; ++i)\n     {    \n         auto id = hand[i];\n         if (card_dict.at(id).type == EMPTY){\n             first_emprty_slot = i;\n             break;\n         }\n     }\n     eosio_assert(first_emprty_slot !=- 1, &quot;No empty slot in the players hand&quot;);\n     // 如果手上的牌 有空位，进行随机赋值\n     hand[first_emprty_slot] = deck[deck_card_index];\n     // 待选牌中移除掉已经被赋值给手上的牌\n     deck.erase(deck.began() + deck_card_index);\n }\n</code></pre><h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#110;&#x6e;&#x79;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#110;&#x6e;&#x79;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>官方又发布新版本了，目前写的合约也部署不上了，新版本的语法变了确实蛮多的，目前仅按照官网的教程把流程过一遍了<br>很幸运，目前的官方的游戏第一次和第二次已经被我玩了，这里也把第二次的游戏流程分享给大家，对于接下来编写代码心里有点底，因为本课主要是智能合约的编写。<br>Elemental Battles是一款单人纸牌游戏，其中包括元素之间的战斗。对手将通过在EOSIO上运行的智能合约来代表。<br><img src=\"/img_eos1/eos_react5.gif\" alt=\"eos\"></p>\n</blockquote>\n<h4 id=\"学习目标\"><a href=\"#学习目标\" class=\"headerlink\" title=\"学习目标\"></a>学习目标</h4><blockquote>\n<p>在本课中，我们将准备我们的游戏。我们还将在智能合约中构建startgame和playcard动作，并从前端触发。在本课程结束时，您将能够开始玩元素战斗并迈出第一步！  </p>\n</blockquote>\n<h4 id=\"合约编写\"><a href=\"#合约编写\" class=\"headerlink\" title=\"合约编写\"></a>合约编写</h4><blockquote>\n<p>这里我暂时无法部署上去，只能先把代码放在这里了。看了上面的游戏玩法，各位同学结合注释应该看得明白了。<br>玩家和ai进行卡片游戏对战，都从各自的待选17张牌中选出四张，每张牌有不同的攻击力。根据攻击力进行判断一次对决的胜负，各有5条命，输一次减少一条命，谁先到达0谁就输了。游戏简单，主要是了解一下智能合约的开发流程<br>这里并没有成功布置到链上，以后补上了<br><a href=\"https://github.com/shaokun11/eoslearning/tree/eos-dev4\" target=\"_blank\" rel=\"noopener\">第四课源码</a></p>\n</blockquote>\n<p><code>cardgame.hpp</code></p>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\nusing namespace std;\nclass cardgame : public eosio::contract {\n// 继承contract\n  public:\n    //构造方法,并实例化了multi_index表users\n    cardgame( account_name self):contract(self),\n                                _users(self,self),\n                                _seed(self,self){};\n\n    // table和action 必须加上@abi 的注解，这样才能生存对应的abi，\n    // 在eosio.cdt中，使用 [[eosio::action]] 更加简洁 \n    [[eosio::action]]\n    void login(account_name user);\n\n    // 开始游戏，分发手里牌\n    [[eosio::action]]\n    void startgame(account_name user);\n\n    //从手上牌选择卡片进行对战\n    [[eosio::action]]\n    void playcard(account_name user,uint8_t player_card_index);\n\n  private:\n    enum game_status:int8_t\n    {\n      ONGOING = 0,      // 游戏正在进行中\n      PLAYER_WON = 1,   // 游戏已经结束，玩家获得胜利\n      PLAYER_LOST = -1 // 游戏结束， 完结失败\n    };\n    enum card_type : uint8_t  // 卡片的类型 总共五种属性类型,总共17张卡牌\n    {\n      EMPTY = 0,    // 不存在的卡片\n      FIRE = 1,     // 火属性， 克木  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WOOD = 2,     // 木属性， 克水  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      WATER = 3,    // 水属性   克火  攻击力为 1 和 2 的各两张  攻击力为3的一张    总共5张\n      NEUTRAL = 4,  // 中立属性       攻击力为3 总共1张 \n      VOID = 5      // 平局属性       共计力为0 总共1张\n    };\n    struct card\n    {\n      uint8_t type;   // 卡片类型\n      uint8_t attack_point; // 卡片的攻击力\n    };\n    typedef uint8_t card_id;\n    const map&lt;card_id,card&gt; card_dict = {\n        {0 , {EMPTY , 0}},\n        {1 , {EMPTY , 1}},\n        {2 , {EMPTY , 1}},\n        {3 , {EMPTY , 2}},\n        {4 , {EMPTY , 2}},\n        {5 , {EMPTY , 3}},\n        {6 , {EMPTY , 1}},\n        {7 , {EMPTY , 1}},\n        {8 , {EMPTY , 2}},\n        {9 , {EMPTY , 2}},\n        {10 , {EMPTY , 3}},\n        {11 , {EMPTY , 1}},\n        {12 , {EMPTY , 1}},\n        {13 , {EMPTY , 2}},\n        {14 , {EMPTY , 2}},\n        {15 , {EMPTY , 3}},\n        {16 , {EMPTY , 3}},\n        {17 , {EMPTY , 0}},\n    };\n    struct game\n    {\n     int8_t status = ONGOING;   // 只要登录 默认游戏正在进行\n     int8_t life_player = 5;    // 游戏玩家 5条生命\n     int8_t ai_player = 5;      // 游戏玩家 5条生命\n     vector&lt;card_id&gt;  deck_player = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17}; // 玩家待选的卡牌id\n     vector&lt;card_id&gt; deck_ai = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17};     // ai待选的卡牌id\n     vector&lt;card_id&gt; hand_player = {0,0,0,0}; // 玩家的手里牌\n     vector&lt;card_id&gt; hand_ai = {0,0,0,0};     // ai的手里牌\n     card_id selected_card_player = 0;          // 从待选牌中选中的牌\n     card_id selected_card_ai = 0;              // 从待选牌中选中的牌\n    };\n\n      [[eosio::table]]\n      struct userinfo\n      {\n          account_name name;            //玩家的名字    account_name 是uint64_t的一个别名\n          uint16_t win_count = 0;        \n          uint16_t lost_count = 0;\n      game game_data;         // game \n\n          auto primary_key() const {return name;}  \n          //多索引表查找名为primary_key（）的getter函数。这必须使用结构中的第一个字段，编译器将使用它来添加主键。让我们定义这个功能。\n      };\n    [[eosio::table]]\n    struct seed // 这个是用来生成随机数的，全局储存，只要有人玩就会改变，没办法，eos里只能用table来持久化数据在链上\n    {\n      uint64_t key = 1;\n      uint32_t value = 1;\n\n      auto primary_key(){return key;};\n    }\n\n      typedef eosio::multi_index&lt;N(userinfo),userinfo&gt; user_index;\n      //多索引表定义，它有两个参数： 表名 \n      //                         结构定义了我们打算在多索引表中存储的数据。 \n      // 新类型名称作为我们的多索引表定义的别名\n      // \n      // 多索引表中的数据由四条信息标识： code（account_name） \n      //                              scop \n      //                              table name\n      //                              primary key \n    typedef multi_index&lt;N(seed),seed&gt; seed_index;\n    user_index _users; //声明表的实例\n    seed_index _seed;\n\n    int random(const int range);\n    void draw_one_card(vector&lt;uint8_t&gt;&amp; deck,vector&lt;uint8_t&gt;&amp; hand);\n};    \n</code></pre><p><code>cardgame.cpp</code> </p>\n<pre><code>#include &quot;cardgame.hpp&quot;\nvoid cardgame::login(account_name user)\n{\n    require_auth(user); \n    //确保这个用户已经被授权\n    // 这里我理解了很久，把我的想法记录在这里\n    // 这里是调用此合约的account name，即提供私钥的account，这里传入的这个account必须拥有它的active权限，\n    // 当然，这里还可以要求有其他的权限，这样就可以给特殊的账号特殊的权限\n    auto user_iterator = _users.find(user);  // 查找\n    if (user_iterator == _users.end()) {\n        user_iterator = _users.emplace(user, [&amp;](auto&amp; new_user){\n            new_user.name = user;\n        });\n    }\n    // 这里使用multi_index的find 和 emplace(插入)两种方法，\n    // 这些方法的形式都是一样的，记住就好，可以去官网查看详细的方法说明\n}\n\nvoid cardgame::startgame(account_name name) {\n    require_auth(name);\n    auto&amp; info = _users.get(name, &quot;user not exist&quot;);\n    _users.modify(info,name,[&amp;](auto&amp; _to_modify_user){\n        game game_data;\n        for(uint8_t i = 0; i &lt; 4; i++){\n            draw_one_card(game_data.deck_player,game_data.hand_player);\n            draw_one_card(game_data.deck_ai,game_data.hand_ai);\n        }\n        _to_modify_user.game_data = game_data;\n    });\n}\n\nvoid cardgame::playcard(account_name user,uint8_t player_card_index){\n    require_auth(user);\n    eosio.assert(player_card_index &lt; 4,&quot;invalid hand index&quot;); // 手上牌最多四张\n    // 通过user找到数据表中数据\n    auto&amp; player = _users.get(user,&quot;User not exist&quot;);\n    eosio_assert(player.game_data.status == ONGONING,&quot;game have ended&quot;); // 确保本轮游戏没有结束\n    eosio_assert(player.game_data.selected_card_player == 0,&quot;the player have selected car in this turn&quot;); // 确保手上没有选牌\n    // 修改数据表\n    _users.modify(player,user,[&amp;](auto&amp; _to_modify_user){\n        game&amp; game_data = _to_modify_user.game_data;\n        // 设定选中的卡片id\n        game_data.selected_card_player = game_data.hand_player[player_card_index];\n        // 将手中卡片对应位置置位empty\n        game_data.hand_player[player_card_index] = 0;\n    });\n}\nEOSIO_ABI(cardgame,(login)(playcard))\n</code></pre><p><code>gameplay.cpp</code></p>\n<pre><code>#include &quot;cardgame.hpp&quot;\nint cardgame::random(const int range) {\n    auto seed_itr = _seed.begin();\n    if (seed_itr  == _seed.end())\n    {    // 如果没有随机数据，就用默认值初始化\n        seed_itr = _seed.emplace(_self,[&amp;](auto&amp; seed){})\n    };\n    int prime = 65535;\n    // 新值得范围 0 ~ 65535\n    auto new_seed_value = (seed_itr.value + now()) % prime;\n    _seed.modify(seed_itr,_self,[&amp;](auto&amp; s){\n            s.value = new_seed_value;\n    });\n    // 随机范围  0 ~ range\n    int random_res = new_seed_value % range;\n    return random_res;\n}\n// 根据待选卡片和手上已有的卡片，随机进行选择新的卡片\nvoid cardgame::draw_one_card(vector&lt;uint8_t&gt; &amp;deck,vector&lt;uint8_t&gt; &amp;hand){\n    // 0 ~ 16\n     int deck_card_index = random(deck.size());\n     int first_emprty_slot = -1;\n     for (int i = 0; i &lt; hand.size; ++i)\n     {    \n         auto id = hand[i];\n         if (card_dict.at(id).type == EMPTY){\n             first_emprty_slot = i;\n             break;\n         }\n     }\n     eosio_assert(first_emprty_slot !=- 1, &quot;No empty slot in the players hand&quot;);\n     // 如果手上的牌 有空位，进行随机赋值\n     hand[first_emprty_slot] = deck[deck_card_index];\n     // 待选牌中移除掉已经被赋值给手上的牌\n     deck.erase(deck.began() + deck_card_index);\n }\n</code></pre><h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#111;&#107;&#x75;&#x6e;&#x69;&#x6e;&#103;&#64;&#x67;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#110;&#x6e;&#x79;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#110;&#x6e;&#x79;&#x40;&#x31;&#54;&#x33;&#46;&#99;&#111;&#x6d;</a></p>\n"},{"title":"简单例子带你彻底的理解eos中的权限在dapp中如何使用","date":"2018-11-17T13:15:01.000Z","_content":"#### 前言\n> 相信各位同学看eos白皮书的权限看得很是头疼,而我能搜索到的例子基本上是官方的那个权限图再结合eos.token进行转账的权限介绍.如果不细心跟着走一遍,你是绝对不好理解这个权限怎么用的.由于我头脑比较笨,着实按照大佬的文章走了三四遍才大约摸索清楚,这里给自己做一个备忘录吧  \n> 而我站在大佬的肩膀上,结合实际的操作给大家聊聊这个权限如何使用吧.  \n> 这里主要参考的  \n> \n>  *  [EOS 权限管理之-权限的使用 (你绝对找不到的干货)](https://eosfans.io/topics/653)  \n> * [EOS开发系列目录](https://bihu.com/article/293974) 松果的文章都是根据源码分析的,建议开发dapp的同学都认真读几遍吧,这样更能帮助理解eos到底是怎样运行的\n\n\n#### 准备工作\n* 提前在测试网上申请两个账号,并领取测试币(不知道怎么做的可以翻看我前面的文章),我这里申请了两个.  \n\n* 这次使用cleos操作,就不使用scatter操作了.原理一样.所以得把申请的这两个账号的私钥导入到cleos创建的钱包里面  \n\n\t\tshaokun11121\n\t\tPrivate key: 5KFoeWx69fjPj7mTDbcD9JauYd9LLjikYTa9Qg7N5CVZTqZrzNG\n\t\tPublic key: EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t\t\t\n\t\tshaokun11122\n\t\tPrivate key: 5HrJQ9eepF6FuG47eSJprxoFQ6PWRkombbWEwxoSQr6FJ1wQPbg\n\t\tPublic key: EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\n\n\n#### 以太坊权限的实现\n> 这里先给贴一段简单的以太坊的权限的管理吧,这个要自己来写,如果你有以太坊的经验,相信更加容易理解.\n> 理一理:\n> \n> 1. 部署合约,部署完成后,owner就是部署者的地址\n> 2. 查看count的值,此时count为初始值1\n> 3. 执行add方法\n> 4. 查看count的值,此时count的值为2\n> 5. 切换address\n> 6. 执行add方法,报错,因为不是owner\n> 7. 查看count的值 还是为2\n> 8. 再次执行3,4步骤,此时count的值的值为3\n\n ![eos](/eospermission/per1.gif)\n\n\tpragma solidity ^0.4.24;\n\t\n\tcontract Ownable {\n\t  address public owner;\n\t\n\t  constructor() public {\n\t    owner = msg.sender;\n\t  }\n\t\n\t  modifier onlyOwner() {\n\t    require(msg.sender == owner);\n\t    _;\n\t  }\n\t}\n\tcontract leranper is Ownable {\n\t    \n\t    uint256 public count = 1;\n\t    \n\t    function add() external onlyOwner  {\n\t       count += 1;\n\t    }\n\t}\n\t\n#### eos的权限的实现\n\n> eos的权限不需要写到合约中,底层已经帮我们实现了,我们只需要进行相应的设置即可,以下是设置权限的签名.至于设置的各个参数怎么设置,怎么用,可以看看官方文档吧\n\n\tUsage: cleos set account permission [OPTIONS] account permission authority [parent]\n\t\n\tPositionals:\n\t  account TEXT                The account to set/delete a permission authority for (required)\n\t  permission TEXT             The permission name to set/delete an authority for (required)\n\t  authority TEXT              [delete] NULL, [create/update] public key, JSON string, or filename defining the authority (required)\n\t  parent TEXT                 [create] The permission name of this parents permission (Defaults to: \"Active\")\n\t  \n方法1:使用account设置  \n\n\tcleos set account permission shaokun11121 add '{\"threshold\":1,\"keys\":[],\"accounts\":[{\"permission\":{\"actor\":\"shaokun11122\",\"permission\":\"active\"},\"weight\":1}]}'\n\n方法二:使用public key进行设置\n\n\tcleos set account permission shaokun11121 add '{\"threshold\":1,\"keys\":[{\"permission\":{\"key\":\"EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\",\"permission\":\"active\"},\"weight\":1}]}'  \n\n当然你可以把两种设置方式都用上,根据个人习惯设定就好,\n  \n>这里建议后面的permission这段,先使用ide写上正确的json格式.然后在[json格式压缩](http://www.bejson.com/)进行压缩成一行,这样可以避免不必要的麻烦\n\n\t\n\t    {\n\t    \"threshold\": 1,\n\t    \"keys\": [],\n\t    \"accounts\": [\n\t        {\n\t            \"permission\": {\n\t                \"actor\": \"kun2\",\n\t                \"permission\": \"active\"\n\t            },\n\t            \"weight\": 1\n\t        }\n\t    ]\n\t}\n\n#### eos的权限的解读\n* 当按照上述方式设置好后,可以通过此命令查看设置的权限,注意看这里permissions里多了一个add权限 这个权限的名字是 add,阀值是1 权限值 是1 ,父权限是active. \n* 这样设置后,也就是说 只要是active shaokun11121的active的权限能够执行的操作,使用shaokun11122的密钥生成的账户的active权限均能做\n* 一个私钥与一个公钥是一一对应,而这一对钥匙可以作为一个或者多个account中的权限级别\n* 当然你也可以按照上述的方式多设置几个权限看看,它的形式就像Windows的目录展示的形式,很好辨认的\n\n\t\tcleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n\t\n查看的结果  \n\n\tbogon:libraries shaokun$ cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n\tcreated: 2018-11-17T12:46:30.000\n\tpermissions: \n\t     owner     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t        active     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t           add     1:    1 shaokun11122@active\n\tmemory: \n\t     quota:     260.1 KiB    used:     95.82 KiB  \n\t\n\tnet bandwidth: \n\t     staked:        100.0000 EOS           (total stake delegated from account to self)\n\t     delegated:       0.0000 EOS           (total staked delegated to account from others)\n\t     used:             5.534 KiB  \n\t     available:        18.23 MiB  \n\t     limit:            18.24 MiB  \n\t\n\tcpu bandwidth:\n\t     staked:        100.0000 EOS           (total stake delegated from account to self)\n\t     delegated:       0.0000 EOS           (total staked delegated to account from others)\n\t     used:             9.367 ms   \n\t     available:        3.629 sec  \n\t     limit:            3.639 sec  \n\t\n\tEOS balances: \n\t     liquid:           80.1129 EOS\n\t     staked:          200.0000 EOS\n\t     unstaking:         0.0000 EOS\n\t     total:           280.1129 EOS\n\t\n\tproducers:     <not voted>\n\n#### eos权限的使用\n> 上述方法给shaokun11121设置了一个add的权限,得添加到具体的action上才能体现出这个价值.目前能够搜到的文章都是加载 transfer这个操作上面的.为什么呢? 因为有了这个权,就可以不用登陆shaokun11121转账了,直接使用shaokun11122转账了.\n\n* 权限签名 \n\n\t\tPositionals:\n\t\t  account TEXT                The account to set/delete a permission authority for (required)\n\t\t  code TEXT                   The account that owns the code for the action (required)\n\t\t  type TEXT                   the type of the action (required)\n\t\t  requirement TEXT            [delete] NULL, [set/update] The permission name require for executing the given action (required)\n\t\t  \n* 给shaokun11121 add action和add 权限关联起来,这样只要是shaokun111121的合约中有add action,那么使用shaokun11122的add权限均可以调用.根据我的测试,一个account目前只能部署一个智能合约,所以这个add方法是唯一的\n \n\t\tcleos -u http://jungle.cryptolions.io:18888  set action permission shaokun11121 shaokun11121 add add\n\n#### eos权限合约的编写\n> 合约编写很简单,就是helloworld,注意其中的权限验证那一行,也就是说,只有自己的account 才能添加或者更新自己的这条信息\n\n\t#include <eosiolib/eosio.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] learnper2 : public contract {\n\t  public:\n\t    using contract::contract;\n\t    learnper2(eosio::name reciever,eosio::name code,eosio::datastream<const char*> ds )\n\t                              :contract(reciever,code,ds),\n\t                              _students(reciever,code.value){};\n\t\n\t    [[eosio::action]]\n\t    void add(name user, const std::string msg) {\n\t      require_auth(user); // 权限额验证 \n\t      auto itr = _students.find(user.value);\n\t      if (itr == _students.end()){\n\t        _students.emplace(get_self(),[&](auto& row){\n\t          row.user = user;\n\t          row.msg = msg;\n\t        });\n\t      } else {\n\t        _students.modify(itr, get_self(), [&](auto& row){\n\t          row.msg = msg;\n\t        });\n\t      }\n\t    };\n\t\n\t\n\t  private:\n\t  struct [[eosio::table]] student \n\t  {\n\t    name user;\n\t    std::string msg = \"hello world\";\n\t    uint64_t primary_key() const {return user.value;};\n\t\n\t  };\n\t  typedef eosio::multi_index<\"student\"_n, student> student_index;\n\t  student_index _students; \n\t};\n\tEOSIO_DISPATCH( learnper2, (add))\n\n#### eos权限合约的编译,部署\n* 编译:这里有个小插曲,放合约cpp文件的文件夹貌似必须命名和主合约的文件名一致,生成的abi里面没有内容,这着实也困扰了我一会\n\n\teosio-cpp -abigen learnper2.cpp learnper2.wasm\n* 这里部署合约一般需要购买ram  \n\t\n\t\tcleos -u http://jungle.cryptolions.io:18888  system buyram shaokun11121 shaokun11121 -k 256\n\n* 部署:  \n\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11121 ./learnper2/ -p shaokun11121@active\n\n#### eos权限合约结果展示\n![eos](/eospermission/per2.gif)\n> 这里说一下我的操作流程\n\n* 调用合约的add action 插入一条信息(我这里之前插入信息,故此步未进行演示)  \n* 首先查看了 shaokun11121的 account信息,可以看到添加了一条add的permission\n* 再次查看了 shaokun11122的account信息,正常状态,只要你新建一个account都是这样的\n* 查看了钱包里面的信息,这里显示的是shaokun11122的公钥(大家可以仔细对比一下)\n* 查看链上table的数据\n* 修改数据,我们仔细来分析这条命令  \n>1. 这里使用的传入的user是shaokun11121\n>2. 传入的permission是 shaokun111121的add这个permission,各位同学可以回想一下之前的合约,调用都是是用的active\n>3. 钱包中并没有shaokun11121的私钥\n>4. 钱包中占有shaokun11122的私钥  \n\n* 再次展示数据,数据修改成功  \n\n\t\tcleos -u http://jungle.cryptolions.io:18888  push action shaokun11121 add '{\"user\":\"shaokun11121\",\"msg\":\"i am shaokun\"}' -p shaokun11121@add\n\t\t\n#### eos权限使用心得\n> * 这里只是展示的单个权限的使用在dapp中怎么使用   \n> * 如果只看白皮书还是很难理解的,建议通过实际的操作,加深理解吧  \n\n#### eos权限的进一步思考\n> * 以太坊和eos的多重权限的签名目前我还没遇到过在dapp中实际使用的例子,官方的例子就是基本上是转账需要多个人同意,那么在dapp中如何使用呢?\n> * 本课程只展示了阀值为1,权限值为1的active权限,那么如果按照官方例子,如果阈值为2,同时需要两个权限值都为1的账号的active权限来进行某个action的执行呢? \n> * 接上一条,如果需要的不是active权限,比如本课中的add权限呢?\n\n[本课源码](https://github.com/shaokun11/eos-permission)\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos 权限的理解.md","raw":"---\ntitle: 简单例子带你彻底的理解eos中的权限在dapp中如何使用 \ndate: 2018-11-17 21:15:01\n---\n#### 前言\n> 相信各位同学看eos白皮书的权限看得很是头疼,而我能搜索到的例子基本上是官方的那个权限图再结合eos.token进行转账的权限介绍.如果不细心跟着走一遍,你是绝对不好理解这个权限怎么用的.由于我头脑比较笨,着实按照大佬的文章走了三四遍才大约摸索清楚,这里给自己做一个备忘录吧  \n> 而我站在大佬的肩膀上,结合实际的操作给大家聊聊这个权限如何使用吧.  \n> 这里主要参考的  \n> \n>  *  [EOS 权限管理之-权限的使用 (你绝对找不到的干货)](https://eosfans.io/topics/653)  \n> * [EOS开发系列目录](https://bihu.com/article/293974) 松果的文章都是根据源码分析的,建议开发dapp的同学都认真读几遍吧,这样更能帮助理解eos到底是怎样运行的\n\n\n#### 准备工作\n* 提前在测试网上申请两个账号,并领取测试币(不知道怎么做的可以翻看我前面的文章),我这里申请了两个.  \n\n* 这次使用cleos操作,就不使用scatter操作了.原理一样.所以得把申请的这两个账号的私钥导入到cleos创建的钱包里面  \n\n\t\tshaokun11121\n\t\tPrivate key: 5KFoeWx69fjPj7mTDbcD9JauYd9LLjikYTa9Qg7N5CVZTqZrzNG\n\t\tPublic key: EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t\t\t\n\t\tshaokun11122\n\t\tPrivate key: 5HrJQ9eepF6FuG47eSJprxoFQ6PWRkombbWEwxoSQr6FJ1wQPbg\n\t\tPublic key: EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\n\n\n#### 以太坊权限的实现\n> 这里先给贴一段简单的以太坊的权限的管理吧,这个要自己来写,如果你有以太坊的经验,相信更加容易理解.\n> 理一理:\n> \n> 1. 部署合约,部署完成后,owner就是部署者的地址\n> 2. 查看count的值,此时count为初始值1\n> 3. 执行add方法\n> 4. 查看count的值,此时count的值为2\n> 5. 切换address\n> 6. 执行add方法,报错,因为不是owner\n> 7. 查看count的值 还是为2\n> 8. 再次执行3,4步骤,此时count的值的值为3\n\n ![eos](/eospermission/per1.gif)\n\n\tpragma solidity ^0.4.24;\n\t\n\tcontract Ownable {\n\t  address public owner;\n\t\n\t  constructor() public {\n\t    owner = msg.sender;\n\t  }\n\t\n\t  modifier onlyOwner() {\n\t    require(msg.sender == owner);\n\t    _;\n\t  }\n\t}\n\tcontract leranper is Ownable {\n\t    \n\t    uint256 public count = 1;\n\t    \n\t    function add() external onlyOwner  {\n\t       count += 1;\n\t    }\n\t}\n\t\n#### eos的权限的实现\n\n> eos的权限不需要写到合约中,底层已经帮我们实现了,我们只需要进行相应的设置即可,以下是设置权限的签名.至于设置的各个参数怎么设置,怎么用,可以看看官方文档吧\n\n\tUsage: cleos set account permission [OPTIONS] account permission authority [parent]\n\t\n\tPositionals:\n\t  account TEXT                The account to set/delete a permission authority for (required)\n\t  permission TEXT             The permission name to set/delete an authority for (required)\n\t  authority TEXT              [delete] NULL, [create/update] public key, JSON string, or filename defining the authority (required)\n\t  parent TEXT                 [create] The permission name of this parents permission (Defaults to: \"Active\")\n\t  \n方法1:使用account设置  \n\n\tcleos set account permission shaokun11121 add '{\"threshold\":1,\"keys\":[],\"accounts\":[{\"permission\":{\"actor\":\"shaokun11122\",\"permission\":\"active\"},\"weight\":1}]}'\n\n方法二:使用public key进行设置\n\n\tcleos set account permission shaokun11121 add '{\"threshold\":1,\"keys\":[{\"permission\":{\"key\":\"EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\",\"permission\":\"active\"},\"weight\":1}]}'  \n\n当然你可以把两种设置方式都用上,根据个人习惯设定就好,\n  \n>这里建议后面的permission这段,先使用ide写上正确的json格式.然后在[json格式压缩](http://www.bejson.com/)进行压缩成一行,这样可以避免不必要的麻烦\n\n\t\n\t    {\n\t    \"threshold\": 1,\n\t    \"keys\": [],\n\t    \"accounts\": [\n\t        {\n\t            \"permission\": {\n\t                \"actor\": \"kun2\",\n\t                \"permission\": \"active\"\n\t            },\n\t            \"weight\": 1\n\t        }\n\t    ]\n\t}\n\n#### eos的权限的解读\n* 当按照上述方式设置好后,可以通过此命令查看设置的权限,注意看这里permissions里多了一个add权限 这个权限的名字是 add,阀值是1 权限值 是1 ,父权限是active. \n* 这样设置后,也就是说 只要是active shaokun11121的active的权限能够执行的操作,使用shaokun11122的密钥生成的账户的active权限均能做\n* 一个私钥与一个公钥是一一对应,而这一对钥匙可以作为一个或者多个account中的权限级别\n* 当然你也可以按照上述的方式多设置几个权限看看,它的形式就像Windows的目录展示的形式,很好辨认的\n\n\t\tcleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n\t\n查看的结果  \n\n\tbogon:libraries shaokun$ cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n\tcreated: 2018-11-17T12:46:30.000\n\tpermissions: \n\t     owner     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t        active     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\t           add     1:    1 shaokun11122@active\n\tmemory: \n\t     quota:     260.1 KiB    used:     95.82 KiB  \n\t\n\tnet bandwidth: \n\t     staked:        100.0000 EOS           (total stake delegated from account to self)\n\t     delegated:       0.0000 EOS           (total staked delegated to account from others)\n\t     used:             5.534 KiB  \n\t     available:        18.23 MiB  \n\t     limit:            18.24 MiB  \n\t\n\tcpu bandwidth:\n\t     staked:        100.0000 EOS           (total stake delegated from account to self)\n\t     delegated:       0.0000 EOS           (total staked delegated to account from others)\n\t     used:             9.367 ms   \n\t     available:        3.629 sec  \n\t     limit:            3.639 sec  \n\t\n\tEOS balances: \n\t     liquid:           80.1129 EOS\n\t     staked:          200.0000 EOS\n\t     unstaking:         0.0000 EOS\n\t     total:           280.1129 EOS\n\t\n\tproducers:     <not voted>\n\n#### eos权限的使用\n> 上述方法给shaokun11121设置了一个add的权限,得添加到具体的action上才能体现出这个价值.目前能够搜到的文章都是加载 transfer这个操作上面的.为什么呢? 因为有了这个权,就可以不用登陆shaokun11121转账了,直接使用shaokun11122转账了.\n\n* 权限签名 \n\n\t\tPositionals:\n\t\t  account TEXT                The account to set/delete a permission authority for (required)\n\t\t  code TEXT                   The account that owns the code for the action (required)\n\t\t  type TEXT                   the type of the action (required)\n\t\t  requirement TEXT            [delete] NULL, [set/update] The permission name require for executing the given action (required)\n\t\t  \n* 给shaokun11121 add action和add 权限关联起来,这样只要是shaokun111121的合约中有add action,那么使用shaokun11122的add权限均可以调用.根据我的测试,一个account目前只能部署一个智能合约,所以这个add方法是唯一的\n \n\t\tcleos -u http://jungle.cryptolions.io:18888  set action permission shaokun11121 shaokun11121 add add\n\n#### eos权限合约的编写\n> 合约编写很简单,就是helloworld,注意其中的权限验证那一行,也就是说,只有自己的account 才能添加或者更新自己的这条信息\n\n\t#include <eosiolib/eosio.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] learnper2 : public contract {\n\t  public:\n\t    using contract::contract;\n\t    learnper2(eosio::name reciever,eosio::name code,eosio::datastream<const char*> ds )\n\t                              :contract(reciever,code,ds),\n\t                              _students(reciever,code.value){};\n\t\n\t    [[eosio::action]]\n\t    void add(name user, const std::string msg) {\n\t      require_auth(user); // 权限额验证 \n\t      auto itr = _students.find(user.value);\n\t      if (itr == _students.end()){\n\t        _students.emplace(get_self(),[&](auto& row){\n\t          row.user = user;\n\t          row.msg = msg;\n\t        });\n\t      } else {\n\t        _students.modify(itr, get_self(), [&](auto& row){\n\t          row.msg = msg;\n\t        });\n\t      }\n\t    };\n\t\n\t\n\t  private:\n\t  struct [[eosio::table]] student \n\t  {\n\t    name user;\n\t    std::string msg = \"hello world\";\n\t    uint64_t primary_key() const {return user.value;};\n\t\n\t  };\n\t  typedef eosio::multi_index<\"student\"_n, student> student_index;\n\t  student_index _students; \n\t};\n\tEOSIO_DISPATCH( learnper2, (add))\n\n#### eos权限合约的编译,部署\n* 编译:这里有个小插曲,放合约cpp文件的文件夹貌似必须命名和主合约的文件名一致,生成的abi里面没有内容,这着实也困扰了我一会\n\n\teosio-cpp -abigen learnper2.cpp learnper2.wasm\n* 这里部署合约一般需要购买ram  \n\t\n\t\tcleos -u http://jungle.cryptolions.io:18888  system buyram shaokun11121 shaokun11121 -k 256\n\n* 部署:  \n\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11121 ./learnper2/ -p shaokun11121@active\n\n#### eos权限合约结果展示\n![eos](/eospermission/per2.gif)\n> 这里说一下我的操作流程\n\n* 调用合约的add action 插入一条信息(我这里之前插入信息,故此步未进行演示)  \n* 首先查看了 shaokun11121的 account信息,可以看到添加了一条add的permission\n* 再次查看了 shaokun11122的account信息,正常状态,只要你新建一个account都是这样的\n* 查看了钱包里面的信息,这里显示的是shaokun11122的公钥(大家可以仔细对比一下)\n* 查看链上table的数据\n* 修改数据,我们仔细来分析这条命令  \n>1. 这里使用的传入的user是shaokun11121\n>2. 传入的permission是 shaokun111121的add这个permission,各位同学可以回想一下之前的合约,调用都是是用的active\n>3. 钱包中并没有shaokun11121的私钥\n>4. 钱包中占有shaokun11122的私钥  \n\n* 再次展示数据,数据修改成功  \n\n\t\tcleos -u http://jungle.cryptolions.io:18888  push action shaokun11121 add '{\"user\":\"shaokun11121\",\"msg\":\"i am shaokun\"}' -p shaokun11121@add\n\t\t\n#### eos权限使用心得\n> * 这里只是展示的单个权限的使用在dapp中怎么使用   \n> * 如果只看白皮书还是很难理解的,建议通过实际的操作,加深理解吧  \n\n#### eos权限的进一步思考\n> * 以太坊和eos的多重权限的签名目前我还没遇到过在dapp中实际使用的例子,官方的例子就是基本上是转账需要多个人同意,那么在dapp中如何使用呢?\n> * 本课程只展示了阀值为1,权限值为1的active权限,那么如果按照官方例子,如果阈值为2,同时需要两个权限值都为1的账号的active权限来进行某个action的执行呢? \n> * 接上一条,如果需要的不是active权限,比如本课中的add权限呢?\n\n[本课源码](https://github.com/shaokun11/eos-permission)\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos 权限的理解","published":1,"updated":"2019-02-18T13:13:08.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52q000fnh7slrexr3kw","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>相信各位同学看eos白皮书的权限看得很是头疼,而我能搜索到的例子基本上是官方的那个权限图再结合eos.token进行转账的权限介绍.如果不细心跟着走一遍,你是绝对不好理解这个权限怎么用的.由于我头脑比较笨,着实按照大佬的文章走了三四遍才大约摸索清楚,这里给自己做一个备忘录吧<br>而我站在大佬的肩膀上,结合实际的操作给大家聊聊这个权限如何使用吧.<br>这里主要参考的  </p>\n<ul>\n<li><a href=\"https://eosfans.io/topics/653\" target=\"_blank\" rel=\"noopener\">EOS 权限管理之-权限的使用 (你绝对找不到的干货)</a>  <ul>\n<li><a href=\"https://bihu.com/article/293974\" target=\"_blank\" rel=\"noopener\">EOS开发系列目录</a> 松果的文章都是根据源码分析的,建议开发dapp的同学都认真读几遍吧,这样更能帮助理解eos到底是怎样运行的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><ul>\n<li><p>提前在测试网上申请两个账号,并领取测试币(不知道怎么做的可以翻看我前面的文章),我这里申请了两个.  </p>\n</li>\n<li><p>这次使用cleos操作,就不使用scatter操作了.原理一样.所以得把申请的这两个账号的私钥导入到cleos创建的钱包里面  </p>\n<pre><code>shaokun11121\nPrivate key: 5KFoeWx69fjPj7mTDbcD9JauYd9LLjikYTa9Qg7N5CVZTqZrzNG\nPublic key: EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\nshaokun11122\nPrivate key: 5HrJQ9eepF6FuG47eSJprxoFQ6PWRkombbWEwxoSQr6FJ1wQPbg\nPublic key: EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\n</code></pre></li>\n</ul>\n<h4 id=\"以太坊权限的实现\"><a href=\"#以太坊权限的实现\" class=\"headerlink\" title=\"以太坊权限的实现\"></a>以太坊权限的实现</h4><blockquote>\n<p>这里先给贴一段简单的以太坊的权限的管理吧,这个要自己来写,如果你有以太坊的经验,相信更加容易理解.<br>理一理:</p>\n<ol>\n<li>部署合约,部署完成后,owner就是部署者的地址</li>\n<li>查看count的值,此时count为初始值1</li>\n<li>执行add方法</li>\n<li>查看count的值,此时count的值为2</li>\n<li>切换address</li>\n<li>执行add方法,报错,因为不是owner</li>\n<li>查看count的值 还是为2</li>\n<li>再次执行3,4步骤,此时count的值的值为3</li>\n</ol>\n</blockquote>\n<p> <img src=\"/eospermission/per1.gif\" alt=\"eos\"></p>\n<pre><code>pragma solidity ^0.4.24;\n\ncontract Ownable {\n  address public owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n}\ncontract leranper is Ownable {\n\n    uint256 public count = 1;\n\n    function add() external onlyOwner  {\n       count += 1;\n    }\n}\n</code></pre><h4 id=\"eos的权限的实现\"><a href=\"#eos的权限的实现\" class=\"headerlink\" title=\"eos的权限的实现\"></a>eos的权限的实现</h4><blockquote>\n<p>eos的权限不需要写到合约中,底层已经帮我们实现了,我们只需要进行相应的设置即可,以下是设置权限的签名.至于设置的各个参数怎么设置,怎么用,可以看看官方文档吧</p>\n</blockquote>\n<pre><code>Usage: cleos set account permission [OPTIONS] account permission authority [parent]\n\nPositionals:\n  account TEXT                The account to set/delete a permission authority for (required)\n  permission TEXT             The permission name to set/delete an authority for (required)\n  authority TEXT              [delete] NULL, [create/update] public key, JSON string, or filename defining the authority (required)\n  parent TEXT                 [create] The permission name of this parents permission (Defaults to: &quot;Active&quot;)\n</code></pre><p>方法1:使用account设置  </p>\n<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11122&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;\n</code></pre><p>方法二:使用public key进行设置</p>\n<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;permission&quot;:{&quot;key&quot;:&quot;EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;  \n</code></pre><p>当然你可以把两种设置方式都用上,根据个人习惯设定就好,</p>\n<blockquote>\n<p>这里建议后面的permission这段,先使用ide写上正确的json格式.然后在<a href=\"http://www.bejson.com/\" target=\"_blank\" rel=\"noopener\">json格式压缩</a>进行压缩成一行,这样可以避免不必要的麻烦</p>\n</blockquote>\n<pre><code>    {\n    &quot;threshold&quot;: 1,\n    &quot;keys&quot;: [],\n    &quot;accounts&quot;: [\n        {\n            &quot;permission&quot;: {\n                &quot;actor&quot;: &quot;kun2&quot;,\n                &quot;permission&quot;: &quot;active&quot;\n            },\n            &quot;weight&quot;: 1\n        }\n    ]\n}\n</code></pre><h4 id=\"eos的权限的解读\"><a href=\"#eos的权限的解读\" class=\"headerlink\" title=\"eos的权限的解读\"></a>eos的权限的解读</h4><ul>\n<li>当按照上述方式设置好后,可以通过此命令查看设置的权限,注意看这里permissions里多了一个add权限 这个权限的名字是 add,阀值是1 权限值 是1 ,父权限是active. </li>\n<li>这样设置后,也就是说 只要是active shaokun11121的active的权限能够执行的操作,使用shaokun11122的密钥生成的账户的active权限均能做</li>\n<li>一个私钥与一个公钥是一一对应,而这一对钥匙可以作为一个或者多个account中的权限级别</li>\n<li><p>当然你也可以按照上述的方式多设置几个权限看看,它的形式就像Windows的目录展示的形式,很好辨认的</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n</code></pre></li>\n</ul>\n<p>查看的结果  </p>\n<pre><code>bogon:libraries shaokun$ cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\ncreated: 2018-11-17T12:46:30.000\npermissions: \n     owner     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n        active     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n           add     1:    1 shaokun11122@active\nmemory: \n     quota:     260.1 KiB    used:     95.82 KiB  \n\nnet bandwidth: \n     staked:        100.0000 EOS           (total stake delegated from account to self)\n     delegated:       0.0000 EOS           (total staked delegated to account from others)\n     used:             5.534 KiB  \n     available:        18.23 MiB  \n     limit:            18.24 MiB  \n\ncpu bandwidth:\n     staked:        100.0000 EOS           (total stake delegated from account to self)\n     delegated:       0.0000 EOS           (total staked delegated to account from others)\n     used:             9.367 ms   \n     available:        3.629 sec  \n     limit:            3.639 sec  \n\nEOS balances: \n     liquid:           80.1129 EOS\n     staked:          200.0000 EOS\n     unstaking:         0.0000 EOS\n     total:           280.1129 EOS\n\nproducers:     &lt;not voted&gt;\n</code></pre><h4 id=\"eos权限的使用\"><a href=\"#eos权限的使用\" class=\"headerlink\" title=\"eos权限的使用\"></a>eos权限的使用</h4><blockquote>\n<p>上述方法给shaokun11121设置了一个add的权限,得添加到具体的action上才能体现出这个价值.目前能够搜到的文章都是加载 transfer这个操作上面的.为什么呢? 因为有了这个权,就可以不用登陆shaokun11121转账了,直接使用shaokun11122转账了.</p>\n</blockquote>\n<ul>\n<li><p>权限签名 </p>\n<pre><code>Positionals:\n  account TEXT                The account to set/delete a permission authority for (required)\n  code TEXT                   The account that owns the code for the action (required)\n  type TEXT                   the type of the action (required)\n  requirement TEXT            [delete] NULL, [set/update] The permission name require for executing the given action (required)\n</code></pre></li>\n<li><p>给shaokun11121 add action和add 权限关联起来,这样只要是shaokun111121的合约中有add action,那么使用shaokun11122的add权限均可以调用.根据我的测试,一个account目前只能部署一个智能合约,所以这个add方法是唯一的</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  set action permission shaokun11121 shaokun11121 add add\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限合约的编写\"><a href=\"#eos权限合约的编写\" class=\"headerlink\" title=\"eos权限合约的编写\"></a>eos权限合约的编写</h4><blockquote>\n<p>合约编写很简单,就是helloworld,注意其中的权限验证那一行,也就是说,只有自己的account 才能添加或者更新自己的这条信息</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] learnper2 : public contract {\n  public:\n    using contract::contract;\n    learnper2(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )\n                              :contract(reciever,code,ds),\n                              _students(reciever,code.value){};\n\n    [[eosio::action]]\n    void add(name user, const std::string msg) {\n      require_auth(user); // 权限额验证 \n      auto itr = _students.find(user.value);\n      if (itr == _students.end()){\n        _students.emplace(get_self(),[&amp;](auto&amp; row){\n          row.user = user;\n          row.msg = msg;\n        });\n      } else {\n        _students.modify(itr, get_self(), [&amp;](auto&amp; row){\n          row.msg = msg;\n        });\n      }\n    };\n\n\n  private:\n  struct [[eosio::table]] student \n  {\n    name user;\n    std::string msg = &quot;hello world&quot;;\n    uint64_t primary_key() const {return user.value;};\n\n  };\n  typedef eosio::multi_index&lt;&quot;student&quot;_n, student&gt; student_index;\n  student_index _students; \n};\nEOSIO_DISPATCH( learnper2, (add))\n</code></pre><h4 id=\"eos权限合约的编译-部署\"><a href=\"#eos权限合约的编译-部署\" class=\"headerlink\" title=\"eos权限合约的编译,部署\"></a>eos权限合约的编译,部署</h4><ul>\n<li><p>编译:这里有个小插曲,放合约cpp文件的文件夹貌似必须命名和主合约的文件名一致,生成的abi里面没有内容,这着实也困扰了我一会</p>\n<p>  eosio-cpp -abigen learnper2.cpp learnper2.wasm</p>\n</li>\n<li><p>这里部署合约一般需要购买ram  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  system buyram shaokun11121 shaokun11121 -k 256\n</code></pre></li>\n<li><p>部署:  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888 set contract shaokun11121 ./learnper2/ -p shaokun11121@active\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限合约结果展示\"><a href=\"#eos权限合约结果展示\" class=\"headerlink\" title=\"eos权限合约结果展示\"></a>eos权限合约结果展示</h4><p><img src=\"/eospermission/per2.gif\" alt=\"eos\"></p>\n<blockquote>\n<p>这里说一下我的操作流程</p>\n</blockquote>\n<ul>\n<li>调用合约的add action 插入一条信息(我这里之前插入信息,故此步未进行演示)  </li>\n<li>首先查看了 shaokun11121的 account信息,可以看到添加了一条add的permission</li>\n<li>再次查看了 shaokun11122的account信息,正常状态,只要你新建一个account都是这样的</li>\n<li>查看了钱包里面的信息,这里显示的是shaokun11122的公钥(大家可以仔细对比一下)</li>\n<li>查看链上table的数据</li>\n<li><p>修改数据,我们仔细来分析这条命令  </p>\n<blockquote>\n<ol>\n<li>这里使用的传入的user是shaokun11121</li>\n<li>传入的permission是 shaokun111121的add这个permission,各位同学可以回想一下之前的合约,调用都是是用的active</li>\n<li>钱包中并没有shaokun11121的私钥</li>\n<li>钱包中占有shaokun11122的私钥  </li>\n</ol>\n</blockquote>\n</li>\n<li><p>再次展示数据,数据修改成功  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  push action shaokun11121 add &apos;{&quot;user&quot;:&quot;shaokun11121&quot;,&quot;msg&quot;:&quot;i am shaokun&quot;}&apos; -p shaokun11121@add\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限使用心得\"><a href=\"#eos权限使用心得\" class=\"headerlink\" title=\"eos权限使用心得\"></a>eos权限使用心得</h4><blockquote>\n<ul>\n<li>这里只是展示的单个权限的使用在dapp中怎么使用   </li>\n<li>如果只看白皮书还是很难理解的,建议通过实际的操作,加深理解吧  </li>\n</ul>\n</blockquote>\n<h4 id=\"eos权限的进一步思考\"><a href=\"#eos权限的进一步思考\" class=\"headerlink\" title=\"eos权限的进一步思考\"></a>eos权限的进一步思考</h4><blockquote>\n<ul>\n<li>以太坊和eos的多重权限的签名目前我还没遇到过在dapp中实际使用的例子,官方的例子就是基本上是转账需要多个人同意,那么在dapp中如何使用呢?</li>\n<li>本课程只展示了阀值为1,权限值为1的active权限,那么如果按照官方例子,如果阈值为2,同时需要两个权限值都为1的账号的active权限来进行某个action的执行呢? </li>\n<li>接上一条,如果需要的不是active权限,比如本课中的add权限呢?</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eos-permission\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><blockquote>\n<p>相信各位同学看eos白皮书的权限看得很是头疼,而我能搜索到的例子基本上是官方的那个权限图再结合eos.token进行转账的权限介绍.如果不细心跟着走一遍,你是绝对不好理解这个权限怎么用的.由于我头脑比较笨,着实按照大佬的文章走了三四遍才大约摸索清楚,这里给自己做一个备忘录吧<br>而我站在大佬的肩膀上,结合实际的操作给大家聊聊这个权限如何使用吧.<br>这里主要参考的  </p>\n<ul>\n<li><a href=\"https://eosfans.io/topics/653\" target=\"_blank\" rel=\"noopener\">EOS 权限管理之-权限的使用 (你绝对找不到的干货)</a>  <ul>\n<li><a href=\"https://bihu.com/article/293974\" target=\"_blank\" rel=\"noopener\">EOS开发系列目录</a> 松果的文章都是根据源码分析的,建议开发dapp的同学都认真读几遍吧,这样更能帮助理解eos到底是怎样运行的</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h4><ul>\n<li><p>提前在测试网上申请两个账号,并领取测试币(不知道怎么做的可以翻看我前面的文章),我这里申请了两个.  </p>\n</li>\n<li><p>这次使用cleos操作,就不使用scatter操作了.原理一样.所以得把申请的这两个账号的私钥导入到cleos创建的钱包里面  </p>\n<pre><code>shaokun11121\nPrivate key: 5KFoeWx69fjPj7mTDbcD9JauYd9LLjikYTa9Qg7N5CVZTqZrzNG\nPublic key: EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n\nshaokun11122\nPrivate key: 5HrJQ9eepF6FuG47eSJprxoFQ6PWRkombbWEwxoSQr6FJ1wQPbg\nPublic key: EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV\n</code></pre></li>\n</ul>\n<h4 id=\"以太坊权限的实现\"><a href=\"#以太坊权限的实现\" class=\"headerlink\" title=\"以太坊权限的实现\"></a>以太坊权限的实现</h4><blockquote>\n<p>这里先给贴一段简单的以太坊的权限的管理吧,这个要自己来写,如果你有以太坊的经验,相信更加容易理解.<br>理一理:</p>\n<ol>\n<li>部署合约,部署完成后,owner就是部署者的地址</li>\n<li>查看count的值,此时count为初始值1</li>\n<li>执行add方法</li>\n<li>查看count的值,此时count的值为2</li>\n<li>切换address</li>\n<li>执行add方法,报错,因为不是owner</li>\n<li>查看count的值 还是为2</li>\n<li>再次执行3,4步骤,此时count的值的值为3</li>\n</ol>\n</blockquote>\n<p> <img src=\"/eospermission/per1.gif\" alt=\"eos\"></p>\n<pre><code>pragma solidity ^0.4.24;\n\ncontract Ownable {\n  address public owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n}\ncontract leranper is Ownable {\n\n    uint256 public count = 1;\n\n    function add() external onlyOwner  {\n       count += 1;\n    }\n}\n</code></pre><h4 id=\"eos的权限的实现\"><a href=\"#eos的权限的实现\" class=\"headerlink\" title=\"eos的权限的实现\"></a>eos的权限的实现</h4><blockquote>\n<p>eos的权限不需要写到合约中,底层已经帮我们实现了,我们只需要进行相应的设置即可,以下是设置权限的签名.至于设置的各个参数怎么设置,怎么用,可以看看官方文档吧</p>\n</blockquote>\n<pre><code>Usage: cleos set account permission [OPTIONS] account permission authority [parent]\n\nPositionals:\n  account TEXT                The account to set/delete a permission authority for (required)\n  permission TEXT             The permission name to set/delete an authority for (required)\n  authority TEXT              [delete] NULL, [create/update] public key, JSON string, or filename defining the authority (required)\n  parent TEXT                 [create] The permission name of this parents permission (Defaults to: &quot;Active&quot;)\n</code></pre><p>方法1:使用account设置  </p>\n<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11122&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;\n</code></pre><p>方法二:使用public key进行设置</p>\n<pre><code>cleos set account permission shaokun11121 add &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;permission&quot;:{&quot;key&quot;:&quot;EOS8ZZCicammR45b9tQUSU8VHqX4M8oFM89Cs8tFFWYgUGasegnnV&quot;,&quot;permission&quot;:&quot;active&quot;},&quot;weight&quot;:1}]}&apos;  \n</code></pre><p>当然你可以把两种设置方式都用上,根据个人习惯设定就好,</p>\n<blockquote>\n<p>这里建议后面的permission这段,先使用ide写上正确的json格式.然后在<a href=\"http://www.bejson.com/\" target=\"_blank\" rel=\"noopener\">json格式压缩</a>进行压缩成一行,这样可以避免不必要的麻烦</p>\n</blockquote>\n<pre><code>    {\n    &quot;threshold&quot;: 1,\n    &quot;keys&quot;: [],\n    &quot;accounts&quot;: [\n        {\n            &quot;permission&quot;: {\n                &quot;actor&quot;: &quot;kun2&quot;,\n                &quot;permission&quot;: &quot;active&quot;\n            },\n            &quot;weight&quot;: 1\n        }\n    ]\n}\n</code></pre><h4 id=\"eos的权限的解读\"><a href=\"#eos的权限的解读\" class=\"headerlink\" title=\"eos的权限的解读\"></a>eos的权限的解读</h4><ul>\n<li>当按照上述方式设置好后,可以通过此命令查看设置的权限,注意看这里permissions里多了一个add权限 这个权限的名字是 add,阀值是1 权限值 是1 ,父权限是active. </li>\n<li>这样设置后,也就是说 只要是active shaokun11121的active的权限能够执行的操作,使用shaokun11122的密钥生成的账户的active权限均能做</li>\n<li>一个私钥与一个公钥是一一对应,而这一对钥匙可以作为一个或者多个account中的权限级别</li>\n<li><p>当然你也可以按照上述的方式多设置几个权限看看,它的形式就像Windows的目录展示的形式,很好辨认的</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\n</code></pre></li>\n</ul>\n<p>查看的结果  </p>\n<pre><code>bogon:libraries shaokun$ cleos -u http://jungle.cryptolions.io:18888  get account shaokun11121\ncreated: 2018-11-17T12:46:30.000\npermissions: \n     owner     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n        active     1:    1 EOS69w5V46oUaBD5PSx3AMRxWXPi6b3St2PwbX9kBPY6tZvSs65o1\n           add     1:    1 shaokun11122@active\nmemory: \n     quota:     260.1 KiB    used:     95.82 KiB  \n\nnet bandwidth: \n     staked:        100.0000 EOS           (total stake delegated from account to self)\n     delegated:       0.0000 EOS           (total staked delegated to account from others)\n     used:             5.534 KiB  \n     available:        18.23 MiB  \n     limit:            18.24 MiB  \n\ncpu bandwidth:\n     staked:        100.0000 EOS           (total stake delegated from account to self)\n     delegated:       0.0000 EOS           (total staked delegated to account from others)\n     used:             9.367 ms   \n     available:        3.629 sec  \n     limit:            3.639 sec  \n\nEOS balances: \n     liquid:           80.1129 EOS\n     staked:          200.0000 EOS\n     unstaking:         0.0000 EOS\n     total:           280.1129 EOS\n\nproducers:     &lt;not voted&gt;\n</code></pre><h4 id=\"eos权限的使用\"><a href=\"#eos权限的使用\" class=\"headerlink\" title=\"eos权限的使用\"></a>eos权限的使用</h4><blockquote>\n<p>上述方法给shaokun11121设置了一个add的权限,得添加到具体的action上才能体现出这个价值.目前能够搜到的文章都是加载 transfer这个操作上面的.为什么呢? 因为有了这个权,就可以不用登陆shaokun11121转账了,直接使用shaokun11122转账了.</p>\n</blockquote>\n<ul>\n<li><p>权限签名 </p>\n<pre><code>Positionals:\n  account TEXT                The account to set/delete a permission authority for (required)\n  code TEXT                   The account that owns the code for the action (required)\n  type TEXT                   the type of the action (required)\n  requirement TEXT            [delete] NULL, [set/update] The permission name require for executing the given action (required)\n</code></pre></li>\n<li><p>给shaokun11121 add action和add 权限关联起来,这样只要是shaokun111121的合约中有add action,那么使用shaokun11122的add权限均可以调用.根据我的测试,一个account目前只能部署一个智能合约,所以这个add方法是唯一的</p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  set action permission shaokun11121 shaokun11121 add add\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限合约的编写\"><a href=\"#eos权限合约的编写\" class=\"headerlink\" title=\"eos权限合约的编写\"></a>eos权限合约的编写</h4><blockquote>\n<p>合约编写很简单,就是helloworld,注意其中的权限验证那一行,也就是说,只有自己的account 才能添加或者更新自己的这条信息</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] learnper2 : public contract {\n  public:\n    using contract::contract;\n    learnper2(eosio::name reciever,eosio::name code,eosio::datastream&lt;const char*&gt; ds )\n                              :contract(reciever,code,ds),\n                              _students(reciever,code.value){};\n\n    [[eosio::action]]\n    void add(name user, const std::string msg) {\n      require_auth(user); // 权限额验证 \n      auto itr = _students.find(user.value);\n      if (itr == _students.end()){\n        _students.emplace(get_self(),[&amp;](auto&amp; row){\n          row.user = user;\n          row.msg = msg;\n        });\n      } else {\n        _students.modify(itr, get_self(), [&amp;](auto&amp; row){\n          row.msg = msg;\n        });\n      }\n    };\n\n\n  private:\n  struct [[eosio::table]] student \n  {\n    name user;\n    std::string msg = &quot;hello world&quot;;\n    uint64_t primary_key() const {return user.value;};\n\n  };\n  typedef eosio::multi_index&lt;&quot;student&quot;_n, student&gt; student_index;\n  student_index _students; \n};\nEOSIO_DISPATCH( learnper2, (add))\n</code></pre><h4 id=\"eos权限合约的编译-部署\"><a href=\"#eos权限合约的编译-部署\" class=\"headerlink\" title=\"eos权限合约的编译,部署\"></a>eos权限合约的编译,部署</h4><ul>\n<li><p>编译:这里有个小插曲,放合约cpp文件的文件夹貌似必须命名和主合约的文件名一致,生成的abi里面没有内容,这着实也困扰了我一会</p>\n<p>  eosio-cpp -abigen learnper2.cpp learnper2.wasm</p>\n</li>\n<li><p>这里部署合约一般需要购买ram  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  system buyram shaokun11121 shaokun11121 -k 256\n</code></pre></li>\n<li><p>部署:  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888 set contract shaokun11121 ./learnper2/ -p shaokun11121@active\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限合约结果展示\"><a href=\"#eos权限合约结果展示\" class=\"headerlink\" title=\"eos权限合约结果展示\"></a>eos权限合约结果展示</h4><p><img src=\"/eospermission/per2.gif\" alt=\"eos\"></p>\n<blockquote>\n<p>这里说一下我的操作流程</p>\n</blockquote>\n<ul>\n<li>调用合约的add action 插入一条信息(我这里之前插入信息,故此步未进行演示)  </li>\n<li>首先查看了 shaokun11121的 account信息,可以看到添加了一条add的permission</li>\n<li>再次查看了 shaokun11122的account信息,正常状态,只要你新建一个account都是这样的</li>\n<li>查看了钱包里面的信息,这里显示的是shaokun11122的公钥(大家可以仔细对比一下)</li>\n<li>查看链上table的数据</li>\n<li><p>修改数据,我们仔细来分析这条命令  </p>\n<blockquote>\n<ol>\n<li>这里使用的传入的user是shaokun11121</li>\n<li>传入的permission是 shaokun111121的add这个permission,各位同学可以回想一下之前的合约,调用都是是用的active</li>\n<li>钱包中并没有shaokun11121的私钥</li>\n<li>钱包中占有shaokun11122的私钥  </li>\n</ol>\n</blockquote>\n</li>\n<li><p>再次展示数据,数据修改成功  </p>\n<pre><code>cleos -u http://jungle.cryptolions.io:18888  push action shaokun11121 add &apos;{&quot;user&quot;:&quot;shaokun11121&quot;,&quot;msg&quot;:&quot;i am shaokun&quot;}&apos; -p shaokun11121@add\n</code></pre></li>\n</ul>\n<h4 id=\"eos权限使用心得\"><a href=\"#eos权限使用心得\" class=\"headerlink\" title=\"eos权限使用心得\"></a>eos权限使用心得</h4><blockquote>\n<ul>\n<li>这里只是展示的单个权限的使用在dapp中怎么使用   </li>\n<li>如果只看白皮书还是很难理解的,建议通过实际的操作,加深理解吧  </li>\n</ul>\n</blockquote>\n<h4 id=\"eos权限的进一步思考\"><a href=\"#eos权限的进一步思考\" class=\"headerlink\" title=\"eos权限的进一步思考\"></a>eos权限的进一步思考</h4><blockquote>\n<ul>\n<li>以太坊和eos的多重权限的签名目前我还没遇到过在dapp中实际使用的例子,官方的例子就是基本上是转账需要多个人同意,那么在dapp中如何使用呢?</li>\n<li>本课程只展示了阀值为1,权限值为1的active权限,那么如果按照官方例子,如果阈值为2,同时需要两个权限值都为1的账号的active权限来进行某个action的执行呢? </li>\n<li>接上一条,如果需要的不是active权限,比如本课中的add权限呢?</li>\n</ul>\n</blockquote>\n<p><a href=\"https://github.com/shaokun11/eos-permission\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#x68;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x68;&#97;&#111;&#107;&#x75;&#x6e;&#105;&#x6e;&#x67;&#64;&#103;&#x6d;&#x61;&#105;&#x6c;&#46;&#x63;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#110;&#x79;&#64;&#49;&#54;&#x33;&#x2e;&#99;&#x6f;&#109;</a></p>\n"},{"title":"eos中inline action的使用方式 (下)","date":"2018-12-01T01:34:33.000Z","_content":"\n#### 前言\n * 关于上一篇的inline action关于作为log的用法,我觉得这是其一,其二是可以action调用action,这样的话应该也算作action的第二种用法了吧  \n * 本篇文章介绍inline action的第三种用户,外部合约的调用  \n * 记住一点,这些调用都是在一个事务中进行的,所以可以放心大胆的使用\n * 由于eos的体系,需要你完全明白eos中 account 和permission level这两个东东的作用,不然理解起来会有点困难\n\n#### 据说\n* 听说BM又要离开eos了,我觉得无所谓了,毕竟eos是开源的,很多人维护的\n* eos1.5发布了,是不是又得跟上步伐呢?感觉学不动了\n* [js4eos介绍](https://mp.weixin.qq.com/s/IovpLgfvcWhu3L3tGbKiZg)这工具可以简化一些工作,喜欢的同学可以试试[js4eos github](https://github.com/itleaks/js4eos) \n\n#### eos中inline action 结果展示与说明\n* 这里官方的例子合约(cpp文件)和账户名字是一样的,让我困扰了一会,这里给大家一个结论就好:一个账户就只能部署一个合约,而这个合约的名字就是get_self(),当你部署合约的时候,就是账号的名字了.在写line action的时候不要弄混了\n* 使用shaokun11111部署合约 addressbook\n* 使用shaokun11112部署合约 adcounter\n* 在addressbook中使用inline action调用adcounter中的count方法\n* 这样设置后,多个合约就可以相互调用了\n* 关键点,如果要actor shaokun11111能够拥有调用其他合约的权限,必须给shaokun11111账号授予权限eosio.code,这是个系统的权限.\n\n\n\t\tcleos -u https://api-kylin.eosasia.one:443 set account permission shaokun11111 active '{\"threshold\":1,\"keys\":[{\"key\":\"EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82\",\"weight\":1}],\"accounts\":[{\"permission\":{\"actor\":\"shaokun11111\",\"permission\":\"eosio.code\"}}]}' -p shaokun11111@owner\n* 关于permission的格式可以参考我以前的文章,注意这里使用的owner权限\n* `EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82` 这个是原来创建账号的权限的public key,当然按照上面的写法,这样其实可以更改原来账号的active的权限,建议保持原来权限创建的形式就好\n* 授权成功后,账号应该有如图中的显示\n* ![shaokun](/eospermission/per1.png)\n* ![shaokun](/eospermission/per3.gif)\n\n#### eth中合约相互调用\n>如果你理解了eos合约的相互调用,那么接下来eth中的合约相互调用你应该很好理解了  \n>个人看来两者的机制大同小异,因为eth中是以address中作为id的,而eos中是以account做为id的\n\n* 基于上篇文章的eth合约,我们稍加改造一下\n* 新添加了一个合约 Test3,其中我们将Test2的合约地址用来实例化了Service\n* 这个Service中需要包含Test2合约中你需要调用的方法的签名(这里关于是怎样找到的可以去看看官方文档,其实  `function notify(string _notification) external;` 就是这个函数的签名,包括方法名字和参数类型,返回值类型hash后 取了四个字节)\n* 部署Test3合约,部署成功后再Test3合约中的callNotify调用Test2合约中的notify方法,可以看到Test合约中的内容生效了\n* 这里有同学可能有疑问了,你这样的合约岂不是没有安全?拿到Test2合约地址,任何人新建一个合约就可以调用其合约的方法?是的,理论上是这样的.但是,凡事都有个但是哈.还记得我在之前的文章中关于eth中的权限如果验证吗?如果你看了那篇文章,那聪明的你一定知道该怎么做了哈  \n* ![shaokun](/eospermission/per4.gif)\n\n#### 源码献上\n> `addressbook.cpp`,没什么说的,注意写法,变化的部分如果你认真阅读了应该知道变化在哪里\n\t#include <eosiolib/eosio.hpp>\n\t#include <eosiolib/print.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] addressbook : public eosio::contract {\n\tpublic:\n\t    using contract::contract;\n\t    addressbook(name reciever, name code, datastream<const char*> ds) : contract(reciever,code,ds){}\n\t\n\t    [[eosio::action]]\n\t    void upsert(name user, std::string first_name, uint64_t age){\n\t        require_auth(user);\n\t        address_index addresses(_code,_code.value);\n\t        auto itr = addresses.find(user.value);\n\t        if(itr == addresses.end()){\n\t            addresses.emplace(user,[&](auto& row){\n\t                row.key = user;\n\t                row.first_name = first_name;\n\t                row.age = age;\n\t            });\n\t            send_summary(user, \"emplace data\");\n\t            counter(user,\"emplace\");\n\t        } else {\n\t            addresses.modify(itr, user, [&](auto& row){\n\t                        row.first_name = first_name;\n\t                        row.age = age;\n\t            });\n\t            send_summary(user, \"modify data\");\n\t            counter(user,\"modify\");\n\t        }\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void erase(name user){\n\t        require_auth(user);\n\t        address_index addresses(_self, _code.value);\n\t        auto itr = addresses.find(user.value);\n\t        eosio_assert(itr != addresses.end(),\"record not exist\");\n\t        addresses.erase(itr);\n\t        // 调用inline action\n\t        send_summary(user, \" erase data\");\n\t        counter(user,\"erase\");\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void notify(name user, std::string){\n\t        // inline action\n\t        require_auth(get_self());\n\t        require_recipient(user);\n\t    }\n\t\n\tprivate:\n\t    struct [[eosio::table]] person {\n\t        name key;\n\t        std::string first_name;\n\t        uint64_t age;\n\t\n\t        auto primary_key() const {\n\t            return key.value;\n\t        };\n\t    };\n\t    typedef multi_index<\"person\"_n, person> address_index;\n\t    \n\t    // inline action的具体实现\n\t    void send_summary(name user, std::string msg){\n\t        action(\n\t            permission_level{get_self(),\"active\"_n},\n\t                get_self(),\n\t                \"notify\"_n,\n\t                std::make_tuple(user, name{user}.to_string() +msg)\n\t            ).send();\n\t    }\n\t    void counter(name user, std::string type){\n\t        action counter = action(\n\t            permission_level{get_self(),\"active\"_n},// 执行这个inline aciton所需要的权限,即本合约调用\n\t            \"shaokun11112\"_n,                       // 账号名称\n\t            \"count\"_n,                              // action 名称\n\t            std::make_tuple(user,type)              // 传递的参数\n\t            );\n\t        counter.send();\n\t    }\n\t};\n\tEOSIO_DISPATCH(addressbook,(upsert)(erase))\n\n> `adcounter.cpp` 注意其中的权限验证部分,其他没什么好说的\n\n\t#include <eosiolib/eosio.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] adcounter: public eosio::contract {\n\tpublic:\n\t\tusing contract::contract;\n\t\tadcounter(name receiver, name code, datastream<const char*> ds):contract(receiver,code,ds),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcounts(receiver,code.value){}\n\t\n\t\tvoid count(name user, std::string type) {\n\t\t\t// 设定这个方法的调用权限\n\t\t\t// 只有 shaokun11111 这个账号部署的合约有这个权限更改这个合约的内容\n\t\t\trequire_auth(name(\"shaokun11111\"));\n\t\t\tauto itr = counts.find(user.value);\n\t\t\tif(itr == counts.end()){\n\t\t\t\tcounts.emplace(\"shaokun11111\"_n, [&](auto& row){\n\t\t\t\t\trow.key = user;\n\t\t\t\t\trow.emplaced = type == \"emplace\" ? 1 : 0;\n\t\t\t\t\trow.modified = type == \"modify\" ? 1 : 0;\n\t\t\t\t\trow.erased = type == \"erase\" ? 1 : 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcounts.modify(itr,\"shaokun11111\"_n,[&](auto& row){\n\t\t\t\t\tif (type == \"emplace\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.emplaced += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (type == \"modify\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.modified += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (type == \"erase\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.erased += 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\tprivate:\n\t\tstruct [[eosio::table]] counter\n\t\t{\n\t\t\tname key;\n\t\t\tuint64_t emplaced;\n\t\t\tuint64_t modified;\n\t\t\tuint64_t erased;\n\t\n\t\t\tuint64_t primary_key() const {return key.value;}\n\t\t};\n\t\n\t\ttypedef eosio::multi_index<\"counter\"_n,counter> counter_index;\n\t\tcounter_index counts;\n\t};\n\tEOSIO_DISPATCH(adcounter,(count));\n前端代码就不展示了,因为所有的操作都是在addressbook这个合约中进行操作的,adcounter只是展示了合约中的记录  \n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-inline-action2)\n\n#### 总结\n* 建议各位同学一定要仔细敲一遍,虽然例子简单,但是再复杂的内容也是由这些简单的例子所产生的\n* eos inline action的作用已经说完了.这样掌握之后,就可以写很多合约,壮大你的dapp了.inline action很重要的一点 是可以回滚交易,好好利用,发挥意想不到的作用\n* 话说还有个deferred action,有时间再和大家分享一下这货是怎使用了\n* dapp的开发不仅仅是写合约,目前主要应用还是在web上.所以建议各位同学还是得了解一下js,node,webpack,react,css这些基础的概念和用法吧.不要多熟练,大概了解一下怎么用就好了\n* 还有一点,哪位同学知道eos中有类似eth中的event的功能,即合约主动推送信息给我们,我觉得这很重要.我觉得eosjs应该提供类似的功能呢.知道的同学麻烦告知一声\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解2.md","raw":"---\ntitle: eos中inline action的使用方式 (下)\ndate: 2018-12-01 09:34:33\n---\n\n#### 前言\n * 关于上一篇的inline action关于作为log的用法,我觉得这是其一,其二是可以action调用action,这样的话应该也算作action的第二种用法了吧  \n * 本篇文章介绍inline action的第三种用户,外部合约的调用  \n * 记住一点,这些调用都是在一个事务中进行的,所以可以放心大胆的使用\n * 由于eos的体系,需要你完全明白eos中 account 和permission level这两个东东的作用,不然理解起来会有点困难\n\n#### 据说\n* 听说BM又要离开eos了,我觉得无所谓了,毕竟eos是开源的,很多人维护的\n* eos1.5发布了,是不是又得跟上步伐呢?感觉学不动了\n* [js4eos介绍](https://mp.weixin.qq.com/s/IovpLgfvcWhu3L3tGbKiZg)这工具可以简化一些工作,喜欢的同学可以试试[js4eos github](https://github.com/itleaks/js4eos) \n\n#### eos中inline action 结果展示与说明\n* 这里官方的例子合约(cpp文件)和账户名字是一样的,让我困扰了一会,这里给大家一个结论就好:一个账户就只能部署一个合约,而这个合约的名字就是get_self(),当你部署合约的时候,就是账号的名字了.在写line action的时候不要弄混了\n* 使用shaokun11111部署合约 addressbook\n* 使用shaokun11112部署合约 adcounter\n* 在addressbook中使用inline action调用adcounter中的count方法\n* 这样设置后,多个合约就可以相互调用了\n* 关键点,如果要actor shaokun11111能够拥有调用其他合约的权限,必须给shaokun11111账号授予权限eosio.code,这是个系统的权限.\n\n\n\t\tcleos -u https://api-kylin.eosasia.one:443 set account permission shaokun11111 active '{\"threshold\":1,\"keys\":[{\"key\":\"EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82\",\"weight\":1}],\"accounts\":[{\"permission\":{\"actor\":\"shaokun11111\",\"permission\":\"eosio.code\"}}]}' -p shaokun11111@owner\n* 关于permission的格式可以参考我以前的文章,注意这里使用的owner权限\n* `EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82` 这个是原来创建账号的权限的public key,当然按照上面的写法,这样其实可以更改原来账号的active的权限,建议保持原来权限创建的形式就好\n* 授权成功后,账号应该有如图中的显示\n* ![shaokun](/eospermission/per1.png)\n* ![shaokun](/eospermission/per3.gif)\n\n#### eth中合约相互调用\n>如果你理解了eos合约的相互调用,那么接下来eth中的合约相互调用你应该很好理解了  \n>个人看来两者的机制大同小异,因为eth中是以address中作为id的,而eos中是以account做为id的\n\n* 基于上篇文章的eth合约,我们稍加改造一下\n* 新添加了一个合约 Test3,其中我们将Test2的合约地址用来实例化了Service\n* 这个Service中需要包含Test2合约中你需要调用的方法的签名(这里关于是怎样找到的可以去看看官方文档,其实  `function notify(string _notification) external;` 就是这个函数的签名,包括方法名字和参数类型,返回值类型hash后 取了四个字节)\n* 部署Test3合约,部署成功后再Test3合约中的callNotify调用Test2合约中的notify方法,可以看到Test合约中的内容生效了\n* 这里有同学可能有疑问了,你这样的合约岂不是没有安全?拿到Test2合约地址,任何人新建一个合约就可以调用其合约的方法?是的,理论上是这样的.但是,凡事都有个但是哈.还记得我在之前的文章中关于eth中的权限如果验证吗?如果你看了那篇文章,那聪明的你一定知道该怎么做了哈  \n* ![shaokun](/eospermission/per4.gif)\n\n#### 源码献上\n> `addressbook.cpp`,没什么说的,注意写法,变化的部分如果你认真阅读了应该知道变化在哪里\n\t#include <eosiolib/eosio.hpp>\n\t#include <eosiolib/print.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] addressbook : public eosio::contract {\n\tpublic:\n\t    using contract::contract;\n\t    addressbook(name reciever, name code, datastream<const char*> ds) : contract(reciever,code,ds){}\n\t\n\t    [[eosio::action]]\n\t    void upsert(name user, std::string first_name, uint64_t age){\n\t        require_auth(user);\n\t        address_index addresses(_code,_code.value);\n\t        auto itr = addresses.find(user.value);\n\t        if(itr == addresses.end()){\n\t            addresses.emplace(user,[&](auto& row){\n\t                row.key = user;\n\t                row.first_name = first_name;\n\t                row.age = age;\n\t            });\n\t            send_summary(user, \"emplace data\");\n\t            counter(user,\"emplace\");\n\t        } else {\n\t            addresses.modify(itr, user, [&](auto& row){\n\t                        row.first_name = first_name;\n\t                        row.age = age;\n\t            });\n\t            send_summary(user, \"modify data\");\n\t            counter(user,\"modify\");\n\t        }\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void erase(name user){\n\t        require_auth(user);\n\t        address_index addresses(_self, _code.value);\n\t        auto itr = addresses.find(user.value);\n\t        eosio_assert(itr != addresses.end(),\"record not exist\");\n\t        addresses.erase(itr);\n\t        // 调用inline action\n\t        send_summary(user, \" erase data\");\n\t        counter(user,\"erase\");\n\t    }\n\t\n\t    [[eosio::action]]\n\t    void notify(name user, std::string){\n\t        // inline action\n\t        require_auth(get_self());\n\t        require_recipient(user);\n\t    }\n\t\n\tprivate:\n\t    struct [[eosio::table]] person {\n\t        name key;\n\t        std::string first_name;\n\t        uint64_t age;\n\t\n\t        auto primary_key() const {\n\t            return key.value;\n\t        };\n\t    };\n\t    typedef multi_index<\"person\"_n, person> address_index;\n\t    \n\t    // inline action的具体实现\n\t    void send_summary(name user, std::string msg){\n\t        action(\n\t            permission_level{get_self(),\"active\"_n},\n\t                get_self(),\n\t                \"notify\"_n,\n\t                std::make_tuple(user, name{user}.to_string() +msg)\n\t            ).send();\n\t    }\n\t    void counter(name user, std::string type){\n\t        action counter = action(\n\t            permission_level{get_self(),\"active\"_n},// 执行这个inline aciton所需要的权限,即本合约调用\n\t            \"shaokun11112\"_n,                       // 账号名称\n\t            \"count\"_n,                              // action 名称\n\t            std::make_tuple(user,type)              // 传递的参数\n\t            );\n\t        counter.send();\n\t    }\n\t};\n\tEOSIO_DISPATCH(addressbook,(upsert)(erase))\n\n> `adcounter.cpp` 注意其中的权限验证部分,其他没什么好说的\n\n\t#include <eosiolib/eosio.hpp>\n\t\n\tusing namespace eosio;\n\t\n\tclass [[eosio::contract]] adcounter: public eosio::contract {\n\tpublic:\n\t\tusing contract::contract;\n\t\tadcounter(name receiver, name code, datastream<const char*> ds):contract(receiver,code,ds),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcounts(receiver,code.value){}\n\t\n\t\tvoid count(name user, std::string type) {\n\t\t\t// 设定这个方法的调用权限\n\t\t\t// 只有 shaokun11111 这个账号部署的合约有这个权限更改这个合约的内容\n\t\t\trequire_auth(name(\"shaokun11111\"));\n\t\t\tauto itr = counts.find(user.value);\n\t\t\tif(itr == counts.end()){\n\t\t\t\tcounts.emplace(\"shaokun11111\"_n, [&](auto& row){\n\t\t\t\t\trow.key = user;\n\t\t\t\t\trow.emplaced = type == \"emplace\" ? 1 : 0;\n\t\t\t\t\trow.modified = type == \"modify\" ? 1 : 0;\n\t\t\t\t\trow.erased = type == \"erase\" ? 1 : 0;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcounts.modify(itr,\"shaokun11111\"_n,[&](auto& row){\n\t\t\t\t\tif (type == \"emplace\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.emplaced += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (type == \"modify\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.modified += 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (type == \"erase\")\n\t\t\t\t\t{\n\t\t\t\t\t\trow.erased += 1;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\tprivate:\n\t\tstruct [[eosio::table]] counter\n\t\t{\n\t\t\tname key;\n\t\t\tuint64_t emplaced;\n\t\t\tuint64_t modified;\n\t\t\tuint64_t erased;\n\t\n\t\t\tuint64_t primary_key() const {return key.value;}\n\t\t};\n\t\n\t\ttypedef eosio::multi_index<\"counter\"_n,counter> counter_index;\n\t\tcounter_index counts;\n\t};\n\tEOSIO_DISPATCH(adcounter,(count));\n前端代码就不展示了,因为所有的操作都是在addressbook这个合约中进行操作的,adcounter只是展示了合约中的记录  \n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-inline-action2)\n\n#### 总结\n* 建议各位同学一定要仔细敲一遍,虽然例子简单,但是再复杂的内容也是由这些简单的例子所产生的\n* eos inline action的作用已经说完了.这样掌握之后,就可以写很多合约,壮大你的dapp了.inline action很重要的一点 是可以回滚交易,好好利用,发挥意想不到的作用\n* 话说还有个deferred action,有时间再和大家分享一下这货是怎使用了\n* dapp的开发不仅仅是写合约,目前主要应用还是在web上.所以建议各位同学还是得了解一下js,node,webpack,react,css这些基础的概念和用法吧.不要多熟练,大概了解一下怎么用就好了\n* 还有一点,哪位同学知道eos中有类似eth中的event的功能,即合约主动推送信息给我们,我觉得这很重要.我觉得eosjs应该提供类似的功能呢.知道的同学麻烦告知一声\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解2","published":1,"updated":"2019-02-18T13:13:08.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52r000gnh7sk9e8ibut","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>关于上一篇的inline action关于作为log的用法,我觉得这是其一,其二是可以action调用action,这样的话应该也算作action的第二种用法了吧  </li>\n<li>本篇文章介绍inline action的第三种用户,外部合约的调用  </li>\n<li>记住一点,这些调用都是在一个事务中进行的,所以可以放心大胆的使用</li>\n<li>由于eos的体系,需要你完全明白eos中 account 和permission level这两个东东的作用,不然理解起来会有点困难</li>\n</ul>\n<h4 id=\"据说\"><a href=\"#据说\" class=\"headerlink\" title=\"据说\"></a>据说</h4><ul>\n<li>听说BM又要离开eos了,我觉得无所谓了,毕竟eos是开源的,很多人维护的</li>\n<li>eos1.5发布了,是不是又得跟上步伐呢?感觉学不动了</li>\n<li><a href=\"https://mp.weixin.qq.com/s/IovpLgfvcWhu3L3tGbKiZg\" target=\"_blank\" rel=\"noopener\">js4eos介绍</a>这工具可以简化一些工作,喜欢的同学可以试试<a href=\"https://github.com/itleaks/js4eos\" target=\"_blank\" rel=\"noopener\">js4eos github</a> </li>\n</ul>\n<h4 id=\"eos中inline-action-结果展示与说明\"><a href=\"#eos中inline-action-结果展示与说明\" class=\"headerlink\" title=\"eos中inline action 结果展示与说明\"></a>eos中inline action 结果展示与说明</h4><ul>\n<li>这里官方的例子合约(cpp文件)和账户名字是一样的,让我困扰了一会,这里给大家一个结论就好:一个账户就只能部署一个合约,而这个合约的名字就是get_self(),当你部署合约的时候,就是账号的名字了.在写line action的时候不要弄混了</li>\n<li>使用shaokun11111部署合约 addressbook</li>\n<li>使用shaokun11112部署合约 adcounter</li>\n<li>在addressbook中使用inline action调用adcounter中的count方法</li>\n<li>这样设置后,多个合约就可以相互调用了</li>\n<li>关键点,如果要actor shaokun11111能够拥有调用其他合约的权限,必须给shaokun11111账号授予权限eosio.code,这是个系统的权限.</li>\n</ul>\n<pre><code>cleos -u https://api-kylin.eosasia.one:443 set account permission shaokun11111 active &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82&quot;,&quot;weight&quot;:1}],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;}}]}&apos; -p shaokun11111@owner\n</code></pre><ul>\n<li>关于permission的格式可以参考我以前的文章,注意这里使用的owner权限</li>\n<li><code>EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82</code> 这个是原来创建账号的权限的public key,当然按照上面的写法,这样其实可以更改原来账号的active的权限,建议保持原来权限创建的形式就好</li>\n<li>授权成功后,账号应该有如图中的显示</li>\n<li><img src=\"/eospermission/per1.png\" alt=\"shaokun\"></li>\n<li><img src=\"/eospermission/per3.gif\" alt=\"shaokun\"></li>\n</ul>\n<h4 id=\"eth中合约相互调用\"><a href=\"#eth中合约相互调用\" class=\"headerlink\" title=\"eth中合约相互调用\"></a>eth中合约相互调用</h4><blockquote>\n<p>如果你理解了eos合约的相互调用,那么接下来eth中的合约相互调用你应该很好理解了<br>个人看来两者的机制大同小异,因为eth中是以address中作为id的,而eos中是以account做为id的</p>\n</blockquote>\n<ul>\n<li>基于上篇文章的eth合约,我们稍加改造一下</li>\n<li>新添加了一个合约 Test3,其中我们将Test2的合约地址用来实例化了Service</li>\n<li>这个Service中需要包含Test2合约中你需要调用的方法的签名(这里关于是怎样找到的可以去看看官方文档,其实  <code>function notify(string _notification) external;</code> 就是这个函数的签名,包括方法名字和参数类型,返回值类型hash后 取了四个字节)</li>\n<li>部署Test3合约,部署成功后再Test3合约中的callNotify调用Test2合约中的notify方法,可以看到Test合约中的内容生效了</li>\n<li>这里有同学可能有疑问了,你这样的合约岂不是没有安全?拿到Test2合约地址,任何人新建一个合约就可以调用其合约的方法?是的,理论上是这样的.但是,凡事都有个但是哈.还记得我在之前的文章中关于eth中的权限如果验证吗?如果你看了那篇文章,那聪明的你一定知道该怎么做了哈  </li>\n<li><img src=\"/eospermission/per4.gif\" alt=\"shaokun\"></li>\n</ul>\n<h4 id=\"源码献上\"><a href=\"#源码献上\" class=\"headerlink\" title=\"源码献上\"></a>源码献上</h4><blockquote>\n<p><code>addressbook.cpp</code>,没什么说的,注意写法,变化的部分如果你认真阅读了应该知道变化在哪里</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n#include &lt;eosiolib/print.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\npublic:\n    using contract::contract;\n    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}\n\n    [[eosio::action]]\n    void upsert(name user, std::string first_name, uint64_t age){\n        require_auth(user);\n        address_index addresses(_code,_code.value);\n        auto itr = addresses.find(user.value);\n        if(itr == addresses.end()){\n            addresses.emplace(user,[&amp;](auto&amp; row){\n                row.key = user;\n                row.first_name = first_name;\n                row.age = age;\n            });\n            send_summary(user, &quot;emplace data&quot;);\n            counter(user,&quot;emplace&quot;);\n        } else {\n            addresses.modify(itr, user, [&amp;](auto&amp; row){\n                        row.first_name = first_name;\n                        row.age = age;\n            });\n            send_summary(user, &quot;modify data&quot;);\n            counter(user,&quot;modify&quot;);\n        }\n    }\n\n    [[eosio::action]]\n    void erase(name user){\n        require_auth(user);\n        address_index addresses(_self, _code.value);\n        auto itr = addresses.find(user.value);\n        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);\n        addresses.erase(itr);\n        // 调用inline action\n        send_summary(user, &quot; erase data&quot;);\n        counter(user,&quot;erase&quot;);\n    }\n\n    [[eosio::action]]\n    void notify(name user, std::string){\n        // inline action\n        require_auth(get_self());\n        require_recipient(user);\n    }\n\nprivate:\n    struct [[eosio::table]] person {\n        name key;\n        std::string first_name;\n        uint64_t age;\n\n        auto primary_key() const {\n            return key.value;\n        };\n    };\n    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;\n\n    // inline action的具体实现\n    void send_summary(name user, std::string msg){\n        action(\n            permission_level{get_self(),&quot;active&quot;_n},\n                get_self(),\n                &quot;notify&quot;_n,\n                std::make_tuple(user, name{user}.to_string() +msg)\n            ).send();\n    }\n    void counter(name user, std::string type){\n        action counter = action(\n            permission_level{get_self(),&quot;active&quot;_n},// 执行这个inline aciton所需要的权限,即本合约调用\n            &quot;shaokun11112&quot;_n,                       // 账号名称\n            &quot;count&quot;_n,                              // action 名称\n            std::make_tuple(user,type)              // 传递的参数\n            );\n        counter.send();\n    }\n};\nEOSIO_DISPATCH(addressbook,(upsert)(erase))\n</code></pre><blockquote>\n<p><code>adcounter.cpp</code> 注意其中的权限验证部分,其他没什么好说的</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] adcounter: public eosio::contract {\npublic:\n    using contract::contract;\n    adcounter(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver,code,ds),\n                                                                    counts(receiver,code.value){}\n\n    void count(name user, std::string type) {\n        // 设定这个方法的调用权限\n        // 只有 shaokun11111 这个账号部署的合约有这个权限更改这个合约的内容\n        require_auth(name(&quot;shaokun11111&quot;));\n        auto itr = counts.find(user.value);\n        if(itr == counts.end()){\n            counts.emplace(&quot;shaokun11111&quot;_n, [&amp;](auto&amp; row){\n                row.key = user;\n                row.emplaced = type == &quot;emplace&quot; ? 1 : 0;\n                row.modified = type == &quot;modify&quot; ? 1 : 0;\n                row.erased = type == &quot;erase&quot; ? 1 : 0;\n            });\n        } else {\n            counts.modify(itr,&quot;shaokun11111&quot;_n,[&amp;](auto&amp; row){\n                if (type == &quot;emplace&quot;)\n                {\n                    row.emplaced += 1;\n                }\n                if (type == &quot;modify&quot;)\n                {\n                    row.modified += 1;\n                }\n                if (type == &quot;erase&quot;)\n                {\n                    row.erased += 1;\n                }\n            });\n        }\n    }\nprivate:\n    struct [[eosio::table]] counter\n    {\n        name key;\n        uint64_t emplaced;\n        uint64_t modified;\n        uint64_t erased;\n\n        uint64_t primary_key() const {return key.value;}\n    };\n\n    typedef eosio::multi_index&lt;&quot;counter&quot;_n,counter&gt; counter_index;\n    counter_index counts;\n};\nEOSIO_DISPATCH(adcounter,(count));\n</code></pre><p>前端代码就不展示了,因为所有的操作都是在addressbook这个合约中进行操作的,adcounter只是展示了合约中的记录<br><a href=\"https://github.com/shaokun11/eosabout/tree/eos-inline-action2\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>建议各位同学一定要仔细敲一遍,虽然例子简单,但是再复杂的内容也是由这些简单的例子所产生的</li>\n<li>eos inline action的作用已经说完了.这样掌握之后,就可以写很多合约,壮大你的dapp了.inline action很重要的一点 是可以回滚交易,好好利用,发挥意想不到的作用</li>\n<li>话说还有个deferred action,有时间再和大家分享一下这货是怎使用了</li>\n<li>dapp的开发不仅仅是写合约,目前主要应用还是在web上.所以建议各位同学还是得了解一下js,node,webpack,react,css这些基础的概念和用法吧.不要多熟练,大概了解一下怎么用就好了</li>\n<li>还有一点,哪位同学知道eos中有类似eth中的event的功能,即合约主动推送信息给我们,我觉得这很重要.我觉得eosjs应该提供类似的功能呢.知道的同学麻烦告知一声</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#x6b;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x6b;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>关于上一篇的inline action关于作为log的用法,我觉得这是其一,其二是可以action调用action,这样的话应该也算作action的第二种用法了吧  </li>\n<li>本篇文章介绍inline action的第三种用户,外部合约的调用  </li>\n<li>记住一点,这些调用都是在一个事务中进行的,所以可以放心大胆的使用</li>\n<li>由于eos的体系,需要你完全明白eos中 account 和permission level这两个东东的作用,不然理解起来会有点困难</li>\n</ul>\n<h4 id=\"据说\"><a href=\"#据说\" class=\"headerlink\" title=\"据说\"></a>据说</h4><ul>\n<li>听说BM又要离开eos了,我觉得无所谓了,毕竟eos是开源的,很多人维护的</li>\n<li>eos1.5发布了,是不是又得跟上步伐呢?感觉学不动了</li>\n<li><a href=\"https://mp.weixin.qq.com/s/IovpLgfvcWhu3L3tGbKiZg\" target=\"_blank\" rel=\"noopener\">js4eos介绍</a>这工具可以简化一些工作,喜欢的同学可以试试<a href=\"https://github.com/itleaks/js4eos\" target=\"_blank\" rel=\"noopener\">js4eos github</a> </li>\n</ul>\n<h4 id=\"eos中inline-action-结果展示与说明\"><a href=\"#eos中inline-action-结果展示与说明\" class=\"headerlink\" title=\"eos中inline action 结果展示与说明\"></a>eos中inline action 结果展示与说明</h4><ul>\n<li>这里官方的例子合约(cpp文件)和账户名字是一样的,让我困扰了一会,这里给大家一个结论就好:一个账户就只能部署一个合约,而这个合约的名字就是get_self(),当你部署合约的时候,就是账号的名字了.在写line action的时候不要弄混了</li>\n<li>使用shaokun11111部署合约 addressbook</li>\n<li>使用shaokun11112部署合约 adcounter</li>\n<li>在addressbook中使用inline action调用adcounter中的count方法</li>\n<li>这样设置后,多个合约就可以相互调用了</li>\n<li>关键点,如果要actor shaokun11111能够拥有调用其他合约的权限,必须给shaokun11111账号授予权限eosio.code,这是个系统的权限.</li>\n</ul>\n<pre><code>cleos -u https://api-kylin.eosasia.one:443 set account permission shaokun11111 active &apos;{&quot;threshold&quot;:1,&quot;keys&quot;:[{&quot;key&quot;:&quot;EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82&quot;,&quot;weight&quot;:1}],&quot;accounts&quot;:[{&quot;permission&quot;:{&quot;actor&quot;:&quot;shaokun11111&quot;,&quot;permission&quot;:&quot;eosio.code&quot;}}]}&apos; -p shaokun11111@owner\n</code></pre><ul>\n<li>关于permission的格式可以参考我以前的文章,注意这里使用的owner权限</li>\n<li><code>EOS5694dNS19CXwNMgQ3nd8eVG4gnqcihdstnmsChM8AdHNaDCC82</code> 这个是原来创建账号的权限的public key,当然按照上面的写法,这样其实可以更改原来账号的active的权限,建议保持原来权限创建的形式就好</li>\n<li>授权成功后,账号应该有如图中的显示</li>\n<li><img src=\"/eospermission/per1.png\" alt=\"shaokun\"></li>\n<li><img src=\"/eospermission/per3.gif\" alt=\"shaokun\"></li>\n</ul>\n<h4 id=\"eth中合约相互调用\"><a href=\"#eth中合约相互调用\" class=\"headerlink\" title=\"eth中合约相互调用\"></a>eth中合约相互调用</h4><blockquote>\n<p>如果你理解了eos合约的相互调用,那么接下来eth中的合约相互调用你应该很好理解了<br>个人看来两者的机制大同小异,因为eth中是以address中作为id的,而eos中是以account做为id的</p>\n</blockquote>\n<ul>\n<li>基于上篇文章的eth合约,我们稍加改造一下</li>\n<li>新添加了一个合约 Test3,其中我们将Test2的合约地址用来实例化了Service</li>\n<li>这个Service中需要包含Test2合约中你需要调用的方法的签名(这里关于是怎样找到的可以去看看官方文档,其实  <code>function notify(string _notification) external;</code> 就是这个函数的签名,包括方法名字和参数类型,返回值类型hash后 取了四个字节)</li>\n<li>部署Test3合约,部署成功后再Test3合约中的callNotify调用Test2合约中的notify方法,可以看到Test合约中的内容生效了</li>\n<li>这里有同学可能有疑问了,你这样的合约岂不是没有安全?拿到Test2合约地址,任何人新建一个合约就可以调用其合约的方法?是的,理论上是这样的.但是,凡事都有个但是哈.还记得我在之前的文章中关于eth中的权限如果验证吗?如果你看了那篇文章,那聪明的你一定知道该怎么做了哈  </li>\n<li><img src=\"/eospermission/per4.gif\" alt=\"shaokun\"></li>\n</ul>\n<h4 id=\"源码献上\"><a href=\"#源码献上\" class=\"headerlink\" title=\"源码献上\"></a>源码献上</h4><blockquote>\n<p><code>addressbook.cpp</code>,没什么说的,注意写法,变化的部分如果你认真阅读了应该知道变化在哪里</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n#include &lt;eosiolib/print.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\npublic:\n    using contract::contract;\n    addressbook(name reciever, name code, datastream&lt;const char*&gt; ds) : contract(reciever,code,ds){}\n\n    [[eosio::action]]\n    void upsert(name user, std::string first_name, uint64_t age){\n        require_auth(user);\n        address_index addresses(_code,_code.value);\n        auto itr = addresses.find(user.value);\n        if(itr == addresses.end()){\n            addresses.emplace(user,[&amp;](auto&amp; row){\n                row.key = user;\n                row.first_name = first_name;\n                row.age = age;\n            });\n            send_summary(user, &quot;emplace data&quot;);\n            counter(user,&quot;emplace&quot;);\n        } else {\n            addresses.modify(itr, user, [&amp;](auto&amp; row){\n                        row.first_name = first_name;\n                        row.age = age;\n            });\n            send_summary(user, &quot;modify data&quot;);\n            counter(user,&quot;modify&quot;);\n        }\n    }\n\n    [[eosio::action]]\n    void erase(name user){\n        require_auth(user);\n        address_index addresses(_self, _code.value);\n        auto itr = addresses.find(user.value);\n        eosio_assert(itr != addresses.end(),&quot;record not exist&quot;);\n        addresses.erase(itr);\n        // 调用inline action\n        send_summary(user, &quot; erase data&quot;);\n        counter(user,&quot;erase&quot;);\n    }\n\n    [[eosio::action]]\n    void notify(name user, std::string){\n        // inline action\n        require_auth(get_self());\n        require_recipient(user);\n    }\n\nprivate:\n    struct [[eosio::table]] person {\n        name key;\n        std::string first_name;\n        uint64_t age;\n\n        auto primary_key() const {\n            return key.value;\n        };\n    };\n    typedef multi_index&lt;&quot;person&quot;_n, person&gt; address_index;\n\n    // inline action的具体实现\n    void send_summary(name user, std::string msg){\n        action(\n            permission_level{get_self(),&quot;active&quot;_n},\n                get_self(),\n                &quot;notify&quot;_n,\n                std::make_tuple(user, name{user}.to_string() +msg)\n            ).send();\n    }\n    void counter(name user, std::string type){\n        action counter = action(\n            permission_level{get_self(),&quot;active&quot;_n},// 执行这个inline aciton所需要的权限,即本合约调用\n            &quot;shaokun11112&quot;_n,                       // 账号名称\n            &quot;count&quot;_n,                              // action 名称\n            std::make_tuple(user,type)              // 传递的参数\n            );\n        counter.send();\n    }\n};\nEOSIO_DISPATCH(addressbook,(upsert)(erase))\n</code></pre><blockquote>\n<p><code>adcounter.cpp</code> 注意其中的权限验证部分,其他没什么好说的</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;\n\nusing namespace eosio;\n\nclass [[eosio::contract]] adcounter: public eosio::contract {\npublic:\n    using contract::contract;\n    adcounter(name receiver, name code, datastream&lt;const char*&gt; ds):contract(receiver,code,ds),\n                                                                    counts(receiver,code.value){}\n\n    void count(name user, std::string type) {\n        // 设定这个方法的调用权限\n        // 只有 shaokun11111 这个账号部署的合约有这个权限更改这个合约的内容\n        require_auth(name(&quot;shaokun11111&quot;));\n        auto itr = counts.find(user.value);\n        if(itr == counts.end()){\n            counts.emplace(&quot;shaokun11111&quot;_n, [&amp;](auto&amp; row){\n                row.key = user;\n                row.emplaced = type == &quot;emplace&quot; ? 1 : 0;\n                row.modified = type == &quot;modify&quot; ? 1 : 0;\n                row.erased = type == &quot;erase&quot; ? 1 : 0;\n            });\n        } else {\n            counts.modify(itr,&quot;shaokun11111&quot;_n,[&amp;](auto&amp; row){\n                if (type == &quot;emplace&quot;)\n                {\n                    row.emplaced += 1;\n                }\n                if (type == &quot;modify&quot;)\n                {\n                    row.modified += 1;\n                }\n                if (type == &quot;erase&quot;)\n                {\n                    row.erased += 1;\n                }\n            });\n        }\n    }\nprivate:\n    struct [[eosio::table]] counter\n    {\n        name key;\n        uint64_t emplaced;\n        uint64_t modified;\n        uint64_t erased;\n\n        uint64_t primary_key() const {return key.value;}\n    };\n\n    typedef eosio::multi_index&lt;&quot;counter&quot;_n,counter&gt; counter_index;\n    counter_index counts;\n};\nEOSIO_DISPATCH(adcounter,(count));\n</code></pre><p>前端代码就不展示了,因为所有的操作都是在addressbook这个合约中进行操作的,adcounter只是展示了合约中的记录<br><a href=\"https://github.com/shaokun11/eosabout/tree/eos-inline-action2\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>建议各位同学一定要仔细敲一遍,虽然例子简单,但是再复杂的内容也是由这些简单的例子所产生的</li>\n<li>eos inline action的作用已经说完了.这样掌握之后,就可以写很多合约,壮大你的dapp了.inline action很重要的一点 是可以回滚交易,好好利用,发挥意想不到的作用</li>\n<li>话说还有个deferred action,有时间再和大家分享一下这货是怎使用了</li>\n<li>dapp的开发不仅仅是写合约,目前主要应用还是在web上.所以建议各位同学还是得了解一下js,node,webpack,react,css这些基础的概念和用法吧.不要多熟练,大概了解一下怎么用就好了</li>\n<li>还有一点,哪位同学知道eos中有类似eth中的event的功能,即合约主动推送信息给我们,我觉得这很重要.我觉得eosjs应该提供类似的功能呢.知道的同学麻烦告知一声</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#x69;&#x6e;&#103;&#64;&#103;&#x6d;&#x61;&#x69;&#108;&#46;&#99;&#x6f;&#x6d;</a><br>email_2: <a href=\"mailto:&#115;&#x6b;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#x6b;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#54;&#x33;&#46;&#x63;&#x6f;&#109;</a></p>\n"},{"title":"eos的dispatcher的使用(1)","date":"2019-01-12T01:44:26.000Z","_content":"\n#### 填坑\n> 上一篇文章我还在埋怨eos中的智能合约怎么没有以太坊类似的关键字payable呢?看来只有时间才会回答我的这个问题哈.也怪我图样图森破了\n\n#### 前言\n1. 想想距离上次写文章已经过去了快2个月了,而且已经翻了一年了,回想一下去年都做了什么呢?忘了.... 那是什么让我停下了呢?\n\t* 工作,毕竟要靠这个混口饭吃,心累...\n\t* 因为个人原因,周末都在往医院跑,\n\t* 这个eos的知识点是我周末和下班浏览得到的一点知识,主要是现在我在百度也没有找到比较合适的eos智能合约开发教程,所以就把我的这一路走过来的知识点记录下来.我的工作主要也是做智能合约的开发,所以了解一下也是为了未来失业了多一点选择.而目前公司都是基于以太坊和波场的,所以重点我还是会放到公司的项目中来\n\t* 至于其他的零碎时间都没有打开电脑了,只是补习了一些c++的知识,虽然我有java功底,但是对与没有常写c++的我来说,语法对我来说不是很难,难在如何动笔写,如何组织代码结构和写出c++的风格\n2. 在之前的文章中,我们得智能合约能够跑起来,也能够产生各种交互了.这也得益于官方的文档不断的更新,而我也止步于这个地方了,而对于官方智能合约的最后一篇文章,dispatcher的使用我选择了跳过.\n3. 近段时间和几个加我微信好友的开发者一起探讨上面的坑的时候,又回去阅读了几遍官方的教程,再结合Google,那暂时把得到的一点知识分享给大家,希望能够对你有帮助.\n\n\n[custom dispatchers](https://developers.eos.io/eosio-home/docs/writing-a-custom-dispatcher)\n\n#### 什么是EOSIO_DISPATCH\n> 本篇文章我们先跟着上面的链接,把dispatcher的基础信息弄明白,然后再谈其他的哈.而我也会根据自己的理解像大家解释一下,如果有不对的地方,希望各位同学帮我指正过来\n\n\tEOSIO_DISPATCH( myclass, (upsert)(notify)(erase) )\n\n相信这个大家都知道是c++的宏,帮组eos的合约分发action,那么这个宏的具体定义是什么呢?我们来到源码看看\n\n[dispatcher.cpp ](https://sourcegraph.com/github.com/EOSIO/eos/-/blob/contracts/eosiolib/dispatcher.hpp#L13:9-13:17) (这里的eos源码还是EOSIO_ABI,在cdt1.3后改为了EOS_DISPATCHER,只是宏名字改了,内容不变)\n\n\t/** \n\t * Convenient macro to create contract apply handler\n\t * To be able to use this macro, the contract needs to be derived from eosio::contract\n\t * \n\t * @brief Convenient macro to create contract apply handler \n\t * @param TYPE - The class name of the contract\n\t * @param MEMBERS - The sequence of available actions supported by this contract\n\t * \n\t * Example:\n\t * @code\n\t * EOSIO_ABI( eosio::bios, (setpriv)(setalimits)(setglimits)(setprods)(reqauth) )\n\t * @endcode\n\t */\n\t#define EOSIO_ABI( TYPE, MEMBERS ) \\\n\textern \"C\" { \\\n\t   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n\t      auto self = receiver; \\\n\t      if( action == N(onerror)) { \\\n\t         /* onerror is only valid if it is for the \"eosio\" code account and authorized by \"eosio\"'s \"active permission */ \\\n\t         eosio_assert(code == N(eosio), \"onerror action's are only valid from the \\\"eosio\\\" system account\"); \\\n\t      } \\\n\t      if( code == self || action == N(onerror) ) { \\\n\t         TYPE thiscontract( self ); \\\n\t         switch( action ) { \\\n\t            EOSIO_API( TYPE, MEMBERS ) \\\n\t         } \\\n\t         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n\t      } \\\n\t   } \\\n\t} \\\n\n看到了这个宏的具体实现,应该说这个函数在比较古老的版本,需要自己实现的,后面eos为了简化开发者的工作,才定义了这个宏.后面很多的宏比如说ACTION, CONTRACT也都是如此.这个宏的具体用法请看上面的注释,结果就是我们现在写合约的使用方式了.这个dispatcher.cpp建议大家可以深入了解一下,对后面的智能合约开发或者出现的bug都会有更加深一步的看法\n\n这里还有一个关键点就是,我们的智能合约如果要能够使用,必须提供一个apply的函数,而上面的宏就是帮助我们实现的这个apply函数.那么疑问来了,我是不是自己实现一个apply函数,不用上面的宏,也可以完成这个工作呢?  \n答案是可以的\n\n#### 自定义dispatcher 方式1\n>这里同样跟着官方的教程走\n\n\textern \"C\" {\n\t    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n\t        auto self = receiver;\n\t        if( code == self ) {\n\t          addressbook _addressbook(name(receiver));\n\t          switch(action) {\n\t            case name(\"upsert\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::upsert); \n\t              break;\n\t            case name(\"notify\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::notify); \n\t              break;\n\t            case name(\"erase\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::erase); \n\t              break;\n\t          }\n\t        }\n\t    }\n\t};\n\n1.\n \n* 可以看到apply函数接收三个参数,第一个receiver,合约的拥有者,\n* 第二个参数code,调用合约的发起人(这个参数我理解为通过什么方式调用的,如果直接通过调用本合约的,这个参数就是self,而如果通过其他智能合约比如说eosio.token,这个code就是eosio.token,或者其他合约的拥有者)\n* 第三个,执行合约的action,也就是合约的函数名,这个合约被标识为action\n2. if中判断如果合约的调用者是直接调用此合约的,即不是通过其他合约调用本合约的\n3. 实例化addressbook这个类,(这里有点疑惑的是,这个_addressbook在这里代表的是类,而addressbook才是对象,没有明白这是为什么,在c++ 中实例化一个类不是 T t 这种形式吗?),这个实例化比较古老了,只接受了一个参数,在cdt1.3要接受三个参数,请注意\n4. 一个switch结构,根据对应的action的名字分发对应的动作\n5. 使用eosio::execute_action执行对应的action\n\t* 这里大家又看到了一个新的东西了,不要怕,我们看看是什么\n\t\n\t\t\t\t  /**\n\t\t\t    * @defgroup dispatcher Dispatcher API\n\t\t\t    * @brief Defines functions to dispatch action to proper action handler inside a contract\n\t\t\t    * @ingroup contractdev\n\t\t\t    */\n\t\t\t   \n\t\t\t   /**\n\t\t\t    * @defgroup dispatchercpp Dispatcher C++ API\n\t\t\t    * @brief Defines C++ functions to dispatch action to proper action handler inside a contract\n\t\t\t    * @ingroup dispatcher\n\t\t\t    * @{\n\t\t\t    */\n\t\t\t\n\t\t\t   /**\n\t\t\t    * Unpack the received action and execute the correponding action handler\n\t\t\t    * \n\t\t\t    * @brief Unpack the received action and execute the correponding action handler\n\t\t\t    * @tparam T - The contract class that has the correponding action handler, this contract should be derived from eosio::contract\n\t\t\t    * @tparam Q - The namespace of the action handler function \n\t\t\t    * @tparam Args - The arguments that the action handler accepts, i.e. members of the action\n\t\t\t    * @param obj - The contract object that has the correponding action handler\n\t\t\t    * @param func - The action handler\n\t\t\t    * @return true  \n\t\t\t    */\n\t\t\t   template<typename T, typename Q, typename... Args>\n\t\t\t   bool execute_action( T* obj, void (Q::*func)(Args...)  ) {\n\t\t\t   ...\n\t\t\t   }\n\t\t\t   \n\t* 这里我把具体实现删掉了,只留下了注释和方法签名,可以看到是一个模板函数,那我们就看看他的作用是什么了\n\t\n\t\t\tUnpack the received action and execute the correponding action handler\n\t\t\t解压缩收到的操作并执行相应的操作处理程序\n\t* 再结合上面的具体的参数的用法,就知道了原来又是一个dispatcher的帮助函数,帮我们去分发对应的action,只是传递的方式变了.\n\t* 很好,现在我们已经抛弃了系统提供的EOSIO_DISPATCH而自己实现了这个apply函数,至于能不能用呢?那我们接下来试试了\n\t\n#### 自定义dispatcher 方式1 结果展示\n> 本次我们直接copy的官方的addressbook的源码,然后使用自己实现apply函数\n> 精简一些不必要的参数,实现功能为主\n上面我说过,由于版本的原因,目前的版本我们需要在实例化addressbook的时候传入三个参数\n\t\n\t addressbook _addressbook(name(receiver),name(code),datastream<const char*>(nullptr,0));\n\t \n> 最终改造了的代码如下\n\n```\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/print.hpp>\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\n\npublic:\n  using contract::contract;\n  \n  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}\n\n  [[eosio::action]]\n  void upsert(name user, std::string first_name, std::string last_name) {\n    require_auth(user);\n    address_index addresses(_code, _code.value);\n    auto iterator = addresses.find(user.value);\n    if( iterator == addresses.end() )\n    {\n      addresses.emplace(user, [&]( auto& row ) {\n       row.key = user;\n       row.first_name = first_name;\n       row.last_name = last_name;\n      });\n      send_summary(user, \" successfully emplaced record to addressbook\");\n    }\n    else {\n      std::string changes;\n      addresses.modify(iterator, user, [&]( auto& row ) {\n        row.key = user;\n        row.first_name = first_name;\n        row.last_name = last_name;\n      });\n      send_summary(user, \" successfully modified record to addressbook\");\n    }\n  }\n\n  [[eosio::action]]\n  void erase(name user) {\n    require_auth(user);\n\n    address_index addresses(_self, _code.value);\n\n    auto iterator = addresses.find(user.value);\n    eosio_assert(iterator != addresses.end(), \"Record does not exist\");\n    addresses.erase(iterator);\n    send_summary(user, \" successfully erased record from addressbook\");\n  }\n\n  [[eosio::action]]\n  void notify(name user, std::string msg) {\n    require_auth(get_self());\n    require_recipient(user);\n  }\n\nprivate:\n  struct [[eosio::table]] person {\n    name key;\n    std::string first_name;\n    std::string last_name;\n    uint64_t primary_key() const { return key.value; }\n  };\n\n  void send_summary(name user, std::string message) {\n    action(\n      permission_level{get_self(),\"active\"_n},\n      get_self(),\n      \"notify\"_n,\n      std::make_tuple(user, name{user}.to_string() + message)\n    ).send();\n  };\n\n  typedef eosio::multi_index<\"people\"_n, person> address_index;\n  \n};\n\nextern \"C\" {\n    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n        auto self = receiver;\n        if( code == self ) {\n          addressbook _addressbook(name(receiver),name(code),datastream<const char*>(nullptr,0));\n          switch(action) {\n            case name(\"upsert\").value: \n              execute_action(name(receiver), name(code), &addressbook::upsert); \n              break;\n            case name(\"notify\").value: \n              execute_action(name(receiver), name(code), &addressbook::notify); \n              break;\n            case name(\"erase\").value: \n              execute_action(name(receiver), name(code), &addressbook::erase); \n              break;\n          }\n        }\n    }\n};\n```\n\n#### 结果展示\n1. 此次合约部署在kylin上的shaokun11114账号上可以看到我们也完美实现了数据增加和删除\n\n![shaokun](/img_eos1/eos_react8.gif)\n\n2. 去kylin查看结果,可以看到我们得交易记录,其中的notify也可以看到,说明apply函数正常使用\n\n![shaokun](/img_eos1/eos15.png)\n\n[源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-01)\n\n#### 总结\n1. 这就完了?当然没有,这篇文章只是简单的和大家一起走走官网的dispatcher,当然还没有走完,如果只是这样写了能够实现功能那和用eos提供的宏没什么区别了呢\n2. 我建议各位同学接触到错误不要慌,也不要急,各位可以先自己看看报错误的信息提示,可以把这个粘贴到Google上找一下答案,这样自己找寻到的答案记忆会深刻许多\n3. 接下来将我进一步跟着官网走,把剩下的一点点讲明白,而这才是dispatcher的真正用法呢.可以解决文章开头提到的payable的问题呢\n4. 谢谢大家的浏览,希望有发现错误的同学可以加上我微信帮我指出来,再次感谢.\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解4.md","raw":"---\ntitle: eos的dispatcher的使用(1)\ndate: 2019-01-12 09:44:26\n---\n\n#### 填坑\n> 上一篇文章我还在埋怨eos中的智能合约怎么没有以太坊类似的关键字payable呢?看来只有时间才会回答我的这个问题哈.也怪我图样图森破了\n\n#### 前言\n1. 想想距离上次写文章已经过去了快2个月了,而且已经翻了一年了,回想一下去年都做了什么呢?忘了.... 那是什么让我停下了呢?\n\t* 工作,毕竟要靠这个混口饭吃,心累...\n\t* 因为个人原因,周末都在往医院跑,\n\t* 这个eos的知识点是我周末和下班浏览得到的一点知识,主要是现在我在百度也没有找到比较合适的eos智能合约开发教程,所以就把我的这一路走过来的知识点记录下来.我的工作主要也是做智能合约的开发,所以了解一下也是为了未来失业了多一点选择.而目前公司都是基于以太坊和波场的,所以重点我还是会放到公司的项目中来\n\t* 至于其他的零碎时间都没有打开电脑了,只是补习了一些c++的知识,虽然我有java功底,但是对与没有常写c++的我来说,语法对我来说不是很难,难在如何动笔写,如何组织代码结构和写出c++的风格\n2. 在之前的文章中,我们得智能合约能够跑起来,也能够产生各种交互了.这也得益于官方的文档不断的更新,而我也止步于这个地方了,而对于官方智能合约的最后一篇文章,dispatcher的使用我选择了跳过.\n3. 近段时间和几个加我微信好友的开发者一起探讨上面的坑的时候,又回去阅读了几遍官方的教程,再结合Google,那暂时把得到的一点知识分享给大家,希望能够对你有帮助.\n\n\n[custom dispatchers](https://developers.eos.io/eosio-home/docs/writing-a-custom-dispatcher)\n\n#### 什么是EOSIO_DISPATCH\n> 本篇文章我们先跟着上面的链接,把dispatcher的基础信息弄明白,然后再谈其他的哈.而我也会根据自己的理解像大家解释一下,如果有不对的地方,希望各位同学帮我指正过来\n\n\tEOSIO_DISPATCH( myclass, (upsert)(notify)(erase) )\n\n相信这个大家都知道是c++的宏,帮组eos的合约分发action,那么这个宏的具体定义是什么呢?我们来到源码看看\n\n[dispatcher.cpp ](https://sourcegraph.com/github.com/EOSIO/eos/-/blob/contracts/eosiolib/dispatcher.hpp#L13:9-13:17) (这里的eos源码还是EOSIO_ABI,在cdt1.3后改为了EOS_DISPATCHER,只是宏名字改了,内容不变)\n\n\t/** \n\t * Convenient macro to create contract apply handler\n\t * To be able to use this macro, the contract needs to be derived from eosio::contract\n\t * \n\t * @brief Convenient macro to create contract apply handler \n\t * @param TYPE - The class name of the contract\n\t * @param MEMBERS - The sequence of available actions supported by this contract\n\t * \n\t * Example:\n\t * @code\n\t * EOSIO_ABI( eosio::bios, (setpriv)(setalimits)(setglimits)(setprods)(reqauth) )\n\t * @endcode\n\t */\n\t#define EOSIO_ABI( TYPE, MEMBERS ) \\\n\textern \"C\" { \\\n\t   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n\t      auto self = receiver; \\\n\t      if( action == N(onerror)) { \\\n\t         /* onerror is only valid if it is for the \"eosio\" code account and authorized by \"eosio\"'s \"active permission */ \\\n\t         eosio_assert(code == N(eosio), \"onerror action's are only valid from the \\\"eosio\\\" system account\"); \\\n\t      } \\\n\t      if( code == self || action == N(onerror) ) { \\\n\t         TYPE thiscontract( self ); \\\n\t         switch( action ) { \\\n\t            EOSIO_API( TYPE, MEMBERS ) \\\n\t         } \\\n\t         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n\t      } \\\n\t   } \\\n\t} \\\n\n看到了这个宏的具体实现,应该说这个函数在比较古老的版本,需要自己实现的,后面eos为了简化开发者的工作,才定义了这个宏.后面很多的宏比如说ACTION, CONTRACT也都是如此.这个宏的具体用法请看上面的注释,结果就是我们现在写合约的使用方式了.这个dispatcher.cpp建议大家可以深入了解一下,对后面的智能合约开发或者出现的bug都会有更加深一步的看法\n\n这里还有一个关键点就是,我们的智能合约如果要能够使用,必须提供一个apply的函数,而上面的宏就是帮助我们实现的这个apply函数.那么疑问来了,我是不是自己实现一个apply函数,不用上面的宏,也可以完成这个工作呢?  \n答案是可以的\n\n#### 自定义dispatcher 方式1\n>这里同样跟着官方的教程走\n\n\textern \"C\" {\n\t    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n\t        auto self = receiver;\n\t        if( code == self ) {\n\t          addressbook _addressbook(name(receiver));\n\t          switch(action) {\n\t            case name(\"upsert\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::upsert); \n\t              break;\n\t            case name(\"notify\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::notify); \n\t              break;\n\t            case name(\"erase\").value: \n\t              execute_action(name(receiver), name(code), &addressbook::erase); \n\t              break;\n\t          }\n\t        }\n\t    }\n\t};\n\n1.\n \n* 可以看到apply函数接收三个参数,第一个receiver,合约的拥有者,\n* 第二个参数code,调用合约的发起人(这个参数我理解为通过什么方式调用的,如果直接通过调用本合约的,这个参数就是self,而如果通过其他智能合约比如说eosio.token,这个code就是eosio.token,或者其他合约的拥有者)\n* 第三个,执行合约的action,也就是合约的函数名,这个合约被标识为action\n2. if中判断如果合约的调用者是直接调用此合约的,即不是通过其他合约调用本合约的\n3. 实例化addressbook这个类,(这里有点疑惑的是,这个_addressbook在这里代表的是类,而addressbook才是对象,没有明白这是为什么,在c++ 中实例化一个类不是 T t 这种形式吗?),这个实例化比较古老了,只接受了一个参数,在cdt1.3要接受三个参数,请注意\n4. 一个switch结构,根据对应的action的名字分发对应的动作\n5. 使用eosio::execute_action执行对应的action\n\t* 这里大家又看到了一个新的东西了,不要怕,我们看看是什么\n\t\n\t\t\t\t  /**\n\t\t\t    * @defgroup dispatcher Dispatcher API\n\t\t\t    * @brief Defines functions to dispatch action to proper action handler inside a contract\n\t\t\t    * @ingroup contractdev\n\t\t\t    */\n\t\t\t   \n\t\t\t   /**\n\t\t\t    * @defgroup dispatchercpp Dispatcher C++ API\n\t\t\t    * @brief Defines C++ functions to dispatch action to proper action handler inside a contract\n\t\t\t    * @ingroup dispatcher\n\t\t\t    * @{\n\t\t\t    */\n\t\t\t\n\t\t\t   /**\n\t\t\t    * Unpack the received action and execute the correponding action handler\n\t\t\t    * \n\t\t\t    * @brief Unpack the received action and execute the correponding action handler\n\t\t\t    * @tparam T - The contract class that has the correponding action handler, this contract should be derived from eosio::contract\n\t\t\t    * @tparam Q - The namespace of the action handler function \n\t\t\t    * @tparam Args - The arguments that the action handler accepts, i.e. members of the action\n\t\t\t    * @param obj - The contract object that has the correponding action handler\n\t\t\t    * @param func - The action handler\n\t\t\t    * @return true  \n\t\t\t    */\n\t\t\t   template<typename T, typename Q, typename... Args>\n\t\t\t   bool execute_action( T* obj, void (Q::*func)(Args...)  ) {\n\t\t\t   ...\n\t\t\t   }\n\t\t\t   \n\t* 这里我把具体实现删掉了,只留下了注释和方法签名,可以看到是一个模板函数,那我们就看看他的作用是什么了\n\t\n\t\t\tUnpack the received action and execute the correponding action handler\n\t\t\t解压缩收到的操作并执行相应的操作处理程序\n\t* 再结合上面的具体的参数的用法,就知道了原来又是一个dispatcher的帮助函数,帮我们去分发对应的action,只是传递的方式变了.\n\t* 很好,现在我们已经抛弃了系统提供的EOSIO_DISPATCH而自己实现了这个apply函数,至于能不能用呢?那我们接下来试试了\n\t\n#### 自定义dispatcher 方式1 结果展示\n> 本次我们直接copy的官方的addressbook的源码,然后使用自己实现apply函数\n> 精简一些不必要的参数,实现功能为主\n上面我说过,由于版本的原因,目前的版本我们需要在实例化addressbook的时候传入三个参数\n\t\n\t addressbook _addressbook(name(receiver),name(code),datastream<const char*>(nullptr,0));\n\t \n> 最终改造了的代码如下\n\n```\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/print.hpp>\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\n\npublic:\n  using contract::contract;\n  \n  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}\n\n  [[eosio::action]]\n  void upsert(name user, std::string first_name, std::string last_name) {\n    require_auth(user);\n    address_index addresses(_code, _code.value);\n    auto iterator = addresses.find(user.value);\n    if( iterator == addresses.end() )\n    {\n      addresses.emplace(user, [&]( auto& row ) {\n       row.key = user;\n       row.first_name = first_name;\n       row.last_name = last_name;\n      });\n      send_summary(user, \" successfully emplaced record to addressbook\");\n    }\n    else {\n      std::string changes;\n      addresses.modify(iterator, user, [&]( auto& row ) {\n        row.key = user;\n        row.first_name = first_name;\n        row.last_name = last_name;\n      });\n      send_summary(user, \" successfully modified record to addressbook\");\n    }\n  }\n\n  [[eosio::action]]\n  void erase(name user) {\n    require_auth(user);\n\n    address_index addresses(_self, _code.value);\n\n    auto iterator = addresses.find(user.value);\n    eosio_assert(iterator != addresses.end(), \"Record does not exist\");\n    addresses.erase(iterator);\n    send_summary(user, \" successfully erased record from addressbook\");\n  }\n\n  [[eosio::action]]\n  void notify(name user, std::string msg) {\n    require_auth(get_self());\n    require_recipient(user);\n  }\n\nprivate:\n  struct [[eosio::table]] person {\n    name key;\n    std::string first_name;\n    std::string last_name;\n    uint64_t primary_key() const { return key.value; }\n  };\n\n  void send_summary(name user, std::string message) {\n    action(\n      permission_level{get_self(),\"active\"_n},\n      get_self(),\n      \"notify\"_n,\n      std::make_tuple(user, name{user}.to_string() + message)\n    ).send();\n  };\n\n  typedef eosio::multi_index<\"people\"_n, person> address_index;\n  \n};\n\nextern \"C\" {\n    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n        auto self = receiver;\n        if( code == self ) {\n          addressbook _addressbook(name(receiver),name(code),datastream<const char*>(nullptr,0));\n          switch(action) {\n            case name(\"upsert\").value: \n              execute_action(name(receiver), name(code), &addressbook::upsert); \n              break;\n            case name(\"notify\").value: \n              execute_action(name(receiver), name(code), &addressbook::notify); \n              break;\n            case name(\"erase\").value: \n              execute_action(name(receiver), name(code), &addressbook::erase); \n              break;\n          }\n        }\n    }\n};\n```\n\n#### 结果展示\n1. 此次合约部署在kylin上的shaokun11114账号上可以看到我们也完美实现了数据增加和删除\n\n![shaokun](/img_eos1/eos_react8.gif)\n\n2. 去kylin查看结果,可以看到我们得交易记录,其中的notify也可以看到,说明apply函数正常使用\n\n![shaokun](/img_eos1/eos15.png)\n\n[源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-01)\n\n#### 总结\n1. 这就完了?当然没有,这篇文章只是简单的和大家一起走走官网的dispatcher,当然还没有走完,如果只是这样写了能够实现功能那和用eos提供的宏没什么区别了呢\n2. 我建议各位同学接触到错误不要慌,也不要急,各位可以先自己看看报错误的信息提示,可以把这个粘贴到Google上找一下答案,这样自己找寻到的答案记忆会深刻许多\n3. 接下来将我进一步跟着官网走,把剩下的一点点讲明白,而这才是dispatcher的真正用法呢.可以解决文章开头提到的payable的问题呢\n4. 谢谢大家的浏览,希望有发现错误的同学可以加上我微信帮我指出来,再次感谢.\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解4","published":1,"updated":"2019-02-18T13:13:08.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52s000hnh7sf82j6lel","content":"<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><blockquote>\n<p>上一篇文章我还在埋怨eos中的智能合约怎么没有以太坊类似的关键字payable呢?看来只有时间才会回答我的这个问题哈.也怪我图样图森破了</p>\n</blockquote>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ol>\n<li>想想距离上次写文章已经过去了快2个月了,而且已经翻了一年了,回想一下去年都做了什么呢?忘了…. 那是什么让我停下了呢?<ul>\n<li>工作,毕竟要靠这个混口饭吃,心累…</li>\n<li>因为个人原因,周末都在往医院跑,</li>\n<li>这个eos的知识点是我周末和下班浏览得到的一点知识,主要是现在我在百度也没有找到比较合适的eos智能合约开发教程,所以就把我的这一路走过来的知识点记录下来.我的工作主要也是做智能合约的开发,所以了解一下也是为了未来失业了多一点选择.而目前公司都是基于以太坊和波场的,所以重点我还是会放到公司的项目中来</li>\n<li>至于其他的零碎时间都没有打开电脑了,只是补习了一些c++的知识,虽然我有java功底,但是对与没有常写c++的我来说,语法对我来说不是很难,难在如何动笔写,如何组织代码结构和写出c++的风格</li>\n</ul>\n</li>\n<li>在之前的文章中,我们得智能合约能够跑起来,也能够产生各种交互了.这也得益于官方的文档不断的更新,而我也止步于这个地方了,而对于官方智能合约的最后一篇文章,dispatcher的使用我选择了跳过.</li>\n<li>近段时间和几个加我微信好友的开发者一起探讨上面的坑的时候,又回去阅读了几遍官方的教程,再结合Google,那暂时把得到的一点知识分享给大家,希望能够对你有帮助.</li>\n</ol>\n<p><a href=\"https://developers.eos.io/eosio-home/docs/writing-a-custom-dispatcher\" target=\"_blank\" rel=\"noopener\">custom dispatchers</a></p>\n<h4 id=\"什么是EOSIO-DISPATCH\"><a href=\"#什么是EOSIO-DISPATCH\" class=\"headerlink\" title=\"什么是EOSIO_DISPATCH\"></a>什么是EOSIO_DISPATCH</h4><blockquote>\n<p>本篇文章我们先跟着上面的链接,把dispatcher的基础信息弄明白,然后再谈其他的哈.而我也会根据自己的理解像大家解释一下,如果有不对的地方,希望各位同学帮我指正过来</p>\n</blockquote>\n<pre><code>EOSIO_DISPATCH( myclass, (upsert)(notify)(erase) )\n</code></pre><p>相信这个大家都知道是c++的宏,帮组eos的合约分发action,那么这个宏的具体定义是什么呢?我们来到源码看看</p>\n<p><a href=\"https://sourcegraph.com/github.com/EOSIO/eos/-/blob/contracts/eosiolib/dispatcher.hpp#L13:9-13:17\" target=\"_blank\" rel=\"noopener\">dispatcher.cpp </a> (这里的eos源码还是EOSIO_ABI,在cdt1.3后改为了EOS_DISPATCHER,只是宏名字改了,内容不变)</p>\n<pre><code>/** \n * Convenient macro to create contract apply handler\n * To be able to use this macro, the contract needs to be derived from eosio::contract\n * \n * @brief Convenient macro to create contract apply handler \n * @param TYPE - The class name of the contract\n * @param MEMBERS - The sequence of available actions supported by this contract\n * \n * Example:\n * @code\n * EOSIO_ABI( eosio::bios, (setpriv)(setalimits)(setglimits)(setprods)(reqauth) )\n * @endcode\n */\n#define EOSIO_ABI( TYPE, MEMBERS ) \\\nextern &quot;C&quot; { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      auto self = receiver; \\\n      if( action == N(onerror)) { \\\n         /* onerror is only valid if it is for the &quot;eosio&quot; code account and authorized by &quot;eosio&quot;&apos;s &quot;active permission */ \\\n         eosio_assert(code == N(eosio), &quot;onerror action&apos;s are only valid from the \\&quot;eosio\\&quot; system account&quot;); \\\n      } \\\n      if( code == self || action == N(onerror) ) { \\\n         TYPE thiscontract( self ); \\\n         switch( action ) { \\\n            EOSIO_API( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n</code></pre><p>看到了这个宏的具体实现,应该说这个函数在比较古老的版本,需要自己实现的,后面eos为了简化开发者的工作,才定义了这个宏.后面很多的宏比如说ACTION, CONTRACT也都是如此.这个宏的具体用法请看上面的注释,结果就是我们现在写合约的使用方式了.这个dispatcher.cpp建议大家可以深入了解一下,对后面的智能合约开发或者出现的bug都会有更加深一步的看法</p>\n<p>这里还有一个关键点就是,我们的智能合约如果要能够使用,必须提供一个apply的函数,而上面的宏就是帮助我们实现的这个apply函数.那么疑问来了,我是不是自己实现一个apply函数,不用上面的宏,也可以完成这个工作呢?<br>答案是可以的</p>\n<h4 id=\"自定义dispatcher-方式1\"><a href=\"#自定义dispatcher-方式1\" class=\"headerlink\" title=\"自定义dispatcher 方式1\"></a>自定义dispatcher 方式1</h4><blockquote>\n<p>这里同样跟着官方的教程走</p>\n</blockquote>\n<pre><code>extern &quot;C&quot; {\n    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n        auto self = receiver;\n        if( code == self ) {\n          addressbook _addressbook(name(receiver));\n          switch(action) {\n            case name(&quot;upsert&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::upsert); \n              break;\n            case name(&quot;notify&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::notify); \n              break;\n            case name(&quot;erase&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::erase); \n              break;\n          }\n        }\n    }\n};\n</code></pre><p>1.</p>\n<ul>\n<li>可以看到apply函数接收三个参数,第一个receiver,合约的拥有者,</li>\n<li>第二个参数code,调用合约的发起人(这个参数我理解为通过什么方式调用的,如果直接通过调用本合约的,这个参数就是self,而如果通过其他智能合约比如说eosio.token,这个code就是eosio.token,或者其他合约的拥有者)</li>\n<li>第三个,执行合约的action,也就是合约的函数名,这个合约被标识为action</li>\n</ul>\n<ol start=\"2\">\n<li>if中判断如果合约的调用者是直接调用此合约的,即不是通过其他合约调用本合约的</li>\n<li>实例化addressbook这个类,(这里有点疑惑的是,这个_addressbook在这里代表的是类,而addressbook才是对象,没有明白这是为什么,在c++ 中实例化一个类不是 T t 这种形式吗?),这个实例化比较古老了,只接受了一个参数,在cdt1.3要接受三个参数,请注意</li>\n<li>一个switch结构,根据对应的action的名字分发对应的动作</li>\n<li><p>使用eosio::execute_action执行对应的action</p>\n<ul>\n<li><p>这里大家又看到了一个新的东西了,不要怕,我们看看是什么</p>\n<pre><code>   /**\n * @defgroup dispatcher Dispatcher API\n * @brief Defines functions to dispatch action to proper action handler inside a contract\n * @ingroup contractdev\n */\n\n/**\n * @defgroup dispatchercpp Dispatcher C++ API\n * @brief Defines C++ functions to dispatch action to proper action handler inside a contract\n * @ingroup dispatcher\n * @{\n */\n\n/**\n * Unpack the received action and execute the correponding action handler\n * \n * @brief Unpack the received action and execute the correponding action handler\n * @tparam T - The contract class that has the correponding action handler, this contract should be derived from eosio::contract\n * @tparam Q - The namespace of the action handler function \n * @tparam Args - The arguments that the action handler accepts, i.e. members of the action\n * @param obj - The contract object that has the correponding action handler\n * @param func - The action handler\n * @return true  \n */\ntemplate&lt;typename T, typename Q, typename... Args&gt;\nbool execute_action( T* obj, void (Q::*func)(Args...)  ) {\n...\n}\n</code></pre></li>\n<li><p>这里我把具体实现删掉了,只留下了注释和方法签名,可以看到是一个模板函数,那我们就看看他的作用是什么了</p>\n<pre><code>Unpack the received action and execute the correponding action handler\n解压缩收到的操作并执行相应的操作处理程序\n</code></pre></li>\n<li>再结合上面的具体的参数的用法,就知道了原来又是一个dispatcher的帮助函数,帮我们去分发对应的action,只是传递的方式变了.</li>\n<li>很好,现在我们已经抛弃了系统提供的EOSIO_DISPATCH而自己实现了这个apply函数,至于能不能用呢?那我们接下来试试了</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"自定义dispatcher-方式1-结果展示\"><a href=\"#自定义dispatcher-方式1-结果展示\" class=\"headerlink\" title=\"自定义dispatcher 方式1 结果展示\"></a>自定义dispatcher 方式1 结果展示</h4><blockquote>\n<p>本次我们直接copy的官方的addressbook的源码,然后使用自己实现apply函数<br>精简一些不必要的参数,实现功能为主<br>上面我说过,由于版本的原因,目前的版本我们需要在实例化addressbook的时候传入三个参数</p>\n</blockquote>\n<pre><code>addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));\n</code></pre><blockquote>\n<p>最终改造了的代码如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;eosiolib/eosio.hpp&gt;</span><br><span class=\"line\">#include &lt;eosiolib/print.hpp&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace eosio;</span><br><span class=\"line\"></span><br><span class=\"line\">class [[eosio::contract]] addressbook : public eosio::contract &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">  using contract::contract;</span><br><span class=\"line\">  </span><br><span class=\"line\">  addressbook(name receiver, name code,  datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void upsert(name user, std::string first_name, std::string last_name) &#123;</span><br><span class=\"line\">    require_auth(user);</span><br><span class=\"line\">    address_index addresses(_code, _code.value);</span><br><span class=\"line\">    auto iterator = addresses.find(user.value);</span><br><span class=\"line\">    if( iterator == addresses.end() )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      addresses.emplace(user, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">       row.key = user;</span><br><span class=\"line\">       row.first_name = first_name;</span><br><span class=\"line\">       row.last_name = last_name;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      send_summary(user, &quot; successfully emplaced record to addressbook&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">      std::string changes;</span><br><span class=\"line\">      addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">        row.key = user;</span><br><span class=\"line\">        row.first_name = first_name;</span><br><span class=\"line\">        row.last_name = last_name;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      send_summary(user, &quot; successfully modified record to addressbook&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void erase(name user) &#123;</span><br><span class=\"line\">    require_auth(user);</span><br><span class=\"line\"></span><br><span class=\"line\">    address_index addresses(_self, _code.value);</span><br><span class=\"line\"></span><br><span class=\"line\">    auto iterator = addresses.find(user.value);</span><br><span class=\"line\">    eosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);</span><br><span class=\"line\">    addresses.erase(iterator);</span><br><span class=\"line\">    send_summary(user, &quot; successfully erased record from addressbook&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void notify(name user, std::string msg) &#123;</span><br><span class=\"line\">    require_auth(get_self());</span><br><span class=\"line\">    require_recipient(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">  struct [[eosio::table]] person &#123;</span><br><span class=\"line\">    name key;</span><br><span class=\"line\">    std::string first_name;</span><br><span class=\"line\">    std::string last_name;</span><br><span class=\"line\">    uint64_t primary_key() const &#123; return key.value; &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  void send_summary(name user, std::string message) &#123;</span><br><span class=\"line\">    action(</span><br><span class=\"line\">      permission_level&#123;get_self(),&quot;active&quot;_n&#125;,</span><br><span class=\"line\">      get_self(),</span><br><span class=\"line\">      &quot;notify&quot;_n,</span><br><span class=\"line\">      std::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class=\"line\">    ).send();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  typedef eosio::multi_index&lt;&quot;people&quot;_n, person&gt; address_index;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">extern &quot;C&quot; &#123;</span><br><span class=\"line\">    void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class=\"line\">        auto self = receiver;</span><br><span class=\"line\">        if( code == self ) &#123;</span><br><span class=\"line\">          addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));</span><br><span class=\"line\">          switch(action) &#123;</span><br><span class=\"line\">            case name(&quot;upsert&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::upsert); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">            case name(&quot;notify&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::notify); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">            case name(&quot;erase&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::erase); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h4><ol>\n<li>此次合约部署在kylin上的shaokun11114账号上可以看到我们也完美实现了数据增加和删除</li>\n</ol>\n<p><img src=\"/img_eos1/eos_react8.gif\" alt=\"shaokun\"></p>\n<ol start=\"2\">\n<li>去kylin查看结果,可以看到我们得交易记录,其中的notify也可以看到,说明apply函数正常使用</li>\n</ol>\n<p><img src=\"/img_eos1/eos15.png\" alt=\"shaokun\"></p>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-01\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>这就完了?当然没有,这篇文章只是简单的和大家一起走走官网的dispatcher,当然还没有走完,如果只是这样写了能够实现功能那和用eos提供的宏没什么区别了呢</li>\n<li>我建议各位同学接触到错误不要慌,也不要急,各位可以先自己看看报错误的信息提示,可以把这个粘贴到Google上找一下答案,这样自己找寻到的答案记忆会深刻许多</li>\n<li>接下来将我进一步跟着官网走,把剩下的一点点讲明白,而这才是dispatcher的真正用法呢.可以解决文章开头提到的payable的问题呢</li>\n<li>谢谢大家的浏览,希望有发现错误的同学可以加上我微信帮我指出来,再次感谢.</li>\n</ol>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#x6f;&#107;&#117;&#110;&#105;&#110;&#103;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#x6f;&#107;&#117;&#110;&#105;&#110;&#103;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><blockquote>\n<p>上一篇文章我还在埋怨eos中的智能合约怎么没有以太坊类似的关键字payable呢?看来只有时间才会回答我的这个问题哈.也怪我图样图森破了</p>\n</blockquote>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ol>\n<li>想想距离上次写文章已经过去了快2个月了,而且已经翻了一年了,回想一下去年都做了什么呢?忘了…. 那是什么让我停下了呢?<ul>\n<li>工作,毕竟要靠这个混口饭吃,心累…</li>\n<li>因为个人原因,周末都在往医院跑,</li>\n<li>这个eos的知识点是我周末和下班浏览得到的一点知识,主要是现在我在百度也没有找到比较合适的eos智能合约开发教程,所以就把我的这一路走过来的知识点记录下来.我的工作主要也是做智能合约的开发,所以了解一下也是为了未来失业了多一点选择.而目前公司都是基于以太坊和波场的,所以重点我还是会放到公司的项目中来</li>\n<li>至于其他的零碎时间都没有打开电脑了,只是补习了一些c++的知识,虽然我有java功底,但是对与没有常写c++的我来说,语法对我来说不是很难,难在如何动笔写,如何组织代码结构和写出c++的风格</li>\n</ul>\n</li>\n<li>在之前的文章中,我们得智能合约能够跑起来,也能够产生各种交互了.这也得益于官方的文档不断的更新,而我也止步于这个地方了,而对于官方智能合约的最后一篇文章,dispatcher的使用我选择了跳过.</li>\n<li>近段时间和几个加我微信好友的开发者一起探讨上面的坑的时候,又回去阅读了几遍官方的教程,再结合Google,那暂时把得到的一点知识分享给大家,希望能够对你有帮助.</li>\n</ol>\n<p><a href=\"https://developers.eos.io/eosio-home/docs/writing-a-custom-dispatcher\" target=\"_blank\" rel=\"noopener\">custom dispatchers</a></p>\n<h4 id=\"什么是EOSIO-DISPATCH\"><a href=\"#什么是EOSIO-DISPATCH\" class=\"headerlink\" title=\"什么是EOSIO_DISPATCH\"></a>什么是EOSIO_DISPATCH</h4><blockquote>\n<p>本篇文章我们先跟着上面的链接,把dispatcher的基础信息弄明白,然后再谈其他的哈.而我也会根据自己的理解像大家解释一下,如果有不对的地方,希望各位同学帮我指正过来</p>\n</blockquote>\n<pre><code>EOSIO_DISPATCH( myclass, (upsert)(notify)(erase) )\n</code></pre><p>相信这个大家都知道是c++的宏,帮组eos的合约分发action,那么这个宏的具体定义是什么呢?我们来到源码看看</p>\n<p><a href=\"https://sourcegraph.com/github.com/EOSIO/eos/-/blob/contracts/eosiolib/dispatcher.hpp#L13:9-13:17\" target=\"_blank\" rel=\"noopener\">dispatcher.cpp </a> (这里的eos源码还是EOSIO_ABI,在cdt1.3后改为了EOS_DISPATCHER,只是宏名字改了,内容不变)</p>\n<pre><code>/** \n * Convenient macro to create contract apply handler\n * To be able to use this macro, the contract needs to be derived from eosio::contract\n * \n * @brief Convenient macro to create contract apply handler \n * @param TYPE - The class name of the contract\n * @param MEMBERS - The sequence of available actions supported by this contract\n * \n * Example:\n * @code\n * EOSIO_ABI( eosio::bios, (setpriv)(setalimits)(setglimits)(setprods)(reqauth) )\n * @endcode\n */\n#define EOSIO_ABI( TYPE, MEMBERS ) \\\nextern &quot;C&quot; { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      auto self = receiver; \\\n      if( action == N(onerror)) { \\\n         /* onerror is only valid if it is for the &quot;eosio&quot; code account and authorized by &quot;eosio&quot;&apos;s &quot;active permission */ \\\n         eosio_assert(code == N(eosio), &quot;onerror action&apos;s are only valid from the \\&quot;eosio\\&quot; system account&quot;); \\\n      } \\\n      if( code == self || action == N(onerror) ) { \\\n         TYPE thiscontract( self ); \\\n         switch( action ) { \\\n            EOSIO_API( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n</code></pre><p>看到了这个宏的具体实现,应该说这个函数在比较古老的版本,需要自己实现的,后面eos为了简化开发者的工作,才定义了这个宏.后面很多的宏比如说ACTION, CONTRACT也都是如此.这个宏的具体用法请看上面的注释,结果就是我们现在写合约的使用方式了.这个dispatcher.cpp建议大家可以深入了解一下,对后面的智能合约开发或者出现的bug都会有更加深一步的看法</p>\n<p>这里还有一个关键点就是,我们的智能合约如果要能够使用,必须提供一个apply的函数,而上面的宏就是帮助我们实现的这个apply函数.那么疑问来了,我是不是自己实现一个apply函数,不用上面的宏,也可以完成这个工作呢?<br>答案是可以的</p>\n<h4 id=\"自定义dispatcher-方式1\"><a href=\"#自定义dispatcher-方式1\" class=\"headerlink\" title=\"自定义dispatcher 方式1\"></a>自定义dispatcher 方式1</h4><blockquote>\n<p>这里同样跟着官方的教程走</p>\n</blockquote>\n<pre><code>extern &quot;C&quot; {\n    void apply(uint64_t receiver, uint64_t code, uint64_t action) {\n        auto self = receiver;\n        if( code == self ) {\n          addressbook _addressbook(name(receiver));\n          switch(action) {\n            case name(&quot;upsert&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::upsert); \n              break;\n            case name(&quot;notify&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::notify); \n              break;\n            case name(&quot;erase&quot;).value: \n              execute_action(name(receiver), name(code), &amp;addressbook::erase); \n              break;\n          }\n        }\n    }\n};\n</code></pre><p>1.</p>\n<ul>\n<li>可以看到apply函数接收三个参数,第一个receiver,合约的拥有者,</li>\n<li>第二个参数code,调用合约的发起人(这个参数我理解为通过什么方式调用的,如果直接通过调用本合约的,这个参数就是self,而如果通过其他智能合约比如说eosio.token,这个code就是eosio.token,或者其他合约的拥有者)</li>\n<li>第三个,执行合约的action,也就是合约的函数名,这个合约被标识为action</li>\n</ul>\n<ol start=\"2\">\n<li>if中判断如果合约的调用者是直接调用此合约的,即不是通过其他合约调用本合约的</li>\n<li>实例化addressbook这个类,(这里有点疑惑的是,这个_addressbook在这里代表的是类,而addressbook才是对象,没有明白这是为什么,在c++ 中实例化一个类不是 T t 这种形式吗?),这个实例化比较古老了,只接受了一个参数,在cdt1.3要接受三个参数,请注意</li>\n<li>一个switch结构,根据对应的action的名字分发对应的动作</li>\n<li><p>使用eosio::execute_action执行对应的action</p>\n<ul>\n<li><p>这里大家又看到了一个新的东西了,不要怕,我们看看是什么</p>\n<pre><code>   /**\n * @defgroup dispatcher Dispatcher API\n * @brief Defines functions to dispatch action to proper action handler inside a contract\n * @ingroup contractdev\n */\n\n/**\n * @defgroup dispatchercpp Dispatcher C++ API\n * @brief Defines C++ functions to dispatch action to proper action handler inside a contract\n * @ingroup dispatcher\n * @{\n */\n\n/**\n * Unpack the received action and execute the correponding action handler\n * \n * @brief Unpack the received action and execute the correponding action handler\n * @tparam T - The contract class that has the correponding action handler, this contract should be derived from eosio::contract\n * @tparam Q - The namespace of the action handler function \n * @tparam Args - The arguments that the action handler accepts, i.e. members of the action\n * @param obj - The contract object that has the correponding action handler\n * @param func - The action handler\n * @return true  \n */\ntemplate&lt;typename T, typename Q, typename... Args&gt;\nbool execute_action( T* obj, void (Q::*func)(Args...)  ) {\n...\n}\n</code></pre></li>\n<li><p>这里我把具体实现删掉了,只留下了注释和方法签名,可以看到是一个模板函数,那我们就看看他的作用是什么了</p>\n<pre><code>Unpack the received action and execute the correponding action handler\n解压缩收到的操作并执行相应的操作处理程序\n</code></pre></li>\n<li>再结合上面的具体的参数的用法,就知道了原来又是一个dispatcher的帮助函数,帮我们去分发对应的action,只是传递的方式变了.</li>\n<li>很好,现在我们已经抛弃了系统提供的EOSIO_DISPATCH而自己实现了这个apply函数,至于能不能用呢?那我们接下来试试了</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"自定义dispatcher-方式1-结果展示\"><a href=\"#自定义dispatcher-方式1-结果展示\" class=\"headerlink\" title=\"自定义dispatcher 方式1 结果展示\"></a>自定义dispatcher 方式1 结果展示</h4><blockquote>\n<p>本次我们直接copy的官方的addressbook的源码,然后使用自己实现apply函数<br>精简一些不必要的参数,实现功能为主<br>上面我说过,由于版本的原因,目前的版本我们需要在实例化addressbook的时候传入三个参数</p>\n</blockquote>\n<pre><code>addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));\n</code></pre><blockquote>\n<p>最终改造了的代码如下</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;eosiolib/eosio.hpp&gt;</span><br><span class=\"line\">#include &lt;eosiolib/print.hpp&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">using namespace eosio;</span><br><span class=\"line\"></span><br><span class=\"line\">class [[eosio::contract]] addressbook : public eosio::contract &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">public:</span><br><span class=\"line\">  using contract::contract;</span><br><span class=\"line\">  </span><br><span class=\"line\">  addressbook(name receiver, name code,  datastream&lt;const char*&gt; ds): contract(receiver, code, ds) &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void upsert(name user, std::string first_name, std::string last_name) &#123;</span><br><span class=\"line\">    require_auth(user);</span><br><span class=\"line\">    address_index addresses(_code, _code.value);</span><br><span class=\"line\">    auto iterator = addresses.find(user.value);</span><br><span class=\"line\">    if( iterator == addresses.end() )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      addresses.emplace(user, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">       row.key = user;</span><br><span class=\"line\">       row.first_name = first_name;</span><br><span class=\"line\">       row.last_name = last_name;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      send_summary(user, &quot; successfully emplaced record to addressbook&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    else &#123;</span><br><span class=\"line\">      std::string changes;</span><br><span class=\"line\">      addresses.modify(iterator, user, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">        row.key = user;</span><br><span class=\"line\">        row.first_name = first_name;</span><br><span class=\"line\">        row.last_name = last_name;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">      send_summary(user, &quot; successfully modified record to addressbook&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void erase(name user) &#123;</span><br><span class=\"line\">    require_auth(user);</span><br><span class=\"line\"></span><br><span class=\"line\">    address_index addresses(_self, _code.value);</span><br><span class=\"line\"></span><br><span class=\"line\">    auto iterator = addresses.find(user.value);</span><br><span class=\"line\">    eosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);</span><br><span class=\"line\">    addresses.erase(iterator);</span><br><span class=\"line\">    send_summary(user, &quot; successfully erased record from addressbook&quot;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  [[eosio::action]]</span><br><span class=\"line\">  void notify(name user, std::string msg) &#123;</span><br><span class=\"line\">    require_auth(get_self());</span><br><span class=\"line\">    require_recipient(user);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">private:</span><br><span class=\"line\">  struct [[eosio::table]] person &#123;</span><br><span class=\"line\">    name key;</span><br><span class=\"line\">    std::string first_name;</span><br><span class=\"line\">    std::string last_name;</span><br><span class=\"line\">    uint64_t primary_key() const &#123; return key.value; &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  void send_summary(name user, std::string message) &#123;</span><br><span class=\"line\">    action(</span><br><span class=\"line\">      permission_level&#123;get_self(),&quot;active&quot;_n&#125;,</span><br><span class=\"line\">      get_self(),</span><br><span class=\"line\">      &quot;notify&quot;_n,</span><br><span class=\"line\">      std::make_tuple(user, name&#123;user&#125;.to_string() + message)</span><br><span class=\"line\">    ).send();</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">  typedef eosio::multi_index&lt;&quot;people&quot;_n, person&gt; address_index;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">extern &quot;C&quot; &#123;</span><br><span class=\"line\">    void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123;</span><br><span class=\"line\">        auto self = receiver;</span><br><span class=\"line\">        if( code == self ) &#123;</span><br><span class=\"line\">          addressbook _addressbook(name(receiver),name(code),datastream&lt;const char*&gt;(nullptr,0));</span><br><span class=\"line\">          switch(action) &#123;</span><br><span class=\"line\">            case name(&quot;upsert&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::upsert); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">            case name(&quot;notify&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::notify); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">            case name(&quot;erase&quot;).value: </span><br><span class=\"line\">              execute_action(name(receiver), name(code), &amp;addressbook::erase); </span><br><span class=\"line\">              break;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<h4 id=\"结果展示\"><a href=\"#结果展示\" class=\"headerlink\" title=\"结果展示\"></a>结果展示</h4><ol>\n<li>此次合约部署在kylin上的shaokun11114账号上可以看到我们也完美实现了数据增加和删除</li>\n</ol>\n<p><img src=\"/img_eos1/eos_react8.gif\" alt=\"shaokun\"></p>\n<ol start=\"2\">\n<li>去kylin查看结果,可以看到我们得交易记录,其中的notify也可以看到,说明apply函数正常使用</li>\n</ol>\n<p><img src=\"/img_eos1/eos15.png\" alt=\"shaokun\"></p>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-01\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ol>\n<li>这就完了?当然没有,这篇文章只是简单的和大家一起走走官网的dispatcher,当然还没有走完,如果只是这样写了能够实现功能那和用eos提供的宏没什么区别了呢</li>\n<li>我建议各位同学接触到错误不要慌,也不要急,各位可以先自己看看报错误的信息提示,可以把这个粘贴到Google上找一下答案,这样自己找寻到的答案记忆会深刻许多</li>\n<li>接下来将我进一步跟着官网走,把剩下的一点点讲明白,而这才是dispatcher的真正用法呢.可以解决文章开头提到的payable的问题呢</li>\n<li>谢谢大家的浏览,希望有发现错误的同学可以加上我微信帮我指出来,再次感谢.</li>\n</ol>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#97;&#x6f;&#107;&#117;&#110;&#105;&#110;&#103;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#97;&#x6f;&#107;&#117;&#110;&#105;&#110;&#103;&#64;&#x67;&#109;&#x61;&#105;&#108;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#117;&#x6e;&#110;&#121;&#64;&#49;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>\n"},{"title":"eosio.token transfer正确的使用方式","date":"2019-03-02T13:30:27.000Z","_content":"\n#### 前言\n* 额,正确使用的方式不就是转账吗?直接调用不就可以了?\n* 是的,就是转账,但是\n\t1. 我要在账号中的合约中执行转账(这个之前的文章已经实现了,不是本篇文章的重点)\n\t2. 同时执行一个greet(std::string msg) action呢?\n\t3. 当其他任何玩家转账给我,我要知道转账的数据,同时给我捎句话呢\n* 那就使用一个action转账,一个action greet(msg)!!!\n* 目的是到了呢,但是这个是两个action呢?那就是有时间差的,貌似不符合我的需求哦,那该怎么办呢?\n* 好的,如果你看过之前的文章,其实你已经明白怎么做了,自定义dispatcher这个宏\n* 是的,完全正确,那么本篇文章就是接着之前的文章而来,把数据记录起来\n\n#### 游戏设计\n* 本次的合约来玩一个游戏叫做:paymsg\n* 游戏规则:\n\t* 任何人均可以参加游戏,每次参加至少游戏需花费1eos\n\t* 花费了这个费用的玩家 合约会自动将他转账的memo储存在区块链中,但是会加上我的签名\n\t* 当然,当你花费超过5个eos时,将会有一次免费的机会再次更新你储存的信息\n#### 合约设计\n* 合约的具体设计请看源码就可以了\n\t1. 拦截transfer方法,获取转账信息\n\t2. 记住反序列化的时候,需要建一个struct来承载数据的信息 \n\t3. 设计一个对外的action用于 用户免费更新储存的信息\n\t4. 此合约只是demo,仅供参考\n\n```\n  [[eosio::action]]\n  void upmsg(name player, std::string msg) {\n    require_auth(player);\n    // 这个地方可以使用这种方式初始化table 真不知道是哪里醉了\n    paymessage_index paymessages(get_self(), _code.value);\n    auto iterator = paymessages.find(player.value);\n    eosio_assert(iterator != paymessages.end(), \"you are not in shaokun paymsg game\");\n    eosio_assert(iterator->uamount >= 50000, \"you must send more than 5 eos that can update your msg\");\n    paymessages.modify(iterator, player, [&]( auto& row ) {\n        row.player = player;\n        row.msg = msg;\n        row.uamount = 0;  //置为0 ,下次更改必须花5eos以上\n      });\n  }\n\n  void transfer(){\n    // 反序列化得到st_transfer结构体对象\n    // 就可以拿到transfer的交易信息了,而且是eosio.token发过的transfer\n    auto transfer_data = unpack_action_data<st_transfer>();\n    // eos是4位小数,由于不支持实际意义上的小数,所以这里要使用整形10000代替1eos\n    eosio_assert(transfer_data.quantity.amount >= 10000, \"must more than 1 eos provide\");\n    auto tr_from = transfer_data.from;\n    if(tr_from == get_self()) {\n        //自己转出去就不需要参加游戏了\n        return;\n    }\n    auto tr_amount = transfer_data.quantity.amount;\n    // https://github.com/EOSIO/eosio.cdt/blob/master/libraries/eosiolib/symbol.hpp\n    if(transfer_data.quantity.symbol != eosio::symbol(\"EOS\",4)){\n        // 我们只收eos\n        return;\n    }\n    auto tr_memo = transfer_data.memo;\n    // 这里一定要按照这样的格式初始化table,不然无法写入数据\n    // 理论上这种方式初始化的table权限是一样的呢 paymessage_index paymessages(get_self(), _code.value);\n    paymessage_index paymessages(get_self(), get_self().value);\n    auto itr = paymessages.find(transfer_data.from.value);\n    if (itr == paymessages.end()){\n        paymessages.emplace(get_self(), [&]( auto& row ) {\n            row.player = tr_from;\n            row.uamount = tr_amount;\n            row.tamount = tr_amount;\n            row.msg = \"welcome to shaokun paygame, your pay msg is :\" + tr_memo;\n        });\n    }else {\n        paymessages.modify(itr, get_self(), [&]( auto& row ) {\n            row.tamount += tr_amount;\n            row.uamount += tr_amount ;\n            row.msg = \"welcome come back to shaokun paygame:\"+ tr_memo;\n        });\n    }\n  }\n\n```\n\n#### 编译,部署,验证\n* 编译,买RAM,部署\n* 使用shaokunpay11部署合约\n* 使用eostoday1235进行添加数据\n* 使用eostoday1235进行两次的upmsg进行修改数据\n\n ![shaokun](/img_eos1/eos_gif_3.gif)\n\n* [源码](https://github.com/shaokun11/eosabout.git)\n\n\n#### 填坑\n* 之前有一个困惑的问题是关于scatter和eosjs2无法一起使用,官方也没有例子,而现在找到了[github](https://github.com/GetScatter/scatter-js)\n* 以下我只是搬运工 ^.^\n* scatter + eosjs2  \n* npm i -S scatterjs-core scatterjs-plugin-eosjs2 eosjs@20.0.0-beta3\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterEOS from 'scatterjs-plugin-eosjs2';\nimport {JsonRpc, Api} from 'eosjs';\n\nScatterJS.plugins( new ScatterEOS() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eos',\n    chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n    host:'nodes.get-scatter.com',\n    port:443,\n    protocol:'https'\n});\nconst rpc = new JsonRpc(network.fullhost());\n\nScatterJS.connect('hello shaokun', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const eos = ScatterJS.eos(network, Api, {rpc, beta3:true});\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('eos');\n\n        eos.transact({\n            actions: [{\n                account: 'eosio.token',\n                name: 'transfer',\n                authorization: [{\n                    actor: account.name,\n                    permission: account.authority,\n                }],\n                data: {\n                    from: account.name,\n                    to: 'safetransfer',\n                    quantity: '0.0001 EOS',\n                    memo: account.name,\n                },\n            }]\n        }, {\n            blocksBehind: 3,\n            expireSeconds: 30,\n        }).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + eosjs1  \n* npm i -S scatterjs-core scatterjs-plugin-eosjs eosjs@16.0.9\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterEOS from 'scatterjs-plugin-eosjs';\nimport Eos from 'eosjs';\n\nScatterJS.plugins( new ScatterEOS() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eos',\n    chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n    host:'nodes.get-scatter.com',\n    port:443,\n    protocol:'https'\n});\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const eos = ScatterJS.eos(network, Eos);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('eos');\n        const options = {authorization:[`${account.name}@${account.authority}`]};\n        eos.transfer(account.name, 'safetransfer', '0.0001 EOS', account.name, options).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + web3\n* npm i -S scatterjs-core scatterjs-plugin-web3 web3\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterETH from 'scatterjs-plugin-web3';\nimport Web3 from 'web3';\n\nScatterJS.plugins( new ScatterETH() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eth',\n    chainId:'1',\n    host:'YOUR ETHEREUM NODE',\n    port:443,\n    protocol:'https'\n});\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const web3 = ScatterJS.web3(network, Web3);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        // https://github.com/GetScatter/scatter-js/blob/master/packages/core/src/models/Blockchains.js\n        // 这里官方应该写错了,携程trx了,我们把它改过来\n        const account = ScatterJS.account('eth');\n        web3.eth.sendTransaction({\n            from: account.address,\n            to: '0x...',\n            value: '1000000000000000'\n        }).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + tronweb\n* npm i -S scatterjs-core scatterjs-plugin-tron tronweb\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterTron from 'scatterjs-plugin-tron';\nimport TronWeb from 'tronweb';\n\nScatterJS.plugins( new ScatterTron() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'tron',\n    chainId:'1',\n    host:'api.trongrid.io',\n    port:443,\n    protocol:'https'\n});\n\nconst httpProvider = new TronWeb.providers.HttpProvider(network.fullhost());\nlet tron = new TronWeb(httpProvider, httpProvider, network.fullhost());\ntron.setDefaultBlock('latest');\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    tron = ScatterJS.trx(network, tron);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('trx');\n        tron.trx.sendTransaction('TX...', 100).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n#### 总结\n* 这样就实现了以太坊payable关键字的功能了\n* paymsg这个小game的逻辑,其实也和市面上大多数的菠菜类游戏的实现方式类似,只是其中的规则少了点\n* 至此,基于eos开发dapp的所有流程基本上是讲完了\n* 当然其中有很多点我也没有讲到,主要是我在学习的过程中,其他点没有遇到太大的问题.比如说multi_index的操作\n* 关于感想,就是要有耐心去学习这个,因为目前也没有其他的更好的资料,我比较推荐官方的教程[eos smart contract](https://developers.eos.io/eosio-home/docs/introduction)\n* 还有一点,如果你使用eosiocpp编译wasm,abi文件,写合约的时候,有时候需要参考源码[eosio](https://sourcegraph.com/github.com/EOSIO/eos),如果使用eosio.cdt编译的合约,[eosio.cdt eoslib](https://github.com/EOSIO/eosio.cdt/tree/master/libraries/eosiolib)要去这里找(ps:这个地方受过很多伤...)\n* 最后,祝大家学的开心\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eosio.token transfer action正确的使用方式.md","raw":"---\ntitle: eosio.token transfer正确的使用方式\ndate: 2019-03-02 21:30:27\n---\n\n#### 前言\n* 额,正确使用的方式不就是转账吗?直接调用不就可以了?\n* 是的,就是转账,但是\n\t1. 我要在账号中的合约中执行转账(这个之前的文章已经实现了,不是本篇文章的重点)\n\t2. 同时执行一个greet(std::string msg) action呢?\n\t3. 当其他任何玩家转账给我,我要知道转账的数据,同时给我捎句话呢\n* 那就使用一个action转账,一个action greet(msg)!!!\n* 目的是到了呢,但是这个是两个action呢?那就是有时间差的,貌似不符合我的需求哦,那该怎么办呢?\n* 好的,如果你看过之前的文章,其实你已经明白怎么做了,自定义dispatcher这个宏\n* 是的,完全正确,那么本篇文章就是接着之前的文章而来,把数据记录起来\n\n#### 游戏设计\n* 本次的合约来玩一个游戏叫做:paymsg\n* 游戏规则:\n\t* 任何人均可以参加游戏,每次参加至少游戏需花费1eos\n\t* 花费了这个费用的玩家 合约会自动将他转账的memo储存在区块链中,但是会加上我的签名\n\t* 当然,当你花费超过5个eos时,将会有一次免费的机会再次更新你储存的信息\n#### 合约设计\n* 合约的具体设计请看源码就可以了\n\t1. 拦截transfer方法,获取转账信息\n\t2. 记住反序列化的时候,需要建一个struct来承载数据的信息 \n\t3. 设计一个对外的action用于 用户免费更新储存的信息\n\t4. 此合约只是demo,仅供参考\n\n```\n  [[eosio::action]]\n  void upmsg(name player, std::string msg) {\n    require_auth(player);\n    // 这个地方可以使用这种方式初始化table 真不知道是哪里醉了\n    paymessage_index paymessages(get_self(), _code.value);\n    auto iterator = paymessages.find(player.value);\n    eosio_assert(iterator != paymessages.end(), \"you are not in shaokun paymsg game\");\n    eosio_assert(iterator->uamount >= 50000, \"you must send more than 5 eos that can update your msg\");\n    paymessages.modify(iterator, player, [&]( auto& row ) {\n        row.player = player;\n        row.msg = msg;\n        row.uamount = 0;  //置为0 ,下次更改必须花5eos以上\n      });\n  }\n\n  void transfer(){\n    // 反序列化得到st_transfer结构体对象\n    // 就可以拿到transfer的交易信息了,而且是eosio.token发过的transfer\n    auto transfer_data = unpack_action_data<st_transfer>();\n    // eos是4位小数,由于不支持实际意义上的小数,所以这里要使用整形10000代替1eos\n    eosio_assert(transfer_data.quantity.amount >= 10000, \"must more than 1 eos provide\");\n    auto tr_from = transfer_data.from;\n    if(tr_from == get_self()) {\n        //自己转出去就不需要参加游戏了\n        return;\n    }\n    auto tr_amount = transfer_data.quantity.amount;\n    // https://github.com/EOSIO/eosio.cdt/blob/master/libraries/eosiolib/symbol.hpp\n    if(transfer_data.quantity.symbol != eosio::symbol(\"EOS\",4)){\n        // 我们只收eos\n        return;\n    }\n    auto tr_memo = transfer_data.memo;\n    // 这里一定要按照这样的格式初始化table,不然无法写入数据\n    // 理论上这种方式初始化的table权限是一样的呢 paymessage_index paymessages(get_self(), _code.value);\n    paymessage_index paymessages(get_self(), get_self().value);\n    auto itr = paymessages.find(transfer_data.from.value);\n    if (itr == paymessages.end()){\n        paymessages.emplace(get_self(), [&]( auto& row ) {\n            row.player = tr_from;\n            row.uamount = tr_amount;\n            row.tamount = tr_amount;\n            row.msg = \"welcome to shaokun paygame, your pay msg is :\" + tr_memo;\n        });\n    }else {\n        paymessages.modify(itr, get_self(), [&]( auto& row ) {\n            row.tamount += tr_amount;\n            row.uamount += tr_amount ;\n            row.msg = \"welcome come back to shaokun paygame:\"+ tr_memo;\n        });\n    }\n  }\n\n```\n\n#### 编译,部署,验证\n* 编译,买RAM,部署\n* 使用shaokunpay11部署合约\n* 使用eostoday1235进行添加数据\n* 使用eostoday1235进行两次的upmsg进行修改数据\n\n ![shaokun](/img_eos1/eos_gif_3.gif)\n\n* [源码](https://github.com/shaokun11/eosabout.git)\n\n\n#### 填坑\n* 之前有一个困惑的问题是关于scatter和eosjs2无法一起使用,官方也没有例子,而现在找到了[github](https://github.com/GetScatter/scatter-js)\n* 以下我只是搬运工 ^.^\n* scatter + eosjs2  \n* npm i -S scatterjs-core scatterjs-plugin-eosjs2 eosjs@20.0.0-beta3\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterEOS from 'scatterjs-plugin-eosjs2';\nimport {JsonRpc, Api} from 'eosjs';\n\nScatterJS.plugins( new ScatterEOS() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eos',\n    chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n    host:'nodes.get-scatter.com',\n    port:443,\n    protocol:'https'\n});\nconst rpc = new JsonRpc(network.fullhost());\n\nScatterJS.connect('hello shaokun', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const eos = ScatterJS.eos(network, Api, {rpc, beta3:true});\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('eos');\n\n        eos.transact({\n            actions: [{\n                account: 'eosio.token',\n                name: 'transfer',\n                authorization: [{\n                    actor: account.name,\n                    permission: account.authority,\n                }],\n                data: {\n                    from: account.name,\n                    to: 'safetransfer',\n                    quantity: '0.0001 EOS',\n                    memo: account.name,\n                },\n            }]\n        }, {\n            blocksBehind: 3,\n            expireSeconds: 30,\n        }).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + eosjs1  \n* npm i -S scatterjs-core scatterjs-plugin-eosjs eosjs@16.0.9\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterEOS from 'scatterjs-plugin-eosjs';\nimport Eos from 'eosjs';\n\nScatterJS.plugins( new ScatterEOS() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eos',\n    chainId:'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906',\n    host:'nodes.get-scatter.com',\n    port:443,\n    protocol:'https'\n});\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const eos = ScatterJS.eos(network, Eos);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('eos');\n        const options = {authorization:[`${account.name}@${account.authority}`]};\n        eos.transfer(account.name, 'safetransfer', '0.0001 EOS', account.name, options).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + web3\n* npm i -S scatterjs-core scatterjs-plugin-web3 web3\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterETH from 'scatterjs-plugin-web3';\nimport Web3 from 'web3';\n\nScatterJS.plugins( new ScatterETH() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'eth',\n    chainId:'1',\n    host:'YOUR ETHEREUM NODE',\n    port:443,\n    protocol:'https'\n});\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    const web3 = ScatterJS.web3(network, Web3);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        // https://github.com/GetScatter/scatter-js/blob/master/packages/core/src/models/Blockchains.js\n        // 这里官方应该写错了,携程trx了,我们把它改过来\n        const account = ScatterJS.account('eth');\n        web3.eth.sendTransaction({\n            from: account.address,\n            to: '0x...',\n            value: '1000000000000000'\n        }).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n* scatter + tronweb\n* npm i -S scatterjs-core scatterjs-plugin-tron tronweb\n\n```\nimport ScatterJS from 'scatterjs-core';\nimport ScatterTron from 'scatterjs-plugin-tron';\nimport TronWeb from 'tronweb';\n\nScatterJS.plugins( new ScatterTron() );\n\nconst network = ScatterJS.Network.fromJson({\n    blockchain:'tron',\n    chainId:'1',\n    host:'api.trongrid.io',\n    port:443,\n    protocol:'https'\n});\n\nconst httpProvider = new TronWeb.providers.HttpProvider(network.fullhost());\nlet tron = new TronWeb(httpProvider, httpProvider, network.fullhost());\ntron.setDefaultBlock('latest');\n\nScatterJS.connect('YourAppName', {network}).then(connected => {\n    if(!connected) return console.error('no scatter');\n\n    tron = ScatterJS.trx(network, tron);\n\n    ScatterJS.login().then(id => {\n        if(!id) return console.error('no identity');\n        const account = ScatterJS.account('trx');\n        tron.trx.sendTransaction('TX...', 100).then(res => {\n            console.log('sent: ', res);\n        }).catch(err => {\n            console.error('error: ', err);\n        });\n    });\n});\n```\n\n#### 总结\n* 这样就实现了以太坊payable关键字的功能了\n* paymsg这个小game的逻辑,其实也和市面上大多数的菠菜类游戏的实现方式类似,只是其中的规则少了点\n* 至此,基于eos开发dapp的所有流程基本上是讲完了\n* 当然其中有很多点我也没有讲到,主要是我在学习的过程中,其他点没有遇到太大的问题.比如说multi_index的操作\n* 关于感想,就是要有耐心去学习这个,因为目前也没有其他的更好的资料,我比较推荐官方的教程[eos smart contract](https://developers.eos.io/eosio-home/docs/introduction)\n* 还有一点,如果你使用eosiocpp编译wasm,abi文件,写合约的时候,有时候需要参考源码[eosio](https://sourcegraph.com/github.com/EOSIO/eos),如果使用eosio.cdt编译的合约,[eosio.cdt eoslib](https://github.com/EOSIO/eosio.cdt/tree/master/libraries/eosiolib)要去这里找(ps:这个地方受过很多伤...)\n* 最后,祝大家学的开心\n\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eosio.token transfer action正确的使用方式","published":1,"updated":"2019-03-01T13:24:36.821Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52t000inh7sctv7bku4","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>额,正确使用的方式不就是转账吗?直接调用不就可以了?</li>\n<li>是的,就是转账,但是<ol>\n<li>我要在账号中的合约中执行转账(这个之前的文章已经实现了,不是本篇文章的重点)</li>\n<li>同时执行一个greet(std::string msg) action呢?</li>\n<li>当其他任何玩家转账给我,我要知道转账的数据,同时给我捎句话呢</li>\n</ol>\n</li>\n<li>那就使用一个action转账,一个action greet(msg)!!!</li>\n<li>目的是到了呢,但是这个是两个action呢?那就是有时间差的,貌似不符合我的需求哦,那该怎么办呢?</li>\n<li>好的,如果你看过之前的文章,其实你已经明白怎么做了,自定义dispatcher这个宏</li>\n<li>是的,完全正确,那么本篇文章就是接着之前的文章而来,把数据记录起来</li>\n</ul>\n<h4 id=\"游戏设计\"><a href=\"#游戏设计\" class=\"headerlink\" title=\"游戏设计\"></a>游戏设计</h4><ul>\n<li>本次的合约来玩一个游戏叫做:paymsg</li>\n<li>游戏规则:<ul>\n<li>任何人均可以参加游戏,每次参加至少游戏需花费1eos</li>\n<li>花费了这个费用的玩家 合约会自动将他转账的memo储存在区块链中,但是会加上我的签名</li>\n<li>当然,当你花费超过5个eos时,将会有一次免费的机会再次更新你储存的信息<h4 id=\"合约设计\"><a href=\"#合约设计\" class=\"headerlink\" title=\"合约设计\"></a>合约设计</h4></li>\n</ul>\n</li>\n<li>合约的具体设计请看源码就可以了<ol>\n<li>拦截transfer方法,获取转账信息</li>\n<li>记住反序列化的时候,需要建一个struct来承载数据的信息 </li>\n<li>设计一个对外的action用于 用户免费更新储存的信息</li>\n<li>此合约只是demo,仅供参考</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[eosio::action]]</span><br><span class=\"line\">void upmsg(name player, std::string msg) &#123;</span><br><span class=\"line\">  require_auth(player);</span><br><span class=\"line\">  // 这个地方可以使用这种方式初始化table 真不知道是哪里醉了</span><br><span class=\"line\">  paymessage_index paymessages(get_self(), _code.value);</span><br><span class=\"line\">  auto iterator = paymessages.find(player.value);</span><br><span class=\"line\">  eosio_assert(iterator != paymessages.end(), &quot;you are not in shaokun paymsg game&quot;);</span><br><span class=\"line\">  eosio_assert(iterator-&gt;uamount &gt;= 50000, &quot;you must send more than 5 eos that can update your msg&quot;);</span><br><span class=\"line\">  paymessages.modify(iterator, player, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">      row.player = player;</span><br><span class=\"line\">      row.msg = msg;</span><br><span class=\"line\">      row.uamount = 0;  //置为0 ,下次更改必须花5eos以上</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void transfer()&#123;</span><br><span class=\"line\">  // 反序列化得到st_transfer结构体对象</span><br><span class=\"line\">  // 就可以拿到transfer的交易信息了,而且是eosio.token发过的transfer</span><br><span class=\"line\">  auto transfer_data = unpack_action_data&lt;st_transfer&gt;();</span><br><span class=\"line\">  // eos是4位小数,由于不支持实际意义上的小数,所以这里要使用整形10000代替1eos</span><br><span class=\"line\">  eosio_assert(transfer_data.quantity.amount &gt;= 10000, &quot;must more than 1 eos provide&quot;);</span><br><span class=\"line\">  auto tr_from = transfer_data.from;</span><br><span class=\"line\">  if(tr_from == get_self()) &#123;</span><br><span class=\"line\">      //自己转出去就不需要参加游戏了</span><br><span class=\"line\">      return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tr_amount = transfer_data.quantity.amount;</span><br><span class=\"line\">  // https://github.com/EOSIO/eosio.cdt/blob/master/libraries/eosiolib/symbol.hpp</span><br><span class=\"line\">  if(transfer_data.quantity.symbol != eosio::symbol(&quot;EOS&quot;,4))&#123;</span><br><span class=\"line\">      // 我们只收eos</span><br><span class=\"line\">      return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tr_memo = transfer_data.memo;</span><br><span class=\"line\">  // 这里一定要按照这样的格式初始化table,不然无法写入数据</span><br><span class=\"line\">  // 理论上这种方式初始化的table权限是一样的呢 paymessage_index paymessages(get_self(), _code.value);</span><br><span class=\"line\">  paymessage_index paymessages(get_self(), get_self().value);</span><br><span class=\"line\">  auto itr = paymessages.find(transfer_data.from.value);</span><br><span class=\"line\">  if (itr == paymessages.end())&#123;</span><br><span class=\"line\">      paymessages.emplace(get_self(), [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">          row.player = tr_from;</span><br><span class=\"line\">          row.uamount = tr_amount;</span><br><span class=\"line\">          row.tamount = tr_amount;</span><br><span class=\"line\">          row.msg = &quot;welcome to shaokun paygame, your pay msg is :&quot; + tr_memo;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;else &#123;</span><br><span class=\"line\">      paymessages.modify(itr, get_self(), [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">          row.tamount += tr_amount;</span><br><span class=\"line\">          row.uamount += tr_amount ;</span><br><span class=\"line\">          row.msg = &quot;welcome come back to shaokun paygame:&quot;+ tr_memo;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译-部署-验证\"><a href=\"#编译-部署-验证\" class=\"headerlink\" title=\"编译,部署,验证\"></a>编译,部署,验证</h4><ul>\n<li>编译,买RAM,部署</li>\n<li>使用shaokunpay11部署合约</li>\n<li>使用eostoday1235进行添加数据</li>\n<li><p>使用eostoday1235进行两次的upmsg进行修改数据</p>\n<p><img src=\"/img_eos1/eos_gif_3.gif\" alt=\"shaokun\"></p>\n</li>\n<li><p><a href=\"https://github.com/shaokun11/eosabout.git\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n</li>\n</ul>\n<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><ul>\n<li>之前有一个困惑的问题是关于scatter和eosjs2无法一起使用,官方也没有例子,而现在找到了<a href=\"https://github.com/GetScatter/scatter-js\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>以下我只是搬运工 ^.^</li>\n<li>scatter + eosjs2  </li>\n<li>npm i -S scatterjs-core scatterjs-plugin-eosjs2 <a href=\"mailto:eosjs@20.0.0-beta3\" target=\"_blank\" rel=\"noopener\">eosjs@20.0.0-beta3</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterEOS from &apos;scatterjs-plugin-eosjs2&apos;;</span><br><span class=\"line\">import &#123;JsonRpc, Api&#125; from &apos;eosjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterEOS() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eos&apos;,</span><br><span class=\"line\">    chainId:&apos;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&apos;,</span><br><span class=\"line\">    host:&apos;nodes.get-scatter.com&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const rpc = new JsonRpc(network.fullhost());</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;hello shaokun&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const eos = ScatterJS.eos(network, Api, &#123;rpc, beta3:true&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eos&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">        eos.transact(&#123;</span><br><span class=\"line\">            actions: [&#123;</span><br><span class=\"line\">                account: &apos;eosio.token&apos;,</span><br><span class=\"line\">                name: &apos;transfer&apos;,</span><br><span class=\"line\">                authorization: [&#123;</span><br><span class=\"line\">                    actor: account.name,</span><br><span class=\"line\">                    permission: account.authority,</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">                data: &#123;</span><br><span class=\"line\">                    from: account.name,</span><br><span class=\"line\">                    to: &apos;safetransfer&apos;,</span><br><span class=\"line\">                    quantity: &apos;0.0001 EOS&apos;,</span><br><span class=\"line\">                    memo: account.name,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;]</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            blocksBehind: 3,</span><br><span class=\"line\">            expireSeconds: 30,</span><br><span class=\"line\">        &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + eosjs1  </li>\n<li>npm i -S scatterjs-core scatterjs-plugin-eosjs <a href=\"mailto:eosjs@16.0.9\" target=\"_blank\" rel=\"noopener\">eosjs@16.0.9</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;</span><br><span class=\"line\">import Eos from &apos;eosjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterEOS() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eos&apos;,</span><br><span class=\"line\">    chainId:&apos;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&apos;,</span><br><span class=\"line\">    host:&apos;nodes.get-scatter.com&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const eos = ScatterJS.eos(network, Eos);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eos&apos;);</span><br><span class=\"line\">        const options = &#123;authorization:[`$&#123;account.name&#125;@$&#123;account.authority&#125;`]&#125;;</span><br><span class=\"line\">        eos.transfer(account.name, &apos;safetransfer&apos;, &apos;0.0001 EOS&apos;, account.name, options).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + web3</li>\n<li>npm i -S scatterjs-core scatterjs-plugin-web3 web3</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterETH from &apos;scatterjs-plugin-web3&apos;;</span><br><span class=\"line\">import Web3 from &apos;web3&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterETH() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eth&apos;,</span><br><span class=\"line\">    chainId:&apos;1&apos;,</span><br><span class=\"line\">    host:&apos;YOUR ETHEREUM NODE&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const web3 = ScatterJS.web3(network, Web3);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        // https://github.com/GetScatter/scatter-js/blob/master/packages/core/src/models/Blockchains.js</span><br><span class=\"line\">        // 这里官方应该写错了,携程trx了,我们把它改过来</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eth&apos;);</span><br><span class=\"line\">        web3.eth.sendTransaction(&#123;</span><br><span class=\"line\">            from: account.address,</span><br><span class=\"line\">            to: &apos;0x...&apos;,</span><br><span class=\"line\">            value: &apos;1000000000000000&apos;</span><br><span class=\"line\">        &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + tronweb</li>\n<li>npm i -S scatterjs-core scatterjs-plugin-tron tronweb</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterTron from &apos;scatterjs-plugin-tron&apos;;</span><br><span class=\"line\">import TronWeb from &apos;tronweb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterTron() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;tron&apos;,</span><br><span class=\"line\">    chainId:&apos;1&apos;,</span><br><span class=\"line\">    host:&apos;api.trongrid.io&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const httpProvider = new TronWeb.providers.HttpProvider(network.fullhost());</span><br><span class=\"line\">let tron = new TronWeb(httpProvider, httpProvider, network.fullhost());</span><br><span class=\"line\">tron.setDefaultBlock(&apos;latest&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    tron = ScatterJS.trx(network, tron);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;trx&apos;);</span><br><span class=\"line\">        tron.trx.sendTransaction(&apos;TX...&apos;, 100).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>这样就实现了以太坊payable关键字的功能了</li>\n<li>paymsg这个小game的逻辑,其实也和市面上大多数的菠菜类游戏的实现方式类似,只是其中的规则少了点</li>\n<li>至此,基于eos开发dapp的所有流程基本上是讲完了</li>\n<li>当然其中有很多点我也没有讲到,主要是我在学习的过程中,其他点没有遇到太大的问题.比如说multi_index的操作</li>\n<li>关于感想,就是要有耐心去学习这个,因为目前也没有其他的更好的资料,我比较推荐官方的教程<a href=\"https://developers.eos.io/eosio-home/docs/introduction\" target=\"_blank\" rel=\"noopener\">eos smart contract</a></li>\n<li>还有一点,如果你使用eosiocpp编译wasm,abi文件,写合约的时候,有时候需要参考源码<a href=\"https://sourcegraph.com/github.com/EOSIO/eos\" target=\"_blank\" rel=\"noopener\">eosio</a>,如果使用eosio.cdt编译的合约,<a href=\"https://github.com/EOSIO/eosio.cdt/tree/master/libraries/eosiolib\" target=\"_blank\" rel=\"noopener\">eosio.cdt eoslib</a>要去这里找(ps:这个地方受过很多伤…)</li>\n<li>最后,祝大家学的开心</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#x6e;&#105;&#x6e;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#x6e;&#105;&#x6e;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#x75;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#x75;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>额,正确使用的方式不就是转账吗?直接调用不就可以了?</li>\n<li>是的,就是转账,但是<ol>\n<li>我要在账号中的合约中执行转账(这个之前的文章已经实现了,不是本篇文章的重点)</li>\n<li>同时执行一个greet(std::string msg) action呢?</li>\n<li>当其他任何玩家转账给我,我要知道转账的数据,同时给我捎句话呢</li>\n</ol>\n</li>\n<li>那就使用一个action转账,一个action greet(msg)!!!</li>\n<li>目的是到了呢,但是这个是两个action呢?那就是有时间差的,貌似不符合我的需求哦,那该怎么办呢?</li>\n<li>好的,如果你看过之前的文章,其实你已经明白怎么做了,自定义dispatcher这个宏</li>\n<li>是的,完全正确,那么本篇文章就是接着之前的文章而来,把数据记录起来</li>\n</ul>\n<h4 id=\"游戏设计\"><a href=\"#游戏设计\" class=\"headerlink\" title=\"游戏设计\"></a>游戏设计</h4><ul>\n<li>本次的合约来玩一个游戏叫做:paymsg</li>\n<li>游戏规则:<ul>\n<li>任何人均可以参加游戏,每次参加至少游戏需花费1eos</li>\n<li>花费了这个费用的玩家 合约会自动将他转账的memo储存在区块链中,但是会加上我的签名</li>\n<li>当然,当你花费超过5个eos时,将会有一次免费的机会再次更新你储存的信息<h4 id=\"合约设计\"><a href=\"#合约设计\" class=\"headerlink\" title=\"合约设计\"></a>合约设计</h4></li>\n</ul>\n</li>\n<li>合约的具体设计请看源码就可以了<ol>\n<li>拦截transfer方法,获取转账信息</li>\n<li>记住反序列化的时候,需要建一个struct来承载数据的信息 </li>\n<li>设计一个对外的action用于 用户免费更新储存的信息</li>\n<li>此合约只是demo,仅供参考</li>\n</ol>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[eosio::action]]</span><br><span class=\"line\">void upmsg(name player, std::string msg) &#123;</span><br><span class=\"line\">  require_auth(player);</span><br><span class=\"line\">  // 这个地方可以使用这种方式初始化table 真不知道是哪里醉了</span><br><span class=\"line\">  paymessage_index paymessages(get_self(), _code.value);</span><br><span class=\"line\">  auto iterator = paymessages.find(player.value);</span><br><span class=\"line\">  eosio_assert(iterator != paymessages.end(), &quot;you are not in shaokun paymsg game&quot;);</span><br><span class=\"line\">  eosio_assert(iterator-&gt;uamount &gt;= 50000, &quot;you must send more than 5 eos that can update your msg&quot;);</span><br><span class=\"line\">  paymessages.modify(iterator, player, [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">      row.player = player;</span><br><span class=\"line\">      row.msg = msg;</span><br><span class=\"line\">      row.uamount = 0;  //置为0 ,下次更改必须花5eos以上</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">void transfer()&#123;</span><br><span class=\"line\">  // 反序列化得到st_transfer结构体对象</span><br><span class=\"line\">  // 就可以拿到transfer的交易信息了,而且是eosio.token发过的transfer</span><br><span class=\"line\">  auto transfer_data = unpack_action_data&lt;st_transfer&gt;();</span><br><span class=\"line\">  // eos是4位小数,由于不支持实际意义上的小数,所以这里要使用整形10000代替1eos</span><br><span class=\"line\">  eosio_assert(transfer_data.quantity.amount &gt;= 10000, &quot;must more than 1 eos provide&quot;);</span><br><span class=\"line\">  auto tr_from = transfer_data.from;</span><br><span class=\"line\">  if(tr_from == get_self()) &#123;</span><br><span class=\"line\">      //自己转出去就不需要参加游戏了</span><br><span class=\"line\">      return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tr_amount = transfer_data.quantity.amount;</span><br><span class=\"line\">  // https://github.com/EOSIO/eosio.cdt/blob/master/libraries/eosiolib/symbol.hpp</span><br><span class=\"line\">  if(transfer_data.quantity.symbol != eosio::symbol(&quot;EOS&quot;,4))&#123;</span><br><span class=\"line\">      // 我们只收eos</span><br><span class=\"line\">      return;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  auto tr_memo = transfer_data.memo;</span><br><span class=\"line\">  // 这里一定要按照这样的格式初始化table,不然无法写入数据</span><br><span class=\"line\">  // 理论上这种方式初始化的table权限是一样的呢 paymessage_index paymessages(get_self(), _code.value);</span><br><span class=\"line\">  paymessage_index paymessages(get_self(), get_self().value);</span><br><span class=\"line\">  auto itr = paymessages.find(transfer_data.from.value);</span><br><span class=\"line\">  if (itr == paymessages.end())&#123;</span><br><span class=\"line\">      paymessages.emplace(get_self(), [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">          row.player = tr_from;</span><br><span class=\"line\">          row.uamount = tr_amount;</span><br><span class=\"line\">          row.tamount = tr_amount;</span><br><span class=\"line\">          row.msg = &quot;welcome to shaokun paygame, your pay msg is :&quot; + tr_memo;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;else &#123;</span><br><span class=\"line\">      paymessages.modify(itr, get_self(), [&amp;]( auto&amp; row ) &#123;</span><br><span class=\"line\">          row.tamount += tr_amount;</span><br><span class=\"line\">          row.uamount += tr_amount ;</span><br><span class=\"line\">          row.msg = &quot;welcome come back to shaokun paygame:&quot;+ tr_memo;</span><br><span class=\"line\">      &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译-部署-验证\"><a href=\"#编译-部署-验证\" class=\"headerlink\" title=\"编译,部署,验证\"></a>编译,部署,验证</h4><ul>\n<li>编译,买RAM,部署</li>\n<li>使用shaokunpay11部署合约</li>\n<li>使用eostoday1235进行添加数据</li>\n<li><p>使用eostoday1235进行两次的upmsg进行修改数据</p>\n<p><img src=\"/img_eos1/eos_gif_3.gif\" alt=\"shaokun\"></p>\n</li>\n<li><p><a href=\"https://github.com/shaokun11/eosabout.git\" target=\"_blank\" rel=\"noopener\">源码</a></p>\n</li>\n</ul>\n<h4 id=\"填坑\"><a href=\"#填坑\" class=\"headerlink\" title=\"填坑\"></a>填坑</h4><ul>\n<li>之前有一个困惑的问题是关于scatter和eosjs2无法一起使用,官方也没有例子,而现在找到了<a href=\"https://github.com/GetScatter/scatter-js\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li>以下我只是搬运工 ^.^</li>\n<li>scatter + eosjs2  </li>\n<li>npm i -S scatterjs-core scatterjs-plugin-eosjs2 <a href=\"mailto:eosjs@20.0.0-beta3\" target=\"_blank\" rel=\"noopener\">eosjs@20.0.0-beta3</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterEOS from &apos;scatterjs-plugin-eosjs2&apos;;</span><br><span class=\"line\">import &#123;JsonRpc, Api&#125; from &apos;eosjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterEOS() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eos&apos;,</span><br><span class=\"line\">    chainId:&apos;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&apos;,</span><br><span class=\"line\">    host:&apos;nodes.get-scatter.com&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">const rpc = new JsonRpc(network.fullhost());</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;hello shaokun&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const eos = ScatterJS.eos(network, Api, &#123;rpc, beta3:true&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eos&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">        eos.transact(&#123;</span><br><span class=\"line\">            actions: [&#123;</span><br><span class=\"line\">                account: &apos;eosio.token&apos;,</span><br><span class=\"line\">                name: &apos;transfer&apos;,</span><br><span class=\"line\">                authorization: [&#123;</span><br><span class=\"line\">                    actor: account.name,</span><br><span class=\"line\">                    permission: account.authority,</span><br><span class=\"line\">                &#125;],</span><br><span class=\"line\">                data: &#123;</span><br><span class=\"line\">                    from: account.name,</span><br><span class=\"line\">                    to: &apos;safetransfer&apos;,</span><br><span class=\"line\">                    quantity: &apos;0.0001 EOS&apos;,</span><br><span class=\"line\">                    memo: account.name,</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">            &#125;]</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            blocksBehind: 3,</span><br><span class=\"line\">            expireSeconds: 30,</span><br><span class=\"line\">        &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + eosjs1  </li>\n<li>npm i -S scatterjs-core scatterjs-plugin-eosjs <a href=\"mailto:eosjs@16.0.9\" target=\"_blank\" rel=\"noopener\">eosjs@16.0.9</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;</span><br><span class=\"line\">import Eos from &apos;eosjs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterEOS() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eos&apos;,</span><br><span class=\"line\">    chainId:&apos;aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906&apos;,</span><br><span class=\"line\">    host:&apos;nodes.get-scatter.com&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const eos = ScatterJS.eos(network, Eos);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eos&apos;);</span><br><span class=\"line\">        const options = &#123;authorization:[`$&#123;account.name&#125;@$&#123;account.authority&#125;`]&#125;;</span><br><span class=\"line\">        eos.transfer(account.name, &apos;safetransfer&apos;, &apos;0.0001 EOS&apos;, account.name, options).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + web3</li>\n<li>npm i -S scatterjs-core scatterjs-plugin-web3 web3</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterETH from &apos;scatterjs-plugin-web3&apos;;</span><br><span class=\"line\">import Web3 from &apos;web3&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterETH() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;eth&apos;,</span><br><span class=\"line\">    chainId:&apos;1&apos;,</span><br><span class=\"line\">    host:&apos;YOUR ETHEREUM NODE&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    const web3 = ScatterJS.web3(network, Web3);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        // https://github.com/GetScatter/scatter-js/blob/master/packages/core/src/models/Blockchains.js</span><br><span class=\"line\">        // 这里官方应该写错了,携程trx了,我们把它改过来</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;eth&apos;);</span><br><span class=\"line\">        web3.eth.sendTransaction(&#123;</span><br><span class=\"line\">            from: account.address,</span><br><span class=\"line\">            to: &apos;0x...&apos;,</span><br><span class=\"line\">            value: &apos;1000000000000000&apos;</span><br><span class=\"line\">        &#125;).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>scatter + tronweb</li>\n<li>npm i -S scatterjs-core scatterjs-plugin-tron tronweb</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import ScatterJS from &apos;scatterjs-core&apos;;</span><br><span class=\"line\">import ScatterTron from &apos;scatterjs-plugin-tron&apos;;</span><br><span class=\"line\">import TronWeb from &apos;tronweb&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.plugins( new ScatterTron() );</span><br><span class=\"line\"></span><br><span class=\"line\">const network = ScatterJS.Network.fromJson(&#123;</span><br><span class=\"line\">    blockchain:&apos;tron&apos;,</span><br><span class=\"line\">    chainId:&apos;1&apos;,</span><br><span class=\"line\">    host:&apos;api.trongrid.io&apos;,</span><br><span class=\"line\">    port:443,</span><br><span class=\"line\">    protocol:&apos;https&apos;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">const httpProvider = new TronWeb.providers.HttpProvider(network.fullhost());</span><br><span class=\"line\">let tron = new TronWeb(httpProvider, httpProvider, network.fullhost());</span><br><span class=\"line\">tron.setDefaultBlock(&apos;latest&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">ScatterJS.connect(&apos;YourAppName&apos;, &#123;network&#125;).then(connected =&gt; &#123;</span><br><span class=\"line\">    if(!connected) return console.error(&apos;no scatter&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    tron = ScatterJS.trx(network, tron);</span><br><span class=\"line\"></span><br><span class=\"line\">    ScatterJS.login().then(id =&gt; &#123;</span><br><span class=\"line\">        if(!id) return console.error(&apos;no identity&apos;);</span><br><span class=\"line\">        const account = ScatterJS.account(&apos;trx&apos;);</span><br><span class=\"line\">        tron.trx.sendTransaction(&apos;TX...&apos;, 100).then(res =&gt; &#123;</span><br><span class=\"line\">            console.log(&apos;sent: &apos;, res);</span><br><span class=\"line\">        &#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">            console.error(&apos;error: &apos;, err);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>这样就实现了以太坊payable关键字的功能了</li>\n<li>paymsg这个小game的逻辑,其实也和市面上大多数的菠菜类游戏的实现方式类似,只是其中的规则少了点</li>\n<li>至此,基于eos开发dapp的所有流程基本上是讲完了</li>\n<li>当然其中有很多点我也没有讲到,主要是我在学习的过程中,其他点没有遇到太大的问题.比如说multi_index的操作</li>\n<li>关于感想,就是要有耐心去学习这个,因为目前也没有其他的更好的资料,我比较推荐官方的教程<a href=\"https://developers.eos.io/eosio-home/docs/introduction\" target=\"_blank\" rel=\"noopener\">eos smart contract</a></li>\n<li>还有一点,如果你使用eosiocpp编译wasm,abi文件,写合约的时候,有时候需要参考源码<a href=\"https://sourcegraph.com/github.com/EOSIO/eos\" target=\"_blank\" rel=\"noopener\">eosio</a>,如果使用eosio.cdt编译的合约,<a href=\"https://github.com/EOSIO/eosio.cdt/tree/master/libraries/eosiolib\" target=\"_blank\" rel=\"noopener\">eosio.cdt eoslib</a>要去这里找(ps:这个地方受过很多伤…)</li>\n<li>最后,祝大家学的开心</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#x6e;&#105;&#x6e;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#104;&#x61;&#x6f;&#107;&#117;&#x6e;&#105;&#x6e;&#x67;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d;</a><br>email_2: <a href=\"mailto:&#x73;&#x6b;&#x75;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#x6b;&#x75;&#110;&#x6e;&#x79;&#x40;&#49;&#54;&#51;&#46;&#99;&#111;&#x6d;</a></p>\n"},{"title":"eos的dispatcher的使用(3 完结)","date":"2019-01-26T07:08:04.000Z","_content":"\n#### 前言\n经过前面两篇文章的练习,相信各位同学都已经对自定义dispatcher已经有了自己的看法了,那么今天我们继续跟着官方的教程走,把接下来的知识点完整一下\n\n#### 自定义dispatcher 方式3\n* 这种方式官方说了,不能用于eosio-cpp生成abi,所以我也不详细去探究了,有兴趣的同学可以自己研究一下.官方最后总结这是最为灵活的一种方式呢\n\n```\nThis dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp's ABI generator.\n此调度程序将大多数安全逻辑和控件放在操作处理程序中，但是，不能使用eosio-cpp的ABI生成器。 \n```\n```\nextern \"C\" void apply(uint64_t receiver, uint64_t code, uint64_t action) { \n  switch(action) {\n      case name(\"upsert\").value: return upsert(receiver, code);\n      case name(\"notify\").value: return notify(receiver, code);\n      case name(\"erase\").value: return erase(receiver, code);\n  }\n}\n```\n\n```\nTo handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely code). Having access to code inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence \"Fully Flexible.\"\n为了处理这些请求，我们将调度程序中的安全逻辑移动到操作中。这可以提供更多控制，但可能会引入冗余，特别是对于大型合同。最后，它完成了与上述模式相同的所有点，同时允许更多信息进入范围（即代码）。在某些情况下，访问操作中的代码可能很有用。这种模式在调度程序和操作中提供了最大的灵活性，因此“完全灵活”。\n```\n\n#### 自定义dispatcher 方式4\n* 官方说,上面自定义apply函数的时候,如果action少还是可以接受的,如果很多呢?就编程了体力劳动了,而且有可能出现漏洞.这显然和我们程序猿的做法不一致,所以官方最后给我们推荐了新的方法,功能类似,且减少体力劳动,不得不说还是很贴心的\n\n```\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver ) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n\n* 就是这么简单,虽然简单,但是我们还是得看看有什么魔法(以下内容为官方的介绍)\n\n1. 一定要使用这个 code == receiver的判断,而这个可以自动允许eosio.token进行transfer的方法呢\n\n```\nChecks if code==receiverand that the action is not transfer. If this condition is omitted, you may introduce a vulnerability into your contract. It allows the action through if the code is eosio.token and the action is transfer. This check prevents another contract with a transfer function from exploiting your contract.\n``` \n\n2. 合约的实例化,可以看出和之前的apply方法是一样的,之前是在apply函数中实例化,这里直接传入一个实例\n\n```\nInstantiates the TYPE (this would be your standard C++11 class)\n```\n\n3. 说内部调用了execute_action方法,和我们之前的设计一样\n\n```\nUse the EOSIO_DISPATCH_HELPER macro, which inserts a case for each MEMBER into your switch. Inside this case, it calls execute_action using a pattern very similar to the one demonstrated in the Flexible/Compatible Dispatcher defined above.\n```\n\n4. 直接替换就可以了.不用做任何改变  \n\n```\nYou can then use this macro the same way you would with the provided EOSIO_DISPATCH macro.\n```\n\n* 既然这样,这里多了一个EOSIO_DISPATCH_HELPER的宏,我们还是得去源码看看它究竟做了什么我们才能放心呢\n* 这里出现了一个小的惊喜,由于我目前的源码都是在eos去找,我居然没有找到EOSIO_DISPATCH_HELPER这个宏,这就尴尬了,转而我转向cdt的源码,总算找到了这个宏\n\n```\n// Helper macro for EOSIO_DISPATCH\n#define EOSIO_DISPATCH_HELPER( TYPE,  MEMBERS ) \\\n   BOOST_PP_SEQ_FOR_EACH( EOSIO_DISPATCH_INTERNAL, TYPE, MEMBERS )\n\n```\n\n```\n// Helper macro for EOSIO_DISPATCH_INTERNAL\n#define EOSIO_DISPATCH_INTERNAL( r, OP, elem ) \\\n   case eosio::name( BOOST_PP_STRINGIZE(elem) ).value: \\\n      eosio::execute_action( eosio::name(receiver), eosio::name(code), &OP::elem ); \\\n      break;\n```\n\n```\n#define EOSIO_DISPATCH( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver ) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n* 这里一下子三个宏了,我们关心的EOSIO_DISPATCH其实内部也是调用了EOSIO_DISPATCH_HELPER,所以这第三种方式定义的宏我觉得没有必要了哈,\n* 哎,官方的文档貌似又落后了,不过已经习以为常了呢.\n\n####  Security, Security, Security...\n```\nYour contract's first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.\n```\n\n* 安全第一,所以应该小心使用apply函数,所以官方最后建议还是直接使用EOSIO_DISPATCHER就可以了,至于原因则如下\n\n```\nFor simple contracts that only execute internal public actions, the EOSIO_DISPATCH is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.\n```\n\n#### 猜想\n* 既然使用cdt中的EOSIO_DISPATCH就能够达到需求了,那我们该如何实现前面课程的监听呢?\n* 通过查看EOSIO_DISPATCHER的判断,这里是不允许code为eosio.token的的操作的记录的,既然这样那我们改造一下EOSIO_DISPATCHER如下所示\n\n```\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver || code == \"eosio.token\"_n.value && action == \"transfer\"_n.value) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n\n* 那么最终结果和上篇文章的内容是一样的,只是我们也没有自己实现apply函数了,而是借助于helper这个宏帮助我们完成\n\n```\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/print.hpp>\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\n\npublic:\n  using contract::contract;\n  \n  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}\n\n  [[eosio::action]]\n  void upsert(name user, std::string first_name, std::string last_name) {\n    require_auth(user);\n    address_index addresses(_code, _code.value);\n    auto iterator = addresses.find(user.value);\n    if( iterator == addresses.end() )\n    {\n      addresses.emplace(user, [&]( auto& row ) {\n       row.key = user;\n       row.first_name = first_name;\n       row.last_name = last_name;\n      });\n      send_summary(user, \" successfully emplaced record to addressbook\");\n    }\n    else {\n      std::string changes;\n      addresses.modify(iterator, user, [&]( auto& row ) {\n        row.key = user;\n        row.first_name = first_name;\n        row.last_name = last_name;\n      });\n      send_summary(user, \" successfully modified record to addressbook\");\n    }\n  }\n\n  [[eosio::action]]\n  void erase(name user) {\n    require_auth(user);\n\n    address_index addresses(_self, _code.value);\n\n    auto iterator = addresses.find(user.value);\n    eosio_assert(iterator != addresses.end(), \"Record does not exist\");\n    addresses.erase(iterator);\n    send_summary(user, \" successfully erased record from addressbook\");\n  }\n\n  void transfer(uint64_t receiver, uint64_t code){\n    send_summary(name(code), \"eosio.token transfer\");\n  }\n\nprivate:\n  struct [[eosio::table]] person {\n    name key;\n    std::string first_name;\n    std::string last_name;\n    uint64_t primary_key() const { return key.value; }\n  };\n\n  void send_summary(name user, std::string message) {\n    action(\n      permission_level{get_self(),\"active\"_n},\n      get_self(),\n      \"notify\"_n,\n      std::make_tuple(user, name{user}.to_string() + message)\n    ).send();\n  };\n\n  typedef eosio::multi_index<\"people\"_n, person> address_index;\n};\n\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver || code == \"eosio.token\"_n.value && action == \"transfer\"_n.value) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n\nEOSIO_DISPATCH_CUSTOM( addressbook, (upsert)(erase)(transfer) )\n```\n\n#### 结果验证\n* 通过我们自定义的dispatcher,我们已经实现了和上篇文章同样的功能,且不用自己实现apply函数,极大的简化了操作\n* 当然,目前的方式我们允许的是eosio.token执行transfer操作,那么我们也可以仿照实现其他特殊合约的记录,比如说eosio.system(用来操作cpu,ram)的或者其他我们自定义的合约\n\n![shaokun](/img_eos1/eos_gif_1.gif)\n\n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-03)\n\n#### 总结\n* 上一篇最后一个问题,我们已经记录了当我们账户上eos的交易的数据,但是具体的数据我们还不知道呢?比如说转给谁?谁转的?转了多少?还有memo(这个也很重要的,有时候很多数据的有效性可以通过它来进行验证)\n* 第二个问题,我们怎么在链上发我们的自己的代币呢?而且这个代币要符合eos代币的标准标准(这里为什么要抛出这个问题呢?因为我只在本地的环境按照教程走,发过行过代币,但是在测试网,我没有eosio.token的账号,我居然懵逼了,不知道怎么发了),过程很简单,但是留给各位同学自己也思考一下\n* 三篇文章下来,可以看到跟着官网走,有好处,权威,也有坑,文档总是落后实际情况,那么我们能做点什么吗?我觉得能的,虽然语法变了,但是核心不变,所以我们掌握它的基础性内容,变来变去我们只需要去补一点它变化的内容就好了,如果你之前有基础,这应该就是手到擒来的事情了,只是,看我们还能否学得动哈^_^\n\n#### 啰嗦一句\n* 莫名其妙,就叫收拾东西走人了,具体原因都没有,寒冬的果实也落在了我的头上了...(ps:猜测是俺站错了队吧,整个团队一起走人了...)\n* 换个方向想,何尝不是又给了我们人生中多一次选择的机会呢?\n* 这应该是年前的最后一篇文章了,希望年后能够继续给大家分享一些dapp开发的知识,谢谢你的阅读\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/eos中inline action的理解6.md","raw":"---\ntitle: eos的dispatcher的使用(3 完结)\ndate: 2019-01-26 15:08:04\n---\n\n#### 前言\n经过前面两篇文章的练习,相信各位同学都已经对自定义dispatcher已经有了自己的看法了,那么今天我们继续跟着官方的教程走,把接下来的知识点完整一下\n\n#### 自定义dispatcher 方式3\n* 这种方式官方说了,不能用于eosio-cpp生成abi,所以我也不详细去探究了,有兴趣的同学可以自己研究一下.官方最后总结这是最为灵活的一种方式呢\n\n```\nThis dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp's ABI generator.\n此调度程序将大多数安全逻辑和控件放在操作处理程序中，但是，不能使用eosio-cpp的ABI生成器。 \n```\n```\nextern \"C\" void apply(uint64_t receiver, uint64_t code, uint64_t action) { \n  switch(action) {\n      case name(\"upsert\").value: return upsert(receiver, code);\n      case name(\"notify\").value: return notify(receiver, code);\n      case name(\"erase\").value: return erase(receiver, code);\n  }\n}\n```\n\n```\nTo handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely code). Having access to code inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence \"Fully Flexible.\"\n为了处理这些请求，我们将调度程序中的安全逻辑移动到操作中。这可以提供更多控制，但可能会引入冗余，特别是对于大型合同。最后，它完成了与上述模式相同的所有点，同时允许更多信息进入范围（即代码）。在某些情况下，访问操作中的代码可能很有用。这种模式在调度程序和操作中提供了最大的灵活性，因此“完全灵活”。\n```\n\n#### 自定义dispatcher 方式4\n* 官方说,上面自定义apply函数的时候,如果action少还是可以接受的,如果很多呢?就编程了体力劳动了,而且有可能出现漏洞.这显然和我们程序猿的做法不一致,所以官方最后给我们推荐了新的方法,功能类似,且减少体力劳动,不得不说还是很贴心的\n\n```\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver ) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n\n* 就是这么简单,虽然简单,但是我们还是得看看有什么魔法(以下内容为官方的介绍)\n\n1. 一定要使用这个 code == receiver的判断,而这个可以自动允许eosio.token进行transfer的方法呢\n\n```\nChecks if code==receiverand that the action is not transfer. If this condition is omitted, you may introduce a vulnerability into your contract. It allows the action through if the code is eosio.token and the action is transfer. This check prevents another contract with a transfer function from exploiting your contract.\n``` \n\n2. 合约的实例化,可以看出和之前的apply方法是一样的,之前是在apply函数中实例化,这里直接传入一个实例\n\n```\nInstantiates the TYPE (this would be your standard C++11 class)\n```\n\n3. 说内部调用了execute_action方法,和我们之前的设计一样\n\n```\nUse the EOSIO_DISPATCH_HELPER macro, which inserts a case for each MEMBER into your switch. Inside this case, it calls execute_action using a pattern very similar to the one demonstrated in the Flexible/Compatible Dispatcher defined above.\n```\n\n4. 直接替换就可以了.不用做任何改变  \n\n```\nYou can then use this macro the same way you would with the provided EOSIO_DISPATCH macro.\n```\n\n* 既然这样,这里多了一个EOSIO_DISPATCH_HELPER的宏,我们还是得去源码看看它究竟做了什么我们才能放心呢\n* 这里出现了一个小的惊喜,由于我目前的源码都是在eos去找,我居然没有找到EOSIO_DISPATCH_HELPER这个宏,这就尴尬了,转而我转向cdt的源码,总算找到了这个宏\n\n```\n// Helper macro for EOSIO_DISPATCH\n#define EOSIO_DISPATCH_HELPER( TYPE,  MEMBERS ) \\\n   BOOST_PP_SEQ_FOR_EACH( EOSIO_DISPATCH_INTERNAL, TYPE, MEMBERS )\n\n```\n\n```\n// Helper macro for EOSIO_DISPATCH_INTERNAL\n#define EOSIO_DISPATCH_INTERNAL( r, OP, elem ) \\\n   case eosio::name( BOOST_PP_STRINGIZE(elem) ).value: \\\n      eosio::execute_action( eosio::name(receiver), eosio::name(code), &OP::elem ); \\\n      break;\n```\n\n```\n#define EOSIO_DISPATCH( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver ) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n* 这里一下子三个宏了,我们关心的EOSIO_DISPATCH其实内部也是调用了EOSIO_DISPATCH_HELPER,所以这第三种方式定义的宏我觉得没有必要了哈,\n* 哎,官方的文档貌似又落后了,不过已经习以为常了呢.\n\n####  Security, Security, Security...\n```\nYour contract's first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.\n```\n\n* 安全第一,所以应该小心使用apply函数,所以官方最后建议还是直接使用EOSIO_DISPATCHER就可以了,至于原因则如下\n\n```\nFor simple contracts that only execute internal public actions, the EOSIO_DISPATCH is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.\n```\n\n#### 猜想\n* 既然使用cdt中的EOSIO_DISPATCH就能够达到需求了,那我们该如何实现前面课程的监听呢?\n* 通过查看EOSIO_DISPATCHER的判断,这里是不允许code为eosio.token的的操作的记录的,既然这样那我们改造一下EOSIO_DISPATCHER如下所示\n\n```\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver || code == \"eosio.token\"_n.value && action == \"transfer\"_n.value) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n```\n\n* 那么最终结果和上篇文章的内容是一样的,只是我们也没有自己实现apply函数了,而是借助于helper这个宏帮助我们完成\n\n```\n#include <eosiolib/eosio.hpp>\n#include <eosiolib/print.hpp>\n\nusing namespace eosio;\n\nclass [[eosio::contract]] addressbook : public eosio::contract {\n\npublic:\n  using contract::contract;\n  \n  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}\n\n  [[eosio::action]]\n  void upsert(name user, std::string first_name, std::string last_name) {\n    require_auth(user);\n    address_index addresses(_code, _code.value);\n    auto iterator = addresses.find(user.value);\n    if( iterator == addresses.end() )\n    {\n      addresses.emplace(user, [&]( auto& row ) {\n       row.key = user;\n       row.first_name = first_name;\n       row.last_name = last_name;\n      });\n      send_summary(user, \" successfully emplaced record to addressbook\");\n    }\n    else {\n      std::string changes;\n      addresses.modify(iterator, user, [&]( auto& row ) {\n        row.key = user;\n        row.first_name = first_name;\n        row.last_name = last_name;\n      });\n      send_summary(user, \" successfully modified record to addressbook\");\n    }\n  }\n\n  [[eosio::action]]\n  void erase(name user) {\n    require_auth(user);\n\n    address_index addresses(_self, _code.value);\n\n    auto iterator = addresses.find(user.value);\n    eosio_assert(iterator != addresses.end(), \"Record does not exist\");\n    addresses.erase(iterator);\n    send_summary(user, \" successfully erased record from addressbook\");\n  }\n\n  void transfer(uint64_t receiver, uint64_t code){\n    send_summary(name(code), \"eosio.token transfer\");\n  }\n\nprivate:\n  struct [[eosio::table]] person {\n    name key;\n    std::string first_name;\n    std::string last_name;\n    uint64_t primary_key() const { return key.value; }\n  };\n\n  void send_summary(name user, std::string message) {\n    action(\n      permission_level{get_self(),\"active\"_n},\n      get_self(),\n      \"notify\"_n,\n      std::make_tuple(user, name{user}.to_string() + message)\n    ).send();\n  };\n\n  typedef eosio::multi_index<\"people\"_n, person> address_index;\n};\n\n#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\\nextern \"C\" { \\\n   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\\n      if( code == receiver || code == \"eosio.token\"_n.value && action == \"transfer\"_n.value) { \\\n         switch( action ) { \\\n            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\\n         } \\\n         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\\n      } \\\n   } \\\n} \\\n\nEOSIO_DISPATCH_CUSTOM( addressbook, (upsert)(erase)(transfer) )\n```\n\n#### 结果验证\n* 通过我们自定义的dispatcher,我们已经实现了和上篇文章同样的功能,且不用自己实现apply函数,极大的简化了操作\n* 当然,目前的方式我们允许的是eosio.token执行transfer操作,那么我们也可以仿照实现其他特殊合约的记录,比如说eosio.system(用来操作cpu,ram)的或者其他我们自定义的合约\n\n![shaokun](/img_eos1/eos_gif_1.gif)\n\n[本课源码](https://github.com/shaokun11/eosabout/tree/eos-dispatcher-03)\n\n#### 总结\n* 上一篇最后一个问题,我们已经记录了当我们账户上eos的交易的数据,但是具体的数据我们还不知道呢?比如说转给谁?谁转的?转了多少?还有memo(这个也很重要的,有时候很多数据的有效性可以通过它来进行验证)\n* 第二个问题,我们怎么在链上发我们的自己的代币呢?而且这个代币要符合eos代币的标准标准(这里为什么要抛出这个问题呢?因为我只在本地的环境按照教程走,发过行过代币,但是在测试网,我没有eosio.token的账号,我居然懵逼了,不知道怎么发了),过程很简单,但是留给各位同学自己也思考一下\n* 三篇文章下来,可以看到跟着官网走,有好处,权威,也有坑,文档总是落后实际情况,那么我们能做点什么吗?我觉得能的,虽然语法变了,但是核心不变,所以我们掌握它的基础性内容,变来变去我们只需要去补一点它变化的内容就好了,如果你之前有基础,这应该就是手到擒来的事情了,只是,看我们还能否学得动哈^_^\n\n#### 啰嗦一句\n* 莫名其妙,就叫收拾东西走人了,具体原因都没有,寒冬的果实也落在了我的头上了...(ps:猜测是俺站错了队吧,整个团队一起走人了...)\n* 换个方向想,何尝不是又给了我们人生中多一次选择的机会呢?\n* 这应该是年前的最后一篇文章了,希望年后能够继续给大家分享一些dapp开发的知识,谢谢你的阅读\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"eos中inline action的理解6","published":1,"updated":"2019-02-18T13:13:08.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52u000jnh7sxlctodry","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>经过前面两篇文章的练习,相信各位同学都已经对自定义dispatcher已经有了自己的看法了,那么今天我们继续跟着官方的教程走,把接下来的知识点完整一下</p>\n<h4 id=\"自定义dispatcher-方式3\"><a href=\"#自定义dispatcher-方式3\" class=\"headerlink\" title=\"自定义dispatcher 方式3\"></a>自定义dispatcher 方式3</h4><ul>\n<li>这种方式官方说了,不能用于eosio-cpp生成abi,所以我也不详细去探究了,有兴趣的同学可以自己研究一下.官方最后总结这是最为灵活的一种方式呢</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp&apos;s ABI generator.</span><br><span class=\"line\">此调度程序将大多数安全逻辑和控件放在操作处理程序中，但是，不能使用eosio-cpp的ABI生成器。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123; </span><br><span class=\"line\">  switch(action) &#123;</span><br><span class=\"line\">      case name(&quot;upsert&quot;).value: return upsert(receiver, code);</span><br><span class=\"line\">      case name(&quot;notify&quot;).value: return notify(receiver, code);</span><br><span class=\"line\">      case name(&quot;erase&quot;).value: return erase(receiver, code);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely code). Having access to code inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence &quot;Fully Flexible.&quot;</span><br><span class=\"line\">为了处理这些请求，我们将调度程序中的安全逻辑移动到操作中。这可以提供更多控制，但可能会引入冗余，特别是对于大型合同。最后，它完成了与上述模式相同的所有点，同时允许更多信息进入范围（即代码）。在某些情况下，访问操作中的代码可能很有用。这种模式在调度程序和操作中提供了最大的灵活性，因此“完全灵活”。</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义dispatcher-方式4\"><a href=\"#自定义dispatcher-方式4\" class=\"headerlink\" title=\"自定义dispatcher 方式4\"></a>自定义dispatcher 方式4</h4><ul>\n<li>官方说,上面自定义apply函数的时候,如果action少还是可以接受的,如果很多呢?就编程了体力劳动了,而且有可能出现漏洞.这显然和我们程序猿的做法不一致,所以官方最后给我们推荐了新的方法,功能类似,且减少体力劳动,不得不说还是很贴心的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\</span><br><span class=\"line\">extern &quot;C&quot; &#123; \\</span><br><span class=\"line\">   void apply( uint64_t receiver, uint64_t code, uint64_t action ) &#123; \\</span><br><span class=\"line\">      if( code == receiver ) &#123; \\</span><br><span class=\"line\">         switch( action ) &#123; \\</span><br><span class=\"line\">            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\</span><br><span class=\"line\">         &#125; \\</span><br><span class=\"line\">         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\</span><br><span class=\"line\">      &#125; \\</span><br><span class=\"line\">   &#125; \\</span><br><span class=\"line\">&#125; \\</span><br></pre></td></tr></table></figure>\n<ul>\n<li>就是这么简单,虽然简单,但是我们还是得看看有什么魔法(以下内容为官方的介绍)</li>\n</ul>\n<ol>\n<li>一定要使用这个 code == receiver的判断,而这个可以自动允许eosio.token进行transfer的方法呢</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checks if code==receiverand that the action is not transfer. If this condition is omitted, you may introduce a vulnerability into your contract. It allows the action through if the code is eosio.token and the action is transfer. This check prevents another contract with a transfer function from exploiting your contract.</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">2. 合约的实例化,可以看出和之前的apply方法是一样的,之前是在apply函数中实例化,这里直接传入一个实例</span><br></pre></td></tr></table></figure>\n<p>Instantiates the TYPE (this would be your standard C++11 class)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 说内部调用了execute_action方法,和我们之前的设计一样</span><br></pre></td></tr></table></figure></p>\n<p>Use the EOSIO_DISPATCH_HELPER macro, which inserts a case for each MEMBER into your switch. Inside this case, it calls execute_action using a pattern very similar to the one demonstrated in the Flexible/Compatible Dispatcher defined above.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 直接替换就可以了.不用做任何改变</span><br></pre></td></tr></table></figure></p>\n<p>You can then use this macro the same way you would with the provided EOSIO_DISPATCH macro.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 既然这样,这里多了一个EOSIO_DISPATCH_HELPER的宏,我们还是得去源码看看它究竟做了什么我们才能放心呢</span><br><span class=\"line\">* 这里出现了一个小的惊喜,由于我目前的源码都是在eos去找,我居然没有找到EOSIO_DISPATCH_HELPER这个宏,这就尴尬了,转而我转向cdt的源码,总算找到了这个宏</span><br></pre></td></tr></table></figure></p>\n<p>// Helper macro for EOSIO_DISPATCH</p>\n<p>#define EOSIO_DISPATCH_HELPER( TYPE,  MEMBERS ) \\<br>   BOOST_PP_SEQ_FOR_EACH( EOSIO_DISPATCH_INTERNAL, TYPE, MEMBERS )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// Helper macro for EOSIO_DISPATCH_INTERNAL</p>\n<p>#define EOSIO_DISPATCH_INTERNAL( r, OP, elem ) \\<br>   case eosio::name( BOOST_PP_STRINGIZE(elem) ).value: \\<br>      eosio::execute_action( eosio::name(receiver), eosio::name(code), &amp;OP::elem ); \\<br>      break;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>#define EOSIO_DISPATCH( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver ) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 这里一下子三个宏了,我们关心的EOSIO_DISPATCH其实内部也是调用了EOSIO_DISPATCH_HELPER,所以这第三种方式定义的宏我觉得没有必要了哈,</span><br><span class=\"line\">* 哎,官方的文档貌似又落后了,不过已经习以为常了呢.</span><br><span class=\"line\"></span><br><span class=\"line\">####  Security, Security, Security...</span><br></pre></td></tr></table></figure></p>\n<p>Your contract’s first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 安全第一,所以应该小心使用apply函数,所以官方最后建议还是直接使用EOSIO_DISPATCHER就可以了,至于原因则如下</span><br></pre></td></tr></table></figure></p>\n<p>For simple contracts that only execute internal public actions, the EOSIO_DISPATCH is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 猜想</span><br><span class=\"line\">* 既然使用cdt中的EOSIO_DISPATCH就能够达到需求了,那我们该如何实现前面课程的监听呢?</span><br><span class=\"line\">* 通过查看EOSIO_DISPATCHER的判断,这里是不允许code为eosio.token的的操作的记录的,既然这样那我们改造一下EOSIO_DISPATCHER如下所示</span><br></pre></td></tr></table></figure></p>\n<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 那么最终结果和上篇文章的内容是一样的,只是我们也没有自己实现apply函数了,而是借助于helper这个宏帮助我们完成</span><br></pre></td></tr></table></figure></p>\n<p>#include &lt;eosiolib/eosio.hpp&gt;</p>\n<p>#include &lt;eosiolib/print.hpp&gt;</p>\n<p>using namespace eosio;</p>\n<p>class [[eosio::contract]] addressbook : public eosio::contract {</p>\n<p>public:<br>  using contract::contract;</p>\n<p>  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}</const></p>\n<p>  [[eosio::action]]<br>  void upsert(name user, std::string first_name, std::string last_name) {<br>    require_auth(user);<br>    address_index addresses(_code, _code.value);<br>    auto iterator = addresses.find(user.value);<br>    if( iterator == addresses.end() )<br>    {<br>      addresses.emplace(user, <a href=\"auto&amp; row\">&amp;</a> {<br>       row.key = user;<br>       row.first_name = first_name;<br>       row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully emplaced record to addressbook”);<br>    }<br>    else {<br>      std::string changes;<br>      addresses.modify(iterator, user, <a href=\"auto&amp; row\">&amp;</a> {<br>        row.key = user;<br>        row.first_name = first_name;<br>        row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully modified record to addressbook”);<br>    }<br>  }</p>\n<p>  [[eosio::action]]<br>  void erase(name user) {<br>    require_auth(user);</p>\n<pre><code>address_index addresses(_self, _code.value);\n\nauto iterator = addresses.find(user.value);\neosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);\naddresses.erase(iterator);\nsend_summary(user, &quot; successfully erased record from addressbook&quot;);\n</code></pre><p>  }</p>\n<p>  void transfer(uint64_t receiver, uint64_t code){<br>    send_summary(name(code), “eosio.token transfer”);<br>  }</p>\n<p>private:<br>  struct [[eosio::table]] person {<br>    name key;<br>    std::string first_name;<br>    std::string last_name;<br>    uint64_t primary_key() const { return key.value; }<br>  };</p>\n<p>  void send_summary(name user, std::string message) {<br>    action(<br>      permission_level{get_self(),”active”_n},<br>      get_self(),<br>      “notify”_n,<br>      std::make_tuple(user, name{user}.to_string() + message)<br>    ).send();<br>  };</p>\n<p>  typedef eosio::multi_index&lt;”people”_n, person&gt; address_index;<br>};</p>\n<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\</p>\n<p>EOSIO_DISPATCH_CUSTOM( addressbook, (upsert)(erase)(transfer) )<br><code>`</code></p>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><ul>\n<li>通过我们自定义的dispatcher,我们已经实现了和上篇文章同样的功能,且不用自己实现apply函数,极大的简化了操作</li>\n<li>当然,目前的方式我们允许的是eosio.token执行transfer操作,那么我们也可以仿照实现其他特殊合约的记录,比如说eosio.system(用来操作cpu,ram)的或者其他我们自定义的合约</li>\n</ul>\n<p><img src=\"/img_eos1/eos_gif_1.gif\" alt=\"shaokun\"></p>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-03\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>上一篇最后一个问题,我们已经记录了当我们账户上eos的交易的数据,但是具体的数据我们还不知道呢?比如说转给谁?谁转的?转了多少?还有memo(这个也很重要的,有时候很多数据的有效性可以通过它来进行验证)</li>\n<li>第二个问题,我们怎么在链上发我们的自己的代币呢?而且这个代币要符合eos代币的标准标准(这里为什么要抛出这个问题呢?因为我只在本地的环境按照教程走,发过行过代币,但是在测试网,我没有eosio.token的账号,我居然懵逼了,不知道怎么发了),过程很简单,但是留给各位同学自己也思考一下</li>\n<li>三篇文章下来,可以看到跟着官网走,有好处,权威,也有坑,文档总是落后实际情况,那么我们能做点什么吗?我觉得能的,虽然语法变了,但是核心不变,所以我们掌握它的基础性内容,变来变去我们只需要去补一点它变化的内容就好了,如果你之前有基础,这应该就是手到擒来的事情了,只是,看我们还能否学得动哈^_^</li>\n</ul>\n<h4 id=\"啰嗦一句\"><a href=\"#啰嗦一句\" class=\"headerlink\" title=\"啰嗦一句\"></a>啰嗦一句</h4><ul>\n<li>莫名其妙,就叫收拾东西走人了,具体原因都没有,寒冬的果实也落在了我的头上了…(ps:猜测是俺站错了队吧,整个团队一起走人了…)</li>\n<li>换个方向想,何尝不是又给了我们人生中多一次选择的机会呢?</li>\n<li>这应该是年前的最后一篇文章了,希望年后能够继续给大家分享一些dapp开发的知识,谢谢你的阅读</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#110;&#x67;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#110;&#x67;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><p>经过前面两篇文章的练习,相信各位同学都已经对自定义dispatcher已经有了自己的看法了,那么今天我们继续跟着官方的教程走,把接下来的知识点完整一下</p>\n<h4 id=\"自定义dispatcher-方式3\"><a href=\"#自定义dispatcher-方式3\" class=\"headerlink\" title=\"自定义dispatcher 方式3\"></a>自定义dispatcher 方式3</h4><ul>\n<li>这种方式官方说了,不能用于eosio-cpp生成abi,所以我也不详细去探究了,有兴趣的同学可以自己研究一下.官方最后总结这是最为灵活的一种方式呢</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This dispatcher places most of the security logic and control inside the action handler, however, cannot use eosio-cpp&apos;s ABI generator.</span><br><span class=\"line\">此调度程序将大多数安全逻辑和控件放在操作处理程序中，但是，不能使用eosio-cpp的ABI生成器。</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">extern &quot;C&quot; void apply(uint64_t receiver, uint64_t code, uint64_t action) &#123; </span><br><span class=\"line\">  switch(action) &#123;</span><br><span class=\"line\">      case name(&quot;upsert&quot;).value: return upsert(receiver, code);</span><br><span class=\"line\">      case name(&quot;notify&quot;).value: return notify(receiver, code);</span><br><span class=\"line\">      case name(&quot;erase&quot;).value: return erase(receiver, code);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">To handle these requests, we move security logic that was otherwise in the dispatcher, into the action. This can provide more control, but may introduce redundancy, particularly for larger contracts. In the end, it accomplishes all the same points as the above patterns while allowing more information into the scope (namely code). Having access to code inside your action may be useful in some situations. This pattern provides the most flexibility in both the dispatcher and the action, hence &quot;Fully Flexible.&quot;</span><br><span class=\"line\">为了处理这些请求，我们将调度程序中的安全逻辑移动到操作中。这可以提供更多控制，但可能会引入冗余，特别是对于大型合同。最后，它完成了与上述模式相同的所有点，同时允许更多信息进入范围（即代码）。在某些情况下，访问操作中的代码可能很有用。这种模式在调度程序和操作中提供了最大的灵活性，因此“完全灵活”。</span><br></pre></td></tr></table></figure>\n<h4 id=\"自定义dispatcher-方式4\"><a href=\"#自定义dispatcher-方式4\" class=\"headerlink\" title=\"自定义dispatcher 方式4\"></a>自定义dispatcher 方式4</h4><ul>\n<li>官方说,上面自定义apply函数的时候,如果action少还是可以接受的,如果很多呢?就编程了体力劳动了,而且有可能出现漏洞.这显然和我们程序猿的做法不一致,所以官方最后给我们推荐了新的方法,功能类似,且减少体力劳动,不得不说还是很贴心的</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\</span><br><span class=\"line\">extern &quot;C&quot; &#123; \\</span><br><span class=\"line\">   void apply( uint64_t receiver, uint64_t code, uint64_t action ) &#123; \\</span><br><span class=\"line\">      if( code == receiver ) &#123; \\</span><br><span class=\"line\">         switch( action ) &#123; \\</span><br><span class=\"line\">            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\</span><br><span class=\"line\">         &#125; \\</span><br><span class=\"line\">         /* does not allow destructor of thiscontract to run: eosio_exit(0); */ \\</span><br><span class=\"line\">      &#125; \\</span><br><span class=\"line\">   &#125; \\</span><br><span class=\"line\">&#125; \\</span><br></pre></td></tr></table></figure>\n<ul>\n<li>就是这么简单,虽然简单,但是我们还是得看看有什么魔法(以下内容为官方的介绍)</li>\n</ul>\n<ol>\n<li>一定要使用这个 code == receiver的判断,而这个可以自动允许eosio.token进行transfer的方法呢</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Checks if code==receiverand that the action is not transfer. If this condition is omitted, you may introduce a vulnerability into your contract. It allows the action through if the code is eosio.token and the action is transfer. This check prevents another contract with a transfer function from exploiting your contract.</span><br><span class=\"line\">``` </span><br><span class=\"line\"></span><br><span class=\"line\">2. 合约的实例化,可以看出和之前的apply方法是一样的,之前是在apply函数中实例化,这里直接传入一个实例</span><br></pre></td></tr></table></figure>\n<p>Instantiates the TYPE (this would be your standard C++11 class)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">3. 说内部调用了execute_action方法,和我们之前的设计一样</span><br></pre></td></tr></table></figure></p>\n<p>Use the EOSIO_DISPATCH_HELPER macro, which inserts a case for each MEMBER into your switch. Inside this case, it calls execute_action using a pattern very similar to the one demonstrated in the Flexible/Compatible Dispatcher defined above.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">4. 直接替换就可以了.不用做任何改变</span><br></pre></td></tr></table></figure></p>\n<p>You can then use this macro the same way you would with the provided EOSIO_DISPATCH macro.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 既然这样,这里多了一个EOSIO_DISPATCH_HELPER的宏,我们还是得去源码看看它究竟做了什么我们才能放心呢</span><br><span class=\"line\">* 这里出现了一个小的惊喜,由于我目前的源码都是在eos去找,我居然没有找到EOSIO_DISPATCH_HELPER这个宏,这就尴尬了,转而我转向cdt的源码,总算找到了这个宏</span><br></pre></td></tr></table></figure></p>\n<p>// Helper macro for EOSIO_DISPATCH</p>\n<p>#define EOSIO_DISPATCH_HELPER( TYPE,  MEMBERS ) \\<br>   BOOST_PP_SEQ_FOR_EACH( EOSIO_DISPATCH_INTERNAL, TYPE, MEMBERS )</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>// Helper macro for EOSIO_DISPATCH_INTERNAL</p>\n<p>#define EOSIO_DISPATCH_INTERNAL( r, OP, elem ) \\<br>   case eosio::name( BOOST_PP_STRINGIZE(elem) ).value: \\<br>      eosio::execute_action( eosio::name(receiver), eosio::name(code), &amp;OP::elem ); \\<br>      break;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n<p>#define EOSIO_DISPATCH( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver ) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">* 这里一下子三个宏了,我们关心的EOSIO_DISPATCH其实内部也是调用了EOSIO_DISPATCH_HELPER,所以这第三种方式定义的宏我觉得没有必要了哈,</span><br><span class=\"line\">* 哎,官方的文档貌似又落后了,不过已经习以为常了呢.</span><br><span class=\"line\"></span><br><span class=\"line\">####  Security, Security, Security...</span><br></pre></td></tr></table></figure></p>\n<p>Your contract’s first line of security begins at your dispatcher. Understanding how the dispatching of actions to your contracts is handled is imperative to limiting exposure to logic inside your actions. Always take great caution when writing a custom dispatcher, and be aware of the security implications of each individual implementation method.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 安全第一,所以应该小心使用apply函数,所以官方最后建议还是直接使用EOSIO_DISPATCHER就可以了,至于原因则如下</span><br></pre></td></tr></table></figure></p>\n<p>For simple contracts that only execute internal public actions, the EOSIO_DISPATCH is more than suitable, eliminates cruft and greatly decrease the chance of introducing logical errors.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">#### 猜想</span><br><span class=\"line\">* 既然使用cdt中的EOSIO_DISPATCH就能够达到需求了,那我们该如何实现前面课程的监听呢?</span><br><span class=\"line\">* 通过查看EOSIO_DISPATCHER的判断,这里是不允许code为eosio.token的的操作的记录的,既然这样那我们改造一下EOSIO_DISPATCHER如下所示</span><br></pre></td></tr></table></figure></p>\n<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">* 那么最终结果和上篇文章的内容是一样的,只是我们也没有自己实现apply函数了,而是借助于helper这个宏帮助我们完成</span><br></pre></td></tr></table></figure></p>\n<p>#include &lt;eosiolib/eosio.hpp&gt;</p>\n<p>#include &lt;eosiolib/print.hpp&gt;</p>\n<p>using namespace eosio;</p>\n<p>class [[eosio::contract]] addressbook : public eosio::contract {</p>\n<p>public:<br>  using contract::contract;</p>\n<p>  addressbook(name receiver, name code,  datastream<const char*> ds): contract(receiver, code, ds) {}</const></p>\n<p>  [[eosio::action]]<br>  void upsert(name user, std::string first_name, std::string last_name) {<br>    require_auth(user);<br>    address_index addresses(_code, _code.value);<br>    auto iterator = addresses.find(user.value);<br>    if( iterator == addresses.end() )<br>    {<br>      addresses.emplace(user, <a href=\"auto&amp; row\">&amp;</a> {<br>       row.key = user;<br>       row.first_name = first_name;<br>       row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully emplaced record to addressbook”);<br>    }<br>    else {<br>      std::string changes;<br>      addresses.modify(iterator, user, <a href=\"auto&amp; row\">&amp;</a> {<br>        row.key = user;<br>        row.first_name = first_name;<br>        row.last_name = last_name;<br>      });<br>      send_summary(user, “ successfully modified record to addressbook”);<br>    }<br>  }</p>\n<p>  [[eosio::action]]<br>  void erase(name user) {<br>    require_auth(user);</p>\n<pre><code>address_index addresses(_self, _code.value);\n\nauto iterator = addresses.find(user.value);\neosio_assert(iterator != addresses.end(), &quot;Record does not exist&quot;);\naddresses.erase(iterator);\nsend_summary(user, &quot; successfully erased record from addressbook&quot;);\n</code></pre><p>  }</p>\n<p>  void transfer(uint64_t receiver, uint64_t code){<br>    send_summary(name(code), “eosio.token transfer”);<br>  }</p>\n<p>private:<br>  struct [[eosio::table]] person {<br>    name key;<br>    std::string first_name;<br>    std::string last_name;<br>    uint64_t primary_key() const { return key.value; }<br>  };</p>\n<p>  void send_summary(name user, std::string message) {<br>    action(<br>      permission_level{get_self(),”active”_n},<br>      get_self(),<br>      “notify”_n,<br>      std::make_tuple(user, name{user}.to_string() + message)<br>    ).send();<br>  };</p>\n<p>  typedef eosio::multi_index&lt;”people”_n, person&gt; address_index;<br>};</p>\n<p>#define EOSIO_DISPATCH_CUSTOM( TYPE, MEMBERS ) \\<br>extern “C” { \\<br>   void apply( uint64_t receiver, uint64_t code, uint64_t action ) { \\<br>      if( code == receiver || code == “eosio.token”_n.value &amp;&amp; action == “transfer”_n.value) { \\<br>         switch( action ) { \\<br>            EOSIO_DISPATCH_HELPER( TYPE, MEMBERS ) \\<br>         } \\<br>         /<em> does not allow destructor of thiscontract to run: eosio_exit(0); </em>/ \\<br>      } \\<br>   } \\<br>} \\</p>\n<p>EOSIO_DISPATCH_CUSTOM( addressbook, (upsert)(erase)(transfer) )<br><code>`</code></p>\n<h4 id=\"结果验证\"><a href=\"#结果验证\" class=\"headerlink\" title=\"结果验证\"></a>结果验证</h4><ul>\n<li>通过我们自定义的dispatcher,我们已经实现了和上篇文章同样的功能,且不用自己实现apply函数,极大的简化了操作</li>\n<li>当然,目前的方式我们允许的是eosio.token执行transfer操作,那么我们也可以仿照实现其他特殊合约的记录,比如说eosio.system(用来操作cpu,ram)的或者其他我们自定义的合约</li>\n</ul>\n<p><img src=\"/img_eos1/eos_gif_1.gif\" alt=\"shaokun\"></p>\n<p><a href=\"https://github.com/shaokun11/eosabout/tree/eos-dispatcher-03\" target=\"_blank\" rel=\"noopener\">本课源码</a></p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><ul>\n<li>上一篇最后一个问题,我们已经记录了当我们账户上eos的交易的数据,但是具体的数据我们还不知道呢?比如说转给谁?谁转的?转了多少?还有memo(这个也很重要的,有时候很多数据的有效性可以通过它来进行验证)</li>\n<li>第二个问题,我们怎么在链上发我们的自己的代币呢?而且这个代币要符合eos代币的标准标准(这里为什么要抛出这个问题呢?因为我只在本地的环境按照教程走,发过行过代币,但是在测试网,我没有eosio.token的账号,我居然懵逼了,不知道怎么发了),过程很简单,但是留给各位同学自己也思考一下</li>\n<li>三篇文章下来,可以看到跟着官网走,有好处,权威,也有坑,文档总是落后实际情况,那么我们能做点什么吗?我觉得能的,虽然语法变了,但是核心不变,所以我们掌握它的基础性内容,变来变去我们只需要去补一点它变化的内容就好了,如果你之前有基础,这应该就是手到擒来的事情了,只是,看我们还能否学得动哈^_^</li>\n</ul>\n<h4 id=\"啰嗦一句\"><a href=\"#啰嗦一句\" class=\"headerlink\" title=\"啰嗦一句\"></a>啰嗦一句</h4><ul>\n<li>莫名其妙,就叫收拾东西走人了,具体原因都没有,寒冬的果实也落在了我的头上了…(ps:猜测是俺站错了队吧,整个团队一起走人了…)</li>\n<li>换个方向想,何尝不是又给了我们人生中多一次选择的机会呢?</li>\n<li>这应该是年前的最后一篇文章了,希望年后能够继续给大家分享一些dapp开发的知识,谢谢你的阅读</li>\n</ul>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#110;&#x67;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#x61;&#x6f;&#107;&#117;&#110;&#105;&#110;&#x67;&#64;&#x67;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#109;</a><br>email_2: <a href=\"mailto:&#x73;&#107;&#x75;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;\" target=\"_blank\" rel=\"noopener\">&#x73;&#107;&#x75;&#x6e;&#110;&#121;&#64;&#x31;&#x36;&#51;&#46;&#x63;&#x6f;&#x6d;</a></p>\n"},{"title":"带你以通俗易懂的小例子了解bancor","date":"2018-10-02T06:33:22.000Z","_content":"\n##### bancor的简单概述\n>bancor是一种算法用于区块链的一种新的token的交易方式，目的是解决长尾的问题，增加ERC20的流通。长尾简单理解就是99%和1%的关系，即1%的token在大家的认知中有实际价值，而99%的token是没有的。那么通过bancor协议就是可以解决这99%的token，也可以给一个机会，让他们也有实际的价值。  \n>具体可访问[bancor github repo](https://github.com/bancorprotocol/contracts)，这里有详细的介绍和白皮书\n\n##### bancor名词展示\n\n*以下资料来自网络*  **start**\n\nToken的供应量【Smart Token's Supply】，简称Supply；\n\nToken的价格【Smart Token's Price 】，简称Price；\n\nToken的总市值【Smart Token's Total Value】，简称TotalValue；\n\n储备金余额【Connector Balance】，简称Balance；\n\n储备金固定比率【Connector Weight】，简称CW。\n\n计算公式如下：\n\n\tCW = Balance / TotalValue;\n\n\tTotalValue = Price * Supply;\n\n\tPrice = Balance /（Supply * CW）\n举例：若当前AToken的发行量为1000，报价为0.5个ETH兑换1个AToken，那么AToken的总价值为500个ETH，但是储备金余额可能并没有500个ETH，比如为250个ETH，那么CW则为0.5（50%)  \n\nToken买入计算公式：\n\n\tToken_Return = Supply *（（1 + ETH_Amount / Balance）^ CW - 1）\n\t//此公式的证明可以通过查看白皮书\n>例如 若当前AToken的发行量为1000，储备金余额为250个ETH，CW为0.5，那么当前的报价则为0.5个ETH兑换1个AToken；现在Bob想花750个ETH购买AToken，带入公式：Token_Return = 1000 *（（1 + 750 / 250）^ 0.5 - 1）= 1000\n\n>即Bob花了750个ETH购买了1000个AToken，本次购买的平均价格为0.75个ETH兑换1个AToken。  \nBob的购买行为推高了AToken的报价。若Bob接着购买同样数量的AToken，则需要付出更多的ETH代价，每一笔购买都会继续推高AToken的报价。\n\nToken卖出计算公式：\n\n\tETH_Return = Balance *（1 - （1 - Token_Amount / Supply）^ （1 / CW））\n\n>在Bob的那笔交易完成后，AToken的发行总量为2000个，储备金余额为1000个ETH，CW维持不变、仍然为0.5，那么通过公式可以计算当前的报价为1个ETH兑换1个AToken；现在Alice想卖掉1000个AToken，带入公式：ETH_Return = 1000 *（1 - （1 - 1000 / 2000）^ （1 /0.5））= 750\n\n>即Alice 卖掉了1000个AToken，获得了750个ETH，本次购买的平均价格为0.75个ETH兑换1个AToken。因为Bob的购买行为推高了AToken的报价，而Alice是在Bob的购买行为之后卖掉了AToken，所以Alice卖到了相对较高的价位。假如没有Bob的购买行为，回到AToken的供应量为1000的那个时候，Alice卖掉全部的AToken，也只能获得250个ETH  \n\n智能代币(Smart Tokens)\n>智能代币是Bancor协议的核心。它们的运作类似于常规代币，在ETH区块链上使用的符合ERC20标准[5]，但也要包含额外的逻辑，即允许用户通过它的智能合约直接购买和出售代币，价格通过程序自动调整以反映供求关系。实际上，智能代币拥有一种内置的流动性机制，确保它们可以持续地为兑换为其他代币。  \n  \n智能代币连接器(Smart Token connectors)  \n>智能代币连接器可以被视为分布式、自主、透明和可预测的做市商，而不是交易所。智能代币通过程序自动调整它们的价格，来管理它们的连接器准备金，以保持它们与智能代币的总市值之间的比率是恒定的。\n锚定代币(connected token)\n>每个智能代币都配置了连接器模块，这些模块持有它连接的另一个代币作为准备金（例如，BNT智能代币有一个连接到ETH的连接器，它持有ETH作为准备金）。ETH此时就是连接器代币。\n\n代币网络(token network)\n>智能代币可以实现自己和它们的连接代币之间进行即时兑换。这个功能足以使智能代币即时兑换为一定数量的以类似的方式连接到同一网络的任何其他代币。通过这种方式，智能代币可以连接到无限数量的代币，从而创建一个分布式的流动性网络，该网络可能由数百万个代币组成，这些代币都可以以不断计算的价格自动地相互兑换。\n\n中继代币(Relay Token)  \n>具有两个连接器的智能代币，其总CW恰好为100%，其功能类似于分布式代币兑换币对。中继代币允许用户在两个连接代币之间互相兑换，通过两步操作实现，即购买一种代币，立即出售另外一种代币。\n\n流动性代币(Liquid Tokens)\n>具有组合连接器总权重低于100%（更典型的低于20%）的智能代币成为流动性代币。可能有一个或者多个连接器。例如，BTN具有单个权重为10%的ETH连接器。流动性代币可以使用连接器代币买卖（使用Bancor公式计算它相对于连接代币的价格），并且可以自适应调节供应量，在购买时增加，出售时减少。  \n\n代理代币(Proxy Token)\n>具有一个连接器占100%权重的智能代币。\n\n组合代币(Array Token)\n>具有三个或者更多连接器权重为100%的智能代币。\n\n糖果代币(Bounty Tokens)\n\n>具有单个尚未激活连接器的智能代币（当前连接器准备金为0），可以向早起持有者（例如社区支持者）发放将来会发行的代币。\n\n网络代币(Network Tokens)\n\n>由多个(>2)智能代币持有作为连接代币的智能代币,BNT就是一个网络代币，也是一个流动性代币。\n\n交易者\n>持有、兑换和支付智能代币的终端用户\n\n智能代币发行者\n>发行智能代币，配置初始供应量、价格、连接器权重CW和管理智能代币初始发行的人员、公司、社区、组织或基金会。还包括将现有ERC20代币连接到Bancor网络的中继代币的创建者。\n\n资产代币化者\n>将代理代币或者组合代币映射到实体资产或者其他区块链上代币的创建者。这允许智能代币连接到更广泛的资产，如比特币、法定货币、黄金或其他新兴的区块链代币。\n\n套利者\n>监控Bancor流动性网络与外部交易所或者其他智能代币的价格，并且通过套利消除价差的交易者。套利者通过消除价差获得奖励，因此是Bancor生态系统的重要参与者。 \n\n***end***\n\n##### 我之理解 \n\n\tcw的理解可以参考很那张很经典的图\n\tcw<50%:price与supply的变化可理解为指数函数y = x^N 的形式变化\n\tcw=50%:price与supply的变化可理解为一次函数y = ax (a>0)的形式变化\n\tcw>50%:price与supply的变化可理解为对数函数y = y=logN(x)的形式变化\n\tcw=100%:price与supply的变化可理解为常数函数y = x的形式变化  \n\n1. 我发行一个smart token（暂且叫sk）,总量1000个 ，即supply= 1000 sk\n2. 预估一下我这个项目的价值，暂且估计价值1000个eth ，即TotalValue = 1000 eth\n3. 而我只有100个eth,那作为储备金，剩余的向大家融资吧,即balance = 100 eth\n4. 设定cw = 10%，\n5. 根据算法，得到price = 1 sk/eth，\n6. 到此，可理解为我用100eth以单价为10买了1000 sk,\n7. 使用100 eth买入，根据买入公式，得到(（1+（100/100））^0.1 - 1) * 1000= 0.0718 *  1000 = 71.8个sk，\n8. 当执行上笔交易后，cw是不会变得，其余的会动态调整。那么此时的sk supply = 1071.8 sk,balance = 200 eth，price = 1.866 sk / eth\n9. 这里可以看到买入100个后，一个sk价值1.866个eth,价格上涨了呢。这里有兴趣的同学可以试试连续分批次买10次，每次10个eth，可以看到价格的变化,最终的结果也是一样的，这就是bancor算法保证的结果\n9. 再继续使用100eth买入，根据买入公式，得到(（1+（100/200））^0.1 - 1) * 1071.8= 0.0414 *  1071.8 = 44.37个sk，这样后来买的价格就比之前的高了，获得的sk就会少，也就是价格高了\n10. supply = 1116.7 sk,balance = 300 eth，price = 26.86 sk/eth 单价已经翻了20倍了\n11. 卖出50 sk，根据卖出公式 300 *（1 - 50/1116.7）^(1/0.1) = 189.7488 eth   \n12. 额，初始值设定的不恰当，整个流程算出来的结果有点恐怖，有兴趣的同学可以按照流程调整一下初始值哈0.0\n13. 这里可能有同学会问了，我刚使用100eth获得44个sk,我马上又卖出50个sk可以得到189个eth，大赚了啊。理论上是成立的，但是你得保证你这两个操作中间没有其他人的卖出哈（买入你就赚得越多），其他人卖出之后，你再去卖价格就低了，所以得自己评估风险哦  \n\n**文章允许转载，但请注明出处，谢谢**\n\n小结：\n\n* 控制cw的变化，可以控制token的价格的走势\n* 买入,会提高smart token的价格，卖出会降低smart token的价格，具体变化由cw的决定\n* 缺点：这些数据都是采用智能合约编写的，无法改变。但是项目方可以更改cw的值，从而控制整个token的价格走势\n* 优点：你如果持有smart token是可以随时和储备金类型的token进行买卖的。这都是由智能合约自动执行，这点可以相对于传统的1co有着更好的安全，至少你持有的token有着更好的流通性，随时都可以流通，也可以换取其他的token或者储备金的token  \n\n##### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n##### 资料更新 2018-10-13 15:50:20\n更新一下，这里补上bancor的经典cw图，便于大家理解。  \n![cw](/bancor/bancor.png)  \n根据这张图中的曲线，那么你所持有的币的价值就是等于曲线上任意两点作x轴 所形成的面积。所以任何一点点的买入卖出都会影响整个智能代币的价格  \n另外附上bancor的白皮书  \n[bancor 白皮书 英文版](https://storage.googleapis.com/website-bancor/2018/04/01ba8253-bancor_protocol_whitepaper_en.pdf)\n\n","source":"_posts/关于bancor的理解.md","raw":"---\ntitle: 带你以通俗易懂的小例子了解bancor\ndate: 2018-10-02 14:33:22\n---\n\n##### bancor的简单概述\n>bancor是一种算法用于区块链的一种新的token的交易方式，目的是解决长尾的问题，增加ERC20的流通。长尾简单理解就是99%和1%的关系，即1%的token在大家的认知中有实际价值，而99%的token是没有的。那么通过bancor协议就是可以解决这99%的token，也可以给一个机会，让他们也有实际的价值。  \n>具体可访问[bancor github repo](https://github.com/bancorprotocol/contracts)，这里有详细的介绍和白皮书\n\n##### bancor名词展示\n\n*以下资料来自网络*  **start**\n\nToken的供应量【Smart Token's Supply】，简称Supply；\n\nToken的价格【Smart Token's Price 】，简称Price；\n\nToken的总市值【Smart Token's Total Value】，简称TotalValue；\n\n储备金余额【Connector Balance】，简称Balance；\n\n储备金固定比率【Connector Weight】，简称CW。\n\n计算公式如下：\n\n\tCW = Balance / TotalValue;\n\n\tTotalValue = Price * Supply;\n\n\tPrice = Balance /（Supply * CW）\n举例：若当前AToken的发行量为1000，报价为0.5个ETH兑换1个AToken，那么AToken的总价值为500个ETH，但是储备金余额可能并没有500个ETH，比如为250个ETH，那么CW则为0.5（50%)  \n\nToken买入计算公式：\n\n\tToken_Return = Supply *（（1 + ETH_Amount / Balance）^ CW - 1）\n\t//此公式的证明可以通过查看白皮书\n>例如 若当前AToken的发行量为1000，储备金余额为250个ETH，CW为0.5，那么当前的报价则为0.5个ETH兑换1个AToken；现在Bob想花750个ETH购买AToken，带入公式：Token_Return = 1000 *（（1 + 750 / 250）^ 0.5 - 1）= 1000\n\n>即Bob花了750个ETH购买了1000个AToken，本次购买的平均价格为0.75个ETH兑换1个AToken。  \nBob的购买行为推高了AToken的报价。若Bob接着购买同样数量的AToken，则需要付出更多的ETH代价，每一笔购买都会继续推高AToken的报价。\n\nToken卖出计算公式：\n\n\tETH_Return = Balance *（1 - （1 - Token_Amount / Supply）^ （1 / CW））\n\n>在Bob的那笔交易完成后，AToken的发行总量为2000个，储备金余额为1000个ETH，CW维持不变、仍然为0.5，那么通过公式可以计算当前的报价为1个ETH兑换1个AToken；现在Alice想卖掉1000个AToken，带入公式：ETH_Return = 1000 *（1 - （1 - 1000 / 2000）^ （1 /0.5））= 750\n\n>即Alice 卖掉了1000个AToken，获得了750个ETH，本次购买的平均价格为0.75个ETH兑换1个AToken。因为Bob的购买行为推高了AToken的报价，而Alice是在Bob的购买行为之后卖掉了AToken，所以Alice卖到了相对较高的价位。假如没有Bob的购买行为，回到AToken的供应量为1000的那个时候，Alice卖掉全部的AToken，也只能获得250个ETH  \n\n智能代币(Smart Tokens)\n>智能代币是Bancor协议的核心。它们的运作类似于常规代币，在ETH区块链上使用的符合ERC20标准[5]，但也要包含额外的逻辑，即允许用户通过它的智能合约直接购买和出售代币，价格通过程序自动调整以反映供求关系。实际上，智能代币拥有一种内置的流动性机制，确保它们可以持续地为兑换为其他代币。  \n  \n智能代币连接器(Smart Token connectors)  \n>智能代币连接器可以被视为分布式、自主、透明和可预测的做市商，而不是交易所。智能代币通过程序自动调整它们的价格，来管理它们的连接器准备金，以保持它们与智能代币的总市值之间的比率是恒定的。\n锚定代币(connected token)\n>每个智能代币都配置了连接器模块，这些模块持有它连接的另一个代币作为准备金（例如，BNT智能代币有一个连接到ETH的连接器，它持有ETH作为准备金）。ETH此时就是连接器代币。\n\n代币网络(token network)\n>智能代币可以实现自己和它们的连接代币之间进行即时兑换。这个功能足以使智能代币即时兑换为一定数量的以类似的方式连接到同一网络的任何其他代币。通过这种方式，智能代币可以连接到无限数量的代币，从而创建一个分布式的流动性网络，该网络可能由数百万个代币组成，这些代币都可以以不断计算的价格自动地相互兑换。\n\n中继代币(Relay Token)  \n>具有两个连接器的智能代币，其总CW恰好为100%，其功能类似于分布式代币兑换币对。中继代币允许用户在两个连接代币之间互相兑换，通过两步操作实现，即购买一种代币，立即出售另外一种代币。\n\n流动性代币(Liquid Tokens)\n>具有组合连接器总权重低于100%（更典型的低于20%）的智能代币成为流动性代币。可能有一个或者多个连接器。例如，BTN具有单个权重为10%的ETH连接器。流动性代币可以使用连接器代币买卖（使用Bancor公式计算它相对于连接代币的价格），并且可以自适应调节供应量，在购买时增加，出售时减少。  \n\n代理代币(Proxy Token)\n>具有一个连接器占100%权重的智能代币。\n\n组合代币(Array Token)\n>具有三个或者更多连接器权重为100%的智能代币。\n\n糖果代币(Bounty Tokens)\n\n>具有单个尚未激活连接器的智能代币（当前连接器准备金为0），可以向早起持有者（例如社区支持者）发放将来会发行的代币。\n\n网络代币(Network Tokens)\n\n>由多个(>2)智能代币持有作为连接代币的智能代币,BNT就是一个网络代币，也是一个流动性代币。\n\n交易者\n>持有、兑换和支付智能代币的终端用户\n\n智能代币发行者\n>发行智能代币，配置初始供应量、价格、连接器权重CW和管理智能代币初始发行的人员、公司、社区、组织或基金会。还包括将现有ERC20代币连接到Bancor网络的中继代币的创建者。\n\n资产代币化者\n>将代理代币或者组合代币映射到实体资产或者其他区块链上代币的创建者。这允许智能代币连接到更广泛的资产，如比特币、法定货币、黄金或其他新兴的区块链代币。\n\n套利者\n>监控Bancor流动性网络与外部交易所或者其他智能代币的价格，并且通过套利消除价差的交易者。套利者通过消除价差获得奖励，因此是Bancor生态系统的重要参与者。 \n\n***end***\n\n##### 我之理解 \n\n\tcw的理解可以参考很那张很经典的图\n\tcw<50%:price与supply的变化可理解为指数函数y = x^N 的形式变化\n\tcw=50%:price与supply的变化可理解为一次函数y = ax (a>0)的形式变化\n\tcw>50%:price与supply的变化可理解为对数函数y = y=logN(x)的形式变化\n\tcw=100%:price与supply的变化可理解为常数函数y = x的形式变化  \n\n1. 我发行一个smart token（暂且叫sk）,总量1000个 ，即supply= 1000 sk\n2. 预估一下我这个项目的价值，暂且估计价值1000个eth ，即TotalValue = 1000 eth\n3. 而我只有100个eth,那作为储备金，剩余的向大家融资吧,即balance = 100 eth\n4. 设定cw = 10%，\n5. 根据算法，得到price = 1 sk/eth，\n6. 到此，可理解为我用100eth以单价为10买了1000 sk,\n7. 使用100 eth买入，根据买入公式，得到(（1+（100/100））^0.1 - 1) * 1000= 0.0718 *  1000 = 71.8个sk，\n8. 当执行上笔交易后，cw是不会变得，其余的会动态调整。那么此时的sk supply = 1071.8 sk,balance = 200 eth，price = 1.866 sk / eth\n9. 这里可以看到买入100个后，一个sk价值1.866个eth,价格上涨了呢。这里有兴趣的同学可以试试连续分批次买10次，每次10个eth，可以看到价格的变化,最终的结果也是一样的，这就是bancor算法保证的结果\n9. 再继续使用100eth买入，根据买入公式，得到(（1+（100/200））^0.1 - 1) * 1071.8= 0.0414 *  1071.8 = 44.37个sk，这样后来买的价格就比之前的高了，获得的sk就会少，也就是价格高了\n10. supply = 1116.7 sk,balance = 300 eth，price = 26.86 sk/eth 单价已经翻了20倍了\n11. 卖出50 sk，根据卖出公式 300 *（1 - 50/1116.7）^(1/0.1) = 189.7488 eth   \n12. 额，初始值设定的不恰当，整个流程算出来的结果有点恐怖，有兴趣的同学可以按照流程调整一下初始值哈0.0\n13. 这里可能有同学会问了，我刚使用100eth获得44个sk,我马上又卖出50个sk可以得到189个eth，大赚了啊。理论上是成立的，但是你得保证你这两个操作中间没有其他人的卖出哈（买入你就赚得越多），其他人卖出之后，你再去卖价格就低了，所以得自己评估风险哦  \n\n**文章允许转载，但请注明出处，谢谢**\n\n小结：\n\n* 控制cw的变化，可以控制token的价格的走势\n* 买入,会提高smart token的价格，卖出会降低smart token的价格，具体变化由cw的决定\n* 缺点：这些数据都是采用智能合约编写的，无法改变。但是项目方可以更改cw的值，从而控制整个token的价格走势\n* 优点：你如果持有smart token是可以随时和储备金类型的token进行买卖的。这都是由智能合约自动执行，这点可以相对于传统的1co有着更好的安全，至少你持有的token有着更好的流通性，随时都可以流通，也可以换取其他的token或者储备金的token  \n\n##### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n##### 资料更新 2018-10-13 15:50:20\n更新一下，这里补上bancor的经典cw图，便于大家理解。  \n![cw](/bancor/bancor.png)  \n根据这张图中的曲线，那么你所持有的币的价值就是等于曲线上任意两点作x轴 所形成的面积。所以任何一点点的买入卖出都会影响整个智能代币的价格  \n另外附上bancor的白皮书  \n[bancor 白皮书 英文版](https://storage.googleapis.com/website-bancor/2018/04/01ba8253-bancor_protocol_whitepaper_en.pdf)\n\n","slug":"关于bancor的理解","published":1,"updated":"2019-02-18T13:13:08.308Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52v000knh7s91h5152t","content":"<h5 id=\"bancor的简单概述\"><a href=\"#bancor的简单概述\" class=\"headerlink\" title=\"bancor的简单概述\"></a>bancor的简单概述</h5><blockquote>\n<p>bancor是一种算法用于区块链的一种新的token的交易方式，目的是解决长尾的问题，增加ERC20的流通。长尾简单理解就是99%和1%的关系，即1%的token在大家的认知中有实际价值，而99%的token是没有的。那么通过bancor协议就是可以解决这99%的token，也可以给一个机会，让他们也有实际的价值。<br>具体可访问<a href=\"https://github.com/bancorprotocol/contracts\" target=\"_blank\" rel=\"noopener\">bancor github repo</a>，这里有详细的介绍和白皮书</p>\n</blockquote>\n<h5 id=\"bancor名词展示\"><a href=\"#bancor名词展示\" class=\"headerlink\" title=\"bancor名词展示\"></a>bancor名词展示</h5><p><em>以下资料来自网络</em>  <strong>start</strong></p>\n<p>Token的供应量【Smart Token’s Supply】，简称Supply；</p>\n<p>Token的价格【Smart Token’s Price 】，简称Price；</p>\n<p>Token的总市值【Smart Token’s Total Value】，简称TotalValue；</p>\n<p>储备金余额【Connector Balance】，简称Balance；</p>\n<p>储备金固定比率【Connector Weight】，简称CW。</p>\n<p>计算公式如下：</p>\n<pre><code>CW = Balance / TotalValue;\n\nTotalValue = Price * Supply;\n\nPrice = Balance /（Supply * CW）\n</code></pre><p>举例：若当前AToken的发行量为1000，报价为0.5个ETH兑换1个AToken，那么AToken的总价值为500个ETH，但是储备金余额可能并没有500个ETH，比如为250个ETH，那么CW则为0.5（50%)  </p>\n<p>Token买入计算公式：</p>\n<pre><code>Token_Return = Supply *（（1 + ETH_Amount / Balance）^ CW - 1）\n//此公式的证明可以通过查看白皮书\n</code></pre><blockquote>\n<p>例如 若当前AToken的发行量为1000，储备金余额为250个ETH，CW为0.5，那么当前的报价则为0.5个ETH兑换1个AToken；现在Bob想花750个ETH购买AToken，带入公式：Token_Return = 1000 *（（1 + 750 / 250）^ 0.5 - 1）= 1000</p>\n</blockquote>\n<blockquote>\n<p>即Bob花了750个ETH购买了1000个AToken，本次购买的平均价格为0.75个ETH兑换1个AToken。<br>Bob的购买行为推高了AToken的报价。若Bob接着购买同样数量的AToken，则需要付出更多的ETH代价，每一笔购买都会继续推高AToken的报价。</p>\n</blockquote>\n<p>Token卖出计算公式：</p>\n<pre><code>ETH_Return = Balance *（1 - （1 - Token_Amount / Supply）^ （1 / CW））\n</code></pre><blockquote>\n<p>在Bob的那笔交易完成后，AToken的发行总量为2000个，储备金余额为1000个ETH，CW维持不变、仍然为0.5，那么通过公式可以计算当前的报价为1个ETH兑换1个AToken；现在Alice想卖掉1000个AToken，带入公式：ETH_Return = 1000 *（1 - （1 - 1000 / 2000）^ （1 /0.5））= 750</p>\n</blockquote>\n<blockquote>\n<p>即Alice 卖掉了1000个AToken，获得了750个ETH，本次购买的平均价格为0.75个ETH兑换1个AToken。因为Bob的购买行为推高了AToken的报价，而Alice是在Bob的购买行为之后卖掉了AToken，所以Alice卖到了相对较高的价位。假如没有Bob的购买行为，回到AToken的供应量为1000的那个时候，Alice卖掉全部的AToken，也只能获得250个ETH  </p>\n</blockquote>\n<p>智能代币(Smart Tokens)</p>\n<blockquote>\n<p>智能代币是Bancor协议的核心。它们的运作类似于常规代币，在ETH区块链上使用的符合ERC20标准[5]，但也要包含额外的逻辑，即允许用户通过它的智能合约直接购买和出售代币，价格通过程序自动调整以反映供求关系。实际上，智能代币拥有一种内置的流动性机制，确保它们可以持续地为兑换为其他代币。  </p>\n</blockquote>\n<p>智能代币连接器(Smart Token connectors)  </p>\n<blockquote>\n<p>智能代币连接器可以被视为分布式、自主、透明和可预测的做市商，而不是交易所。智能代币通过程序自动调整它们的价格，来管理它们的连接器准备金，以保持它们与智能代币的总市值之间的比率是恒定的。<br>锚定代币(connected token)<br>每个智能代币都配置了连接器模块，这些模块持有它连接的另一个代币作为准备金（例如，BNT智能代币有一个连接到ETH的连接器，它持有ETH作为准备金）。ETH此时就是连接器代币。</p>\n</blockquote>\n<p>代币网络(token network)</p>\n<blockquote>\n<p>智能代币可以实现自己和它们的连接代币之间进行即时兑换。这个功能足以使智能代币即时兑换为一定数量的以类似的方式连接到同一网络的任何其他代币。通过这种方式，智能代币可以连接到无限数量的代币，从而创建一个分布式的流动性网络，该网络可能由数百万个代币组成，这些代币都可以以不断计算的价格自动地相互兑换。</p>\n</blockquote>\n<p>中继代币(Relay Token)  </p>\n<blockquote>\n<p>具有两个连接器的智能代币，其总CW恰好为100%，其功能类似于分布式代币兑换币对。中继代币允许用户在两个连接代币之间互相兑换，通过两步操作实现，即购买一种代币，立即出售另外一种代币。</p>\n</blockquote>\n<p>流动性代币(Liquid Tokens)</p>\n<blockquote>\n<p>具有组合连接器总权重低于100%（更典型的低于20%）的智能代币成为流动性代币。可能有一个或者多个连接器。例如，BTN具有单个权重为10%的ETH连接器。流动性代币可以使用连接器代币买卖（使用Bancor公式计算它相对于连接代币的价格），并且可以自适应调节供应量，在购买时增加，出售时减少。  </p>\n</blockquote>\n<p>代理代币(Proxy Token)</p>\n<blockquote>\n<p>具有一个连接器占100%权重的智能代币。</p>\n</blockquote>\n<p>组合代币(Array Token)</p>\n<blockquote>\n<p>具有三个或者更多连接器权重为100%的智能代币。</p>\n</blockquote>\n<p>糖果代币(Bounty Tokens)</p>\n<blockquote>\n<p>具有单个尚未激活连接器的智能代币（当前连接器准备金为0），可以向早起持有者（例如社区支持者）发放将来会发行的代币。</p>\n</blockquote>\n<p>网络代币(Network Tokens)</p>\n<blockquote>\n<p>由多个(&gt;2)智能代币持有作为连接代币的智能代币,BNT就是一个网络代币，也是一个流动性代币。</p>\n</blockquote>\n<p>交易者</p>\n<blockquote>\n<p>持有、兑换和支付智能代币的终端用户</p>\n</blockquote>\n<p>智能代币发行者</p>\n<blockquote>\n<p>发行智能代币，配置初始供应量、价格、连接器权重CW和管理智能代币初始发行的人员、公司、社区、组织或基金会。还包括将现有ERC20代币连接到Bancor网络的中继代币的创建者。</p>\n</blockquote>\n<p>资产代币化者</p>\n<blockquote>\n<p>将代理代币或者组合代币映射到实体资产或者其他区块链上代币的创建者。这允许智能代币连接到更广泛的资产，如比特币、法定货币、黄金或其他新兴的区块链代币。</p>\n</blockquote>\n<p>套利者</p>\n<blockquote>\n<p>监控Bancor流动性网络与外部交易所或者其他智能代币的价格，并且通过套利消除价差的交易者。套利者通过消除价差获得奖励，因此是Bancor生态系统的重要参与者。 </p>\n</blockquote>\n<p><strong><em>end</em></strong></p>\n<h5 id=\"我之理解\"><a href=\"#我之理解\" class=\"headerlink\" title=\"我之理解\"></a>我之理解</h5><pre><code>cw的理解可以参考很那张很经典的图\ncw&lt;50%:price与supply的变化可理解为指数函数y = x^N 的形式变化\ncw=50%:price与supply的变化可理解为一次函数y = ax (a&gt;0)的形式变化\ncw&gt;50%:price与supply的变化可理解为对数函数y = y=logN(x)的形式变化\ncw=100%:price与supply的变化可理解为常数函数y = x的形式变化  \n</code></pre><ol>\n<li>我发行一个smart token（暂且叫sk）,总量1000个 ，即supply= 1000 sk</li>\n<li>预估一下我这个项目的价值，暂且估计价值1000个eth ，即TotalValue = 1000 eth</li>\n<li>而我只有100个eth,那作为储备金，剩余的向大家融资吧,即balance = 100 eth</li>\n<li>设定cw = 10%，</li>\n<li>根据算法，得到price = 1 sk/eth，</li>\n<li>到此，可理解为我用100eth以单价为10买了1000 sk,</li>\n<li>使用100 eth买入，根据买入公式，得到(（1+（100/100））^0.1 - 1) <em> 1000= 0.0718 </em>  1000 = 71.8个sk，</li>\n<li>当执行上笔交易后，cw是不会变得，其余的会动态调整。那么此时的sk supply = 1071.8 sk,balance = 200 eth，price = 1.866 sk / eth</li>\n<li>这里可以看到买入100个后，一个sk价值1.866个eth,价格上涨了呢。这里有兴趣的同学可以试试连续分批次买10次，每次10个eth，可以看到价格的变化,最终的结果也是一样的，这就是bancor算法保证的结果</li>\n<li>再继续使用100eth买入，根据买入公式，得到(（1+（100/200））^0.1 - 1) <em> 1071.8= 0.0414 </em>  1071.8 = 44.37个sk，这样后来买的价格就比之前的高了，获得的sk就会少，也就是价格高了</li>\n<li>supply = 1116.7 sk,balance = 300 eth，price = 26.86 sk/eth 单价已经翻了20倍了</li>\n<li>卖出50 sk，根据卖出公式 300 *（1 - 50/1116.7）^(1/0.1) = 189.7488 eth   </li>\n<li>额，初始值设定的不恰当，整个流程算出来的结果有点恐怖，有兴趣的同学可以按照流程调整一下初始值哈0.0</li>\n<li>这里可能有同学会问了，我刚使用100eth获得44个sk,我马上又卖出50个sk可以得到189个eth，大赚了啊。理论上是成立的，但是你得保证你这两个操作中间没有其他人的卖出哈（买入你就赚得越多），其他人卖出之后，你再去卖价格就低了，所以得自己评估风险哦  </li>\n</ol>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p>小结：</p>\n<ul>\n<li>控制cw的变化，可以控制token的价格的走势</li>\n<li>买入,会提高smart token的价格，卖出会降低smart token的价格，具体变化由cw的决定</li>\n<li>缺点：这些数据都是采用智能合约编写的，无法改变。但是项目方可以更改cw的值，从而控制整个token的价格走势</li>\n<li>优点：你如果持有smart token是可以随时和储备金类型的token进行买卖的。这都是由智能合约自动执行，这点可以相对于传统的1co有着更好的安全，至少你持有的token有着更好的流通性，随时都可以流通，也可以换取其他的token或者储备金的token  </li>\n</ul>\n<h5 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h5><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<h5 id=\"资料更新-2018-10-13-15-50-20\"><a href=\"#资料更新-2018-10-13-15-50-20\" class=\"headerlink\" title=\"资料更新 2018-10-13 15:50:20\"></a>资料更新 2018-10-13 15:50:20</h5><p>更新一下，这里补上bancor的经典cw图，便于大家理解。<br><img src=\"/bancor/bancor.png\" alt=\"cw\"><br>根据这张图中的曲线，那么你所持有的币的价值就是等于曲线上任意两点作x轴 所形成的面积。所以任何一点点的买入卖出都会影响整个智能代币的价格<br>另外附上bancor的白皮书<br><a href=\"https://storage.googleapis.com/website-bancor/2018/04/01ba8253-bancor_protocol_whitepaper_en.pdf\" target=\"_blank\" rel=\"noopener\">bancor 白皮书 英文版</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"bancor的简单概述\"><a href=\"#bancor的简单概述\" class=\"headerlink\" title=\"bancor的简单概述\"></a>bancor的简单概述</h5><blockquote>\n<p>bancor是一种算法用于区块链的一种新的token的交易方式，目的是解决长尾的问题，增加ERC20的流通。长尾简单理解就是99%和1%的关系，即1%的token在大家的认知中有实际价值，而99%的token是没有的。那么通过bancor协议就是可以解决这99%的token，也可以给一个机会，让他们也有实际的价值。<br>具体可访问<a href=\"https://github.com/bancorprotocol/contracts\" target=\"_blank\" rel=\"noopener\">bancor github repo</a>，这里有详细的介绍和白皮书</p>\n</blockquote>\n<h5 id=\"bancor名词展示\"><a href=\"#bancor名词展示\" class=\"headerlink\" title=\"bancor名词展示\"></a>bancor名词展示</h5><p><em>以下资料来自网络</em>  <strong>start</strong></p>\n<p>Token的供应量【Smart Token’s Supply】，简称Supply；</p>\n<p>Token的价格【Smart Token’s Price 】，简称Price；</p>\n<p>Token的总市值【Smart Token’s Total Value】，简称TotalValue；</p>\n<p>储备金余额【Connector Balance】，简称Balance；</p>\n<p>储备金固定比率【Connector Weight】，简称CW。</p>\n<p>计算公式如下：</p>\n<pre><code>CW = Balance / TotalValue;\n\nTotalValue = Price * Supply;\n\nPrice = Balance /（Supply * CW）\n</code></pre><p>举例：若当前AToken的发行量为1000，报价为0.5个ETH兑换1个AToken，那么AToken的总价值为500个ETH，但是储备金余额可能并没有500个ETH，比如为250个ETH，那么CW则为0.5（50%)  </p>\n<p>Token买入计算公式：</p>\n<pre><code>Token_Return = Supply *（（1 + ETH_Amount / Balance）^ CW - 1）\n//此公式的证明可以通过查看白皮书\n</code></pre><blockquote>\n<p>例如 若当前AToken的发行量为1000，储备金余额为250个ETH，CW为0.5，那么当前的报价则为0.5个ETH兑换1个AToken；现在Bob想花750个ETH购买AToken，带入公式：Token_Return = 1000 *（（1 + 750 / 250）^ 0.5 - 1）= 1000</p>\n</blockquote>\n<blockquote>\n<p>即Bob花了750个ETH购买了1000个AToken，本次购买的平均价格为0.75个ETH兑换1个AToken。<br>Bob的购买行为推高了AToken的报价。若Bob接着购买同样数量的AToken，则需要付出更多的ETH代价，每一笔购买都会继续推高AToken的报价。</p>\n</blockquote>\n<p>Token卖出计算公式：</p>\n<pre><code>ETH_Return = Balance *（1 - （1 - Token_Amount / Supply）^ （1 / CW））\n</code></pre><blockquote>\n<p>在Bob的那笔交易完成后，AToken的发行总量为2000个，储备金余额为1000个ETH，CW维持不变、仍然为0.5，那么通过公式可以计算当前的报价为1个ETH兑换1个AToken；现在Alice想卖掉1000个AToken，带入公式：ETH_Return = 1000 *（1 - （1 - 1000 / 2000）^ （1 /0.5））= 750</p>\n</blockquote>\n<blockquote>\n<p>即Alice 卖掉了1000个AToken，获得了750个ETH，本次购买的平均价格为0.75个ETH兑换1个AToken。因为Bob的购买行为推高了AToken的报价，而Alice是在Bob的购买行为之后卖掉了AToken，所以Alice卖到了相对较高的价位。假如没有Bob的购买行为，回到AToken的供应量为1000的那个时候，Alice卖掉全部的AToken，也只能获得250个ETH  </p>\n</blockquote>\n<p>智能代币(Smart Tokens)</p>\n<blockquote>\n<p>智能代币是Bancor协议的核心。它们的运作类似于常规代币，在ETH区块链上使用的符合ERC20标准[5]，但也要包含额外的逻辑，即允许用户通过它的智能合约直接购买和出售代币，价格通过程序自动调整以反映供求关系。实际上，智能代币拥有一种内置的流动性机制，确保它们可以持续地为兑换为其他代币。  </p>\n</blockquote>\n<p>智能代币连接器(Smart Token connectors)  </p>\n<blockquote>\n<p>智能代币连接器可以被视为分布式、自主、透明和可预测的做市商，而不是交易所。智能代币通过程序自动调整它们的价格，来管理它们的连接器准备金，以保持它们与智能代币的总市值之间的比率是恒定的。<br>锚定代币(connected token)<br>每个智能代币都配置了连接器模块，这些模块持有它连接的另一个代币作为准备金（例如，BNT智能代币有一个连接到ETH的连接器，它持有ETH作为准备金）。ETH此时就是连接器代币。</p>\n</blockquote>\n<p>代币网络(token network)</p>\n<blockquote>\n<p>智能代币可以实现自己和它们的连接代币之间进行即时兑换。这个功能足以使智能代币即时兑换为一定数量的以类似的方式连接到同一网络的任何其他代币。通过这种方式，智能代币可以连接到无限数量的代币，从而创建一个分布式的流动性网络，该网络可能由数百万个代币组成，这些代币都可以以不断计算的价格自动地相互兑换。</p>\n</blockquote>\n<p>中继代币(Relay Token)  </p>\n<blockquote>\n<p>具有两个连接器的智能代币，其总CW恰好为100%，其功能类似于分布式代币兑换币对。中继代币允许用户在两个连接代币之间互相兑换，通过两步操作实现，即购买一种代币，立即出售另外一种代币。</p>\n</blockquote>\n<p>流动性代币(Liquid Tokens)</p>\n<blockquote>\n<p>具有组合连接器总权重低于100%（更典型的低于20%）的智能代币成为流动性代币。可能有一个或者多个连接器。例如，BTN具有单个权重为10%的ETH连接器。流动性代币可以使用连接器代币买卖（使用Bancor公式计算它相对于连接代币的价格），并且可以自适应调节供应量，在购买时增加，出售时减少。  </p>\n</blockquote>\n<p>代理代币(Proxy Token)</p>\n<blockquote>\n<p>具有一个连接器占100%权重的智能代币。</p>\n</blockquote>\n<p>组合代币(Array Token)</p>\n<blockquote>\n<p>具有三个或者更多连接器权重为100%的智能代币。</p>\n</blockquote>\n<p>糖果代币(Bounty Tokens)</p>\n<blockquote>\n<p>具有单个尚未激活连接器的智能代币（当前连接器准备金为0），可以向早起持有者（例如社区支持者）发放将来会发行的代币。</p>\n</blockquote>\n<p>网络代币(Network Tokens)</p>\n<blockquote>\n<p>由多个(&gt;2)智能代币持有作为连接代币的智能代币,BNT就是一个网络代币，也是一个流动性代币。</p>\n</blockquote>\n<p>交易者</p>\n<blockquote>\n<p>持有、兑换和支付智能代币的终端用户</p>\n</blockquote>\n<p>智能代币发行者</p>\n<blockquote>\n<p>发行智能代币，配置初始供应量、价格、连接器权重CW和管理智能代币初始发行的人员、公司、社区、组织或基金会。还包括将现有ERC20代币连接到Bancor网络的中继代币的创建者。</p>\n</blockquote>\n<p>资产代币化者</p>\n<blockquote>\n<p>将代理代币或者组合代币映射到实体资产或者其他区块链上代币的创建者。这允许智能代币连接到更广泛的资产，如比特币、法定货币、黄金或其他新兴的区块链代币。</p>\n</blockquote>\n<p>套利者</p>\n<blockquote>\n<p>监控Bancor流动性网络与外部交易所或者其他智能代币的价格，并且通过套利消除价差的交易者。套利者通过消除价差获得奖励，因此是Bancor生态系统的重要参与者。 </p>\n</blockquote>\n<p><strong><em>end</em></strong></p>\n<h5 id=\"我之理解\"><a href=\"#我之理解\" class=\"headerlink\" title=\"我之理解\"></a>我之理解</h5><pre><code>cw的理解可以参考很那张很经典的图\ncw&lt;50%:price与supply的变化可理解为指数函数y = x^N 的形式变化\ncw=50%:price与supply的变化可理解为一次函数y = ax (a&gt;0)的形式变化\ncw&gt;50%:price与supply的变化可理解为对数函数y = y=logN(x)的形式变化\ncw=100%:price与supply的变化可理解为常数函数y = x的形式变化  \n</code></pre><ol>\n<li>我发行一个smart token（暂且叫sk）,总量1000个 ，即supply= 1000 sk</li>\n<li>预估一下我这个项目的价值，暂且估计价值1000个eth ，即TotalValue = 1000 eth</li>\n<li>而我只有100个eth,那作为储备金，剩余的向大家融资吧,即balance = 100 eth</li>\n<li>设定cw = 10%，</li>\n<li>根据算法，得到price = 1 sk/eth，</li>\n<li>到此，可理解为我用100eth以单价为10买了1000 sk,</li>\n<li>使用100 eth买入，根据买入公式，得到(（1+（100/100））^0.1 - 1) <em> 1000= 0.0718 </em>  1000 = 71.8个sk，</li>\n<li>当执行上笔交易后，cw是不会变得，其余的会动态调整。那么此时的sk supply = 1071.8 sk,balance = 200 eth，price = 1.866 sk / eth</li>\n<li>这里可以看到买入100个后，一个sk价值1.866个eth,价格上涨了呢。这里有兴趣的同学可以试试连续分批次买10次，每次10个eth，可以看到价格的变化,最终的结果也是一样的，这就是bancor算法保证的结果</li>\n<li>再继续使用100eth买入，根据买入公式，得到(（1+（100/200））^0.1 - 1) <em> 1071.8= 0.0414 </em>  1071.8 = 44.37个sk，这样后来买的价格就比之前的高了，获得的sk就会少，也就是价格高了</li>\n<li>supply = 1116.7 sk,balance = 300 eth，price = 26.86 sk/eth 单价已经翻了20倍了</li>\n<li>卖出50 sk，根据卖出公式 300 *（1 - 50/1116.7）^(1/0.1) = 189.7488 eth   </li>\n<li>额，初始值设定的不恰当，整个流程算出来的结果有点恐怖，有兴趣的同学可以按照流程调整一下初始值哈0.0</li>\n<li>这里可能有同学会问了，我刚使用100eth获得44个sk,我马上又卖出50个sk可以得到189个eth，大赚了啊。理论上是成立的，但是你得保证你这两个操作中间没有其他人的卖出哈（买入你就赚得越多），其他人卖出之后，你再去卖价格就低了，所以得自己评估风险哦  </li>\n</ol>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<p>小结：</p>\n<ul>\n<li>控制cw的变化，可以控制token的价格的走势</li>\n<li>买入,会提高smart token的价格，卖出会降低smart token的价格，具体变化由cw的决定</li>\n<li>缺点：这些数据都是采用智能合约编写的，无法改变。但是项目方可以更改cw的值，从而控制整个token的价格走势</li>\n<li>优点：你如果持有smart token是可以随时和储备金类型的token进行买卖的。这都是由智能合约自动执行，这点可以相对于传统的1co有着更好的安全，至少你持有的token有着更好的流通性，随时都可以流通，也可以换取其他的token或者储备金的token  </li>\n</ul>\n<h5 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h5><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<h5 id=\"资料更新-2018-10-13-15-50-20\"><a href=\"#资料更新-2018-10-13-15-50-20\" class=\"headerlink\" title=\"资料更新 2018-10-13 15:50:20\"></a>资料更新 2018-10-13 15:50:20</h5><p>更新一下，这里补上bancor的经典cw图，便于大家理解。<br><img src=\"/bancor/bancor.png\" alt=\"cw\"><br>根据这张图中的曲线，那么你所持有的币的价值就是等于曲线上任意两点作x轴 所形成的面积。所以任何一点点的买入卖出都会影响整个智能代币的价格<br>另外附上bancor的白皮书<br><a href=\"https://storage.googleapis.com/website-bancor/2018/04/01ba8253-bancor_protocol_whitepaper_en.pdf\" target=\"_blank\" rel=\"noopener\">bancor 白皮书 英文版</a></p>\n"},{"title":"结合scatter学习eos dapp开发，看这篇就够了（下）","date":"2018-10-14T01:24:19.000Z","_content":" \n#### eos智能合约开发 c++合约编写\n> 这里需要说明的一下，这个例子和官网提供的hello没有多大的区别,仅仅是带你多了解一下如何编写。其中遇到有些概念难以理解，建议还是参考官网的hello 从头看起\n\n\n\t#include <eosiolib/eosio.hpp>  \n\t#include <eosiolib/print.hpp>\n\t#include<string>\n\n\tusing namespace eosio;\n\tusing std::string;\n\n\tclass todolist : public contract {  //继承 contract\n\n  \tpublic:\n      using contract::contract;           \n\t\t\n      todolist(account_name self):contract(self){}   //构造函数\n\t\t// account_name 是eoslib中定义的一种类型\n\t\t\n      [[eosio::action]]   // 以前的版本使用的 ///abi action ，eoscdt使用这种方式标识，更加的优雅，也就是你要对外开放的方法都加上才会生成在abi中\n      void create(account_name author, const uint32_t id, const std::string &description)\n      {\n      // 记住，这些action方法的返回值只能是void，不然会报错，只有实际做过的人才会知道 ，那你要问我如何读取区块链的内容呢？ 这个问题也困扰了我蛮久，继续看下面\n        todo_index todos(_self, _self);\n        // 实例化多索引列表，第一个参数是这张表是谁的 code ,即谁有权限去读写它\n        // 第二个参数scope，相当于缩小范围去找到这张表\n        // _self 是构造函数中的self\n        // todo_index 是Multi_index的一个具体的类型，在下面定义的\n        \n        todos.emplace(author, [&](auto &new_todo) {\n            new_todo.id = id;\n            new_todo.description = description;\n            new_todo.completed = 0;\n        });\n        // 使用todos这个表的实例，去添加一条todo\n        // 第一个参数表示为这条内容的写入付费的account，第二个参数是一个lambda方法，拿到的参数是这个表中的一行的实例，然后赋值对应的数据即可\n        \n        print(\"todo#\", id, \" created\");\n        // 这里，如果你使用命令行方式 执行，执行成功后会打印这个方法，但是如果是dapp开发，这是看不到的，又有一个疑问，那我们怎么知道执行成功了呢？\n      }\n\n      [[eosio::action]]\n      void complete(account_name author,const uint32_t id)\n      {  \n      // 更改todo的状态为完成\n\t  todo_index todos(_self, _self);\n\t  \n    \t  auto todo_look = todos.find(id);\n    \t  // 是否用find()方法，去查找这条方法对应的实例\n    \t  eosio_assert(todo_look != todos.end(), \"todo does not exit\");\n\t\t// 这里 如果找不到，todos.end() 会返回 null\n    \t  todos.modify(todo_look,author,[&](auto &t) {\n    \t\t  t.completed = 1;\n    \t  });\n\n    \t  print(\"todo #\" ,id ,\"marked as complted\");\n      }\n\n      [[eosio::action]]\n      void destroy(account_name author, const uint32_t id)\n      {\t\n      \t  require_auth(author);\n      \t  // 权限验证，只能够删除自己的todo\n      \t  \n\t  \t  todo_index todos(_self, author);\n    \t  auto todo_look = todos.find(id);\n    \t  todos.erase(todo_look);\n    \t  print(\"todo#\", id, \" destroyed\");\n      }\n  \tprivate:\n\t\t// 在eoscdt中 注意加上[[eosio::table]] ，否则abi中不会生成这个table\n      struct [[eosio::table]] todo {\n    \t  uint64_t id;\n    \t  string description;\n    \t  uint64_t completed;\n\t\t \n    \t  uint64_t primary_key() const {\n    \t  // 这个方法是必须存在的，上面方法能够查找就是因为这个方法的存在，  \n    \t  // 所以说查找只用传入 id即可，  \n    \t  // 如果要使用其他的查找方式，得多定义几个查找的方法，最多可以定义16个  \n    \t  // 如何定义看官网，这里不演示了  \n    \t\t  return id;\n    \t  }\n\t\t\t\n    \t  EOSLIB_SERIALIZE(todo,(id)(description)(completed));\n      };\n\n      typedef eosio::multi_index<N(todo),todo> todo_index;\n      // 这里定义了多索引列表的具体实现，N(todo)是将你的account 转换为 uint64_t 类型，第二个参数传入表名字， 定义的具体的类型是todo_index\n\n\t};\n\n\tEOSIO_ABI(todolist, (create)(complete)(destroy))\n\n#### eos智能合约开发  编译智能合约\n>经过以上的步骤，我们编写好了智能合约，这个合约是一个todolist，可以增加todo,可以将todo变为完成的状态，还可以删除todo,只能删除自己的todo\n\n这里编译智能合约，需要下载好eoscdt,如果没有下载好，建议完整安装好eoscdt再继续往下走了  \n\n1. ![contract](/images/contract1.png)    \n新建一个todolist文件夹，将上面写好的todolist.cpp放进去    \n2.  ![contract](/images/contract2.png)  \n打开终端，进入文件夹，输入   \n\n\t\teosio-cpp -o todolist.wasm todolist.cpp --abigen\n\n\n3.  ![contract](/images/contract3.png)  \n\t成功后会在当前文件夹目录下生成 todolist.wasm 和 todolist.abi\n\t\n#### eos智能合约开发 部署智能合约\n> 这里部署智能合约我暂时只找到使用 命令行的方式部署，如果哪位同学知道其他的方式部署，请告诉我，谢谢\n\n>合约的部署又得创建钱包导入账户，和我们在scatter的方式一样，只不过这次是在命令行上操作了，那接下来继续走\n\n\n* ![contract](/images/contract4.png)   \n\t\n\t\t//显示当前的钱包，如果是按照教程来，应该如图显示\n\t\tcleos wallet list \n  \n* ![contract](/images/contract5.png)  \n\n\t\t// 创建钱包，记住将返回的钱包密匙保存起来\n\t\tcleos wallet create —-to-console \n\t\t// 显示钱包\n\t\tcleos wallet list \n\n* ![contract](/images/contract6.png)  \n\n\t\t// 导入我们之前的导入scatter的密匙对的私钥\n\t\t// 执行后粘贴 私钥就好\n\t\tcleos wallet import\n\n* ![contract](/images/contract6.png)  \n\n\t\t// 导入我们之前的导入scatter的密匙对的私钥\n\t\t// 执行后粘贴 私钥就好\n\t\tcleos wallet import\n\t\t\n* ![contract](/images/contract7.png)  \n\n\t\t// 部署合约 eee,注意看提示内容，RAM不够了，怎么办？去买\n\t\t// 参数解释\n\t\t// -u 指定部署合约的网络\n\t\t// set contract  部署合约的命令\n\t\t// shaokun11113  部署到哪个账户上，注意 这里这个账户的私钥必须被导入钱包且已在 -u指定网络上进行注册\n\t\t// /Users/shaokun/Documents/todolist  abi 和 wasm的 绝对路径 ，建议不要使用相对路径\n\t\t//-p 指定权限\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n\n* ![contract](/images/contract8.png)  \n\n\t\t// 购买RAM\n\t\t// -u 去哪里买\n\t\t// system buyram  购买ram的命令\n\t\t// shaokun11113  谁去买，谁付钱\n\t\t// shaokun11113  谁受益 买来的ram 给谁\n\t\t// -k 买多少 kbytes \n\t\tcleos -u http://jungle.cryptolions.io:18888 system buyram shaokun11113 shaokun11113 -k 1024\n\t\t\n* ![contract](/images/contract9.png)  \n\t有时候你也许会遇到这种情况 ，那就需要之前创建钱包时的密匙进行解锁钱包\n\t\t\n* ![contract](/images/contract10.png)  \n\n\t\t// 解锁默认钱包，输入钱包秘钥就好， 可以使用-n 指定解锁的钱包名字\n\t\tcleos unlock wallet\n\t\t\n* ![contract](/images/contract11.png)  \n\n\t\t// 再次部署合约，可以看到结果eosio::setcode eosio::sebabi说明部署成功\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n\t\t\n#### eos智能合约开发 使用scatter.js进行交互\n>这里使用 create-react-app 脚手架创建项目，删除无用的文件，启动项目。这里有疑问的请百度\n\n* ![contract](/images/contract12.png) ![contract](/images/contract13.png) \n\n创建react项目,打开项目，删除无用的文件\n\n* ![contract](/images/contract14.png) \n\n启动项目，保证项目的正确性\n\n* ![contract](/images/contract15.png) \n\t\t\n\t\t// 安装scatter sdk\n\t\t// 这里使用的是eosjs1,尝试了多种方式，未找到eosjs2的使用方式，如有知道的同学，还请告知\n\t\tnpm i -S scatterjs-core  scatterjs-plugin-eosjs\n\n*  ![contract](/images/contract16.png)\n\n改造项目的布局\n\n\trender() {\n        return (\n            <div>\n\n                <div>\n                    <button onClick={() => this.createTodo()}>create todo</button>\n                    <button onClick={() => this.deleteTodo()}>delete todo</button>\n                    <input type=\"text\" onChange={e => {\n                        this.setState({\n                            deleteId: Number.parseInt(e.target.value)\n                        })\n                    }}/>\n\n                    <button onClick={() => this.completeTodo()}>complete todo</button>\n                    <input type=\"text\" onChange={e => {\n                        this.setState({\n                            competedId: Number.parseInt(e.target.value)\n                        })\n                    }}/>\n                    <button onClick={() => this.showTodo()}>show todo</button>\n                </div>\n                <div>\n                    <p>below is data</p>\n                    <ul>\n                        {\n                            this.state.rows.map((todo, index) => {\n                                return <li key={index}>\n                                    <p>id : {todo.id}</p>\n                                    <p>description : {todo.description}</p>\n                                    <p>completed : {todo.completed}</p>\n                                </li>\n                            })\n                        }\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n* 引入scatter sdk \n\n\t\timport React, {Component} from 'react';\n\t\timport ScatterJS from 'scatterjs-core';\n\t\timport ScatterEOS from 'scatterjs-plugin-eosjs';\n\t\timport Eos from 'eosjs';\n\t\n\t\tScatterJS.plugins(new ScatterEOS());\n\t\n\t\tconst network = {\n\t    blockchain: 'eos',\n\t    protocol: 'http',\n\t    host: 'jungle.cryptolions.io',\n\t    port: 18888,\n\t    chainId: \t\t'038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca'\n\t\t}\n\t\t\n\n* 初始化\n\n\t\n\t\tcomponentDidMount() {\n        \tsetTimeout(() => {\n            \tthis.init()\n        \t}, 2000)\n    \t}\n\n    \tinit() {\n        ScatterJS.scatter.connect('eos').then(connected => {\n            if (!connected) return false;\n            const scatter = ScatterJS.scatter;\n\n            this.setState({\n                scatter\n            });\n            alert(\"scatter load success\")\n        });\n    \t}\t\n    \t\n* ![contract](/images/contract17.png)\t\n\t\n\t增加 曾 删 改 查的功能\n\t\n\t\tcreateTodo() {\n        this.state.scatter.getIdentity(requiredFields).then(() => {\n            const account = this.state.scatter.identity.accounts.find(x => x.blockchain === 'eos');\n            const eos = this.state.scatter.eos(network, Eos);\n            const transactionPermission = {authorization: [`${account.name}@${account.authority}`]};\n            const num = Math.floor(Math.random() * 100000);\n            eos.contract(account.name).then(ins => {\n                ins.create(account.name, num, \"this is \" + num, transactionPermission).then(res => {\n                    console.log(res)\n                })\n            })\n\n        }).catch(error => {\n            console.error(error);\n        });\n    \t}\n\t\n* ![contract](/images/eos11.gif)\t\n\n启动项目，看看演示效果。可以看见与eos网络的交互还是很流畅，速度也很快。到此，基于eos网络开发dapp的流程应该算结束了，谢谢你的阅读。\n\n#### eos智能合约开发 总结\n> 本打算下周更新此篇文章，恰好今天原来的计划取消了，那就不拖了，下周有下周的事情呢  \n> 这里有几点需要大家注意：\n\n*  一定要有梯子，不然根本无从谈起\n*  eos要求硬件比较高，这个需要自己准备了\n*  一定要先理解eos中的相关概念，和以太坊还是有很大的区别的\n*  一定要先跟着官网的hello走一遍\n*  如果哪一步遇到问题了，可以反复翻看这两篇文章，你一定能够成功的\n\n#### eos智能合约开发 源码\n2018-11-15 22:18:58更新\n[源码送上...]\n(https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD)\n#### 接下来的计划\n* 继续分享智能合约的知识，主要是基于eos,tron,eth三个平台，希望能够帮助到大家\n* 分享一些编程语言知识，eth 和 tron 是用solidity写合约，eos是用c++写，前端展示页面是用react写的 \n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","source":"_posts/基于eos连接scatter开发dapp(下).md","raw":"---\ntitle: 结合scatter学习eos dapp开发，看这篇就够了（下）\ndate: 2018-10-14 09:24:19\n---\n \n#### eos智能合约开发 c++合约编写\n> 这里需要说明的一下，这个例子和官网提供的hello没有多大的区别,仅仅是带你多了解一下如何编写。其中遇到有些概念难以理解，建议还是参考官网的hello 从头看起\n\n\n\t#include <eosiolib/eosio.hpp>  \n\t#include <eosiolib/print.hpp>\n\t#include<string>\n\n\tusing namespace eosio;\n\tusing std::string;\n\n\tclass todolist : public contract {  //继承 contract\n\n  \tpublic:\n      using contract::contract;           \n\t\t\n      todolist(account_name self):contract(self){}   //构造函数\n\t\t// account_name 是eoslib中定义的一种类型\n\t\t\n      [[eosio::action]]   // 以前的版本使用的 ///abi action ，eoscdt使用这种方式标识，更加的优雅，也就是你要对外开放的方法都加上才会生成在abi中\n      void create(account_name author, const uint32_t id, const std::string &description)\n      {\n      // 记住，这些action方法的返回值只能是void，不然会报错，只有实际做过的人才会知道 ，那你要问我如何读取区块链的内容呢？ 这个问题也困扰了我蛮久，继续看下面\n        todo_index todos(_self, _self);\n        // 实例化多索引列表，第一个参数是这张表是谁的 code ,即谁有权限去读写它\n        // 第二个参数scope，相当于缩小范围去找到这张表\n        // _self 是构造函数中的self\n        // todo_index 是Multi_index的一个具体的类型，在下面定义的\n        \n        todos.emplace(author, [&](auto &new_todo) {\n            new_todo.id = id;\n            new_todo.description = description;\n            new_todo.completed = 0;\n        });\n        // 使用todos这个表的实例，去添加一条todo\n        // 第一个参数表示为这条内容的写入付费的account，第二个参数是一个lambda方法，拿到的参数是这个表中的一行的实例，然后赋值对应的数据即可\n        \n        print(\"todo#\", id, \" created\");\n        // 这里，如果你使用命令行方式 执行，执行成功后会打印这个方法，但是如果是dapp开发，这是看不到的，又有一个疑问，那我们怎么知道执行成功了呢？\n      }\n\n      [[eosio::action]]\n      void complete(account_name author,const uint32_t id)\n      {  \n      // 更改todo的状态为完成\n\t  todo_index todos(_self, _self);\n\t  \n    \t  auto todo_look = todos.find(id);\n    \t  // 是否用find()方法，去查找这条方法对应的实例\n    \t  eosio_assert(todo_look != todos.end(), \"todo does not exit\");\n\t\t// 这里 如果找不到，todos.end() 会返回 null\n    \t  todos.modify(todo_look,author,[&](auto &t) {\n    \t\t  t.completed = 1;\n    \t  });\n\n    \t  print(\"todo #\" ,id ,\"marked as complted\");\n      }\n\n      [[eosio::action]]\n      void destroy(account_name author, const uint32_t id)\n      {\t\n      \t  require_auth(author);\n      \t  // 权限验证，只能够删除自己的todo\n      \t  \n\t  \t  todo_index todos(_self, author);\n    \t  auto todo_look = todos.find(id);\n    \t  todos.erase(todo_look);\n    \t  print(\"todo#\", id, \" destroyed\");\n      }\n  \tprivate:\n\t\t// 在eoscdt中 注意加上[[eosio::table]] ，否则abi中不会生成这个table\n      struct [[eosio::table]] todo {\n    \t  uint64_t id;\n    \t  string description;\n    \t  uint64_t completed;\n\t\t \n    \t  uint64_t primary_key() const {\n    \t  // 这个方法是必须存在的，上面方法能够查找就是因为这个方法的存在，  \n    \t  // 所以说查找只用传入 id即可，  \n    \t  // 如果要使用其他的查找方式，得多定义几个查找的方法，最多可以定义16个  \n    \t  // 如何定义看官网，这里不演示了  \n    \t\t  return id;\n    \t  }\n\t\t\t\n    \t  EOSLIB_SERIALIZE(todo,(id)(description)(completed));\n      };\n\n      typedef eosio::multi_index<N(todo),todo> todo_index;\n      // 这里定义了多索引列表的具体实现，N(todo)是将你的account 转换为 uint64_t 类型，第二个参数传入表名字， 定义的具体的类型是todo_index\n\n\t};\n\n\tEOSIO_ABI(todolist, (create)(complete)(destroy))\n\n#### eos智能合约开发  编译智能合约\n>经过以上的步骤，我们编写好了智能合约，这个合约是一个todolist，可以增加todo,可以将todo变为完成的状态，还可以删除todo,只能删除自己的todo\n\n这里编译智能合约，需要下载好eoscdt,如果没有下载好，建议完整安装好eoscdt再继续往下走了  \n\n1. ![contract](/images/contract1.png)    \n新建一个todolist文件夹，将上面写好的todolist.cpp放进去    \n2.  ![contract](/images/contract2.png)  \n打开终端，进入文件夹，输入   \n\n\t\teosio-cpp -o todolist.wasm todolist.cpp --abigen\n\n\n3.  ![contract](/images/contract3.png)  \n\t成功后会在当前文件夹目录下生成 todolist.wasm 和 todolist.abi\n\t\n#### eos智能合约开发 部署智能合约\n> 这里部署智能合约我暂时只找到使用 命令行的方式部署，如果哪位同学知道其他的方式部署，请告诉我，谢谢\n\n>合约的部署又得创建钱包导入账户，和我们在scatter的方式一样，只不过这次是在命令行上操作了，那接下来继续走\n\n\n* ![contract](/images/contract4.png)   \n\t\n\t\t//显示当前的钱包，如果是按照教程来，应该如图显示\n\t\tcleos wallet list \n  \n* ![contract](/images/contract5.png)  \n\n\t\t// 创建钱包，记住将返回的钱包密匙保存起来\n\t\tcleos wallet create —-to-console \n\t\t// 显示钱包\n\t\tcleos wallet list \n\n* ![contract](/images/contract6.png)  \n\n\t\t// 导入我们之前的导入scatter的密匙对的私钥\n\t\t// 执行后粘贴 私钥就好\n\t\tcleos wallet import\n\n* ![contract](/images/contract6.png)  \n\n\t\t// 导入我们之前的导入scatter的密匙对的私钥\n\t\t// 执行后粘贴 私钥就好\n\t\tcleos wallet import\n\t\t\n* ![contract](/images/contract7.png)  \n\n\t\t// 部署合约 eee,注意看提示内容，RAM不够了，怎么办？去买\n\t\t// 参数解释\n\t\t// -u 指定部署合约的网络\n\t\t// set contract  部署合约的命令\n\t\t// shaokun11113  部署到哪个账户上，注意 这里这个账户的私钥必须被导入钱包且已在 -u指定网络上进行注册\n\t\t// /Users/shaokun/Documents/todolist  abi 和 wasm的 绝对路径 ，建议不要使用相对路径\n\t\t//-p 指定权限\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n\n* ![contract](/images/contract8.png)  \n\n\t\t// 购买RAM\n\t\t// -u 去哪里买\n\t\t// system buyram  购买ram的命令\n\t\t// shaokun11113  谁去买，谁付钱\n\t\t// shaokun11113  谁受益 买来的ram 给谁\n\t\t// -k 买多少 kbytes \n\t\tcleos -u http://jungle.cryptolions.io:18888 system buyram shaokun11113 shaokun11113 -k 1024\n\t\t\n* ![contract](/images/contract9.png)  \n\t有时候你也许会遇到这种情况 ，那就需要之前创建钱包时的密匙进行解锁钱包\n\t\t\n* ![contract](/images/contract10.png)  \n\n\t\t// 解锁默认钱包，输入钱包秘钥就好， 可以使用-n 指定解锁的钱包名字\n\t\tcleos unlock wallet\n\t\t\n* ![contract](/images/contract11.png)  \n\n\t\t// 再次部署合约，可以看到结果eosio::setcode eosio::sebabi说明部署成功\n\t\tcleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n\t\t\n#### eos智能合约开发 使用scatter.js进行交互\n>这里使用 create-react-app 脚手架创建项目，删除无用的文件，启动项目。这里有疑问的请百度\n\n* ![contract](/images/contract12.png) ![contract](/images/contract13.png) \n\n创建react项目,打开项目，删除无用的文件\n\n* ![contract](/images/contract14.png) \n\n启动项目，保证项目的正确性\n\n* ![contract](/images/contract15.png) \n\t\t\n\t\t// 安装scatter sdk\n\t\t// 这里使用的是eosjs1,尝试了多种方式，未找到eosjs2的使用方式，如有知道的同学，还请告知\n\t\tnpm i -S scatterjs-core  scatterjs-plugin-eosjs\n\n*  ![contract](/images/contract16.png)\n\n改造项目的布局\n\n\trender() {\n        return (\n            <div>\n\n                <div>\n                    <button onClick={() => this.createTodo()}>create todo</button>\n                    <button onClick={() => this.deleteTodo()}>delete todo</button>\n                    <input type=\"text\" onChange={e => {\n                        this.setState({\n                            deleteId: Number.parseInt(e.target.value)\n                        })\n                    }}/>\n\n                    <button onClick={() => this.completeTodo()}>complete todo</button>\n                    <input type=\"text\" onChange={e => {\n                        this.setState({\n                            competedId: Number.parseInt(e.target.value)\n                        })\n                    }}/>\n                    <button onClick={() => this.showTodo()}>show todo</button>\n                </div>\n                <div>\n                    <p>below is data</p>\n                    <ul>\n                        {\n                            this.state.rows.map((todo, index) => {\n                                return <li key={index}>\n                                    <p>id : {todo.id}</p>\n                                    <p>description : {todo.description}</p>\n                                    <p>completed : {todo.completed}</p>\n                                </li>\n                            })\n                        }\n                    </ul>\n                </div>\n            </div>\n        );\n    }\n* 引入scatter sdk \n\n\t\timport React, {Component} from 'react';\n\t\timport ScatterJS from 'scatterjs-core';\n\t\timport ScatterEOS from 'scatterjs-plugin-eosjs';\n\t\timport Eos from 'eosjs';\n\t\n\t\tScatterJS.plugins(new ScatterEOS());\n\t\n\t\tconst network = {\n\t    blockchain: 'eos',\n\t    protocol: 'http',\n\t    host: 'jungle.cryptolions.io',\n\t    port: 18888,\n\t    chainId: \t\t'038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca'\n\t\t}\n\t\t\n\n* 初始化\n\n\t\n\t\tcomponentDidMount() {\n        \tsetTimeout(() => {\n            \tthis.init()\n        \t}, 2000)\n    \t}\n\n    \tinit() {\n        ScatterJS.scatter.connect('eos').then(connected => {\n            if (!connected) return false;\n            const scatter = ScatterJS.scatter;\n\n            this.setState({\n                scatter\n            });\n            alert(\"scatter load success\")\n        });\n    \t}\t\n    \t\n* ![contract](/images/contract17.png)\t\n\t\n\t增加 曾 删 改 查的功能\n\t\n\t\tcreateTodo() {\n        this.state.scatter.getIdentity(requiredFields).then(() => {\n            const account = this.state.scatter.identity.accounts.find(x => x.blockchain === 'eos');\n            const eos = this.state.scatter.eos(network, Eos);\n            const transactionPermission = {authorization: [`${account.name}@${account.authority}`]};\n            const num = Math.floor(Math.random() * 100000);\n            eos.contract(account.name).then(ins => {\n                ins.create(account.name, num, \"this is \" + num, transactionPermission).then(res => {\n                    console.log(res)\n                })\n            })\n\n        }).catch(error => {\n            console.error(error);\n        });\n    \t}\n\t\n* ![contract](/images/eos11.gif)\t\n\n启动项目，看看演示效果。可以看见与eos网络的交互还是很流畅，速度也很快。到此，基于eos网络开发dapp的流程应该算结束了，谢谢你的阅读。\n\n#### eos智能合约开发 总结\n> 本打算下周更新此篇文章，恰好今天原来的计划取消了，那就不拖了，下周有下周的事情呢  \n> 这里有几点需要大家注意：\n\n*  一定要有梯子，不然根本无从谈起\n*  eos要求硬件比较高，这个需要自己准备了\n*  一定要先理解eos中的相关概念，和以太坊还是有很大的区别的\n*  一定要先跟着官网的hello走一遍\n*  如果哪一步遇到问题了，可以反复翻看这两篇文章，你一定能够成功的\n\n#### eos智能合约开发 源码\n2018-11-15 22:18:58更新\n[源码送上...]\n(https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD)\n#### 接下来的计划\n* 继续分享智能合约的知识，主要是基于eos,tron,eth三个平台，希望能够帮助到大家\n* 分享一些编程语言知识，eth 和 tron 是用solidity写合约，eos是用c++写，前端展示页面是用react写的 \n\n**文章允许转载，但请注明出处，谢谢**\n\n#### 关于我\n区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。  \n（加好友时，请备注 区块链，谢谢）  \n![jungle](/common/wx.png) \n\n当然也可以通过以下方式联系我  \nemail_1: <shaokuning@gmail.com>   \nemail_2: <skunny@163.com>","slug":"基于eos连接scatter开发dapp(下)","published":1,"updated":"2019-02-18T13:13:08.309Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsq3b52w000lnh7s87u2qx7d","content":"<h4 id=\"eos智能合约开发-c-合约编写\"><a href=\"#eos智能合约开发-c-合约编写\" class=\"headerlink\" title=\"eos智能合约开发 c++合约编写\"></a>eos智能合约开发 c++合约编写</h4><blockquote>\n<p>这里需要说明的一下，这个例子和官网提供的hello没有多大的区别,仅仅是带你多了解一下如何编写。其中遇到有些概念难以理解，建议还是参考官网的hello 从头看起</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;  \n#include &lt;eosiolib/print.hpp&gt;\n#include&lt;string&gt;\n\nusing namespace eosio;\nusing std::string;\n\nclass todolist : public contract {  //继承 contract\n\n  public:\n  using contract::contract;           \n\n  todolist(account_name self):contract(self){}   //构造函数\n    // account_name 是eoslib中定义的一种类型\n\n  [[eosio::action]]   // 以前的版本使用的 ///abi action ，eoscdt使用这种方式标识，更加的优雅，也就是你要对外开放的方法都加上才会生成在abi中\n  void create(account_name author, const uint32_t id, const std::string &amp;description)\n  {\n  // 记住，这些action方法的返回值只能是void，不然会报错，只有实际做过的人才会知道 ，那你要问我如何读取区块链的内容呢？ 这个问题也困扰了我蛮久，继续看下面\n    todo_index todos(_self, _self);\n    // 实例化多索引列表，第一个参数是这张表是谁的 code ,即谁有权限去读写它\n    // 第二个参数scope，相当于缩小范围去找到这张表\n    // _self 是构造函数中的self\n    // todo_index 是Multi_index的一个具体的类型，在下面定义的\n\n    todos.emplace(author, [&amp;](auto &amp;new_todo) {\n        new_todo.id = id;\n        new_todo.description = description;\n        new_todo.completed = 0;\n    });\n    // 使用todos这个表的实例，去添加一条todo\n    // 第一个参数表示为这条内容的写入付费的account，第二个参数是一个lambda方法，拿到的参数是这个表中的一行的实例，然后赋值对应的数据即可\n\n    print(&quot;todo#&quot;, id, &quot; created&quot;);\n    // 这里，如果你使用命令行方式 执行，执行成功后会打印这个方法，但是如果是dapp开发，这是看不到的，又有一个疑问，那我们怎么知道执行成功了呢？\n  }\n\n  [[eosio::action]]\n  void complete(account_name author,const uint32_t id)\n  {  \n  // 更改todo的状态为完成\n  todo_index todos(_self, _self);\n\n      auto todo_look = todos.find(id);\n      // 是否用find()方法，去查找这条方法对应的实例\n      eosio_assert(todo_look != todos.end(), &quot;todo does not exit&quot;);\n    // 这里 如果找不到，todos.end() 会返回 null\n      todos.modify(todo_look,author,[&amp;](auto &amp;t) {\n          t.completed = 1;\n      });\n\n      print(&quot;todo #&quot; ,id ,&quot;marked as complted&quot;);\n  }\n\n  [[eosio::action]]\n  void destroy(account_name author, const uint32_t id)\n  {    \n        require_auth(author);\n        // 权限验证，只能够删除自己的todo\n\n        todo_index todos(_self, author);\n      auto todo_look = todos.find(id);\n      todos.erase(todo_look);\n      print(&quot;todo#&quot;, id, &quot; destroyed&quot;);\n  }\n  private:\n    // 在eoscdt中 注意加上[[eosio::table]] ，否则abi中不会生成这个table\n  struct [[eosio::table]] todo {\n      uint64_t id;\n      string description;\n      uint64_t completed;\n\n      uint64_t primary_key() const {\n      // 这个方法是必须存在的，上面方法能够查找就是因为这个方法的存在，  \n      // 所以说查找只用传入 id即可，  \n      // 如果要使用其他的查找方式，得多定义几个查找的方法，最多可以定义16个  \n      // 如何定义看官网，这里不演示了  \n          return id;\n      }\n\n      EOSLIB_SERIALIZE(todo,(id)(description)(completed));\n  };\n\n  typedef eosio::multi_index&lt;N(todo),todo&gt; todo_index;\n  // 这里定义了多索引列表的具体实现，N(todo)是将你的account 转换为 uint64_t 类型，第二个参数传入表名字， 定义的具体的类型是todo_index\n\n};\n\nEOSIO_ABI(todolist, (create)(complete)(destroy))\n</code></pre><h4 id=\"eos智能合约开发-编译智能合约\"><a href=\"#eos智能合约开发-编译智能合约\" class=\"headerlink\" title=\"eos智能合约开发  编译智能合约\"></a>eos智能合约开发  编译智能合约</h4><blockquote>\n<p>经过以上的步骤，我们编写好了智能合约，这个合约是一个todolist，可以增加todo,可以将todo变为完成的状态，还可以删除todo,只能删除自己的todo</p>\n</blockquote>\n<p>这里编译智能合约，需要下载好eoscdt,如果没有下载好，建议完整安装好eoscdt再继续往下走了  </p>\n<ol>\n<li><img src=\"/images/contract1.png\" alt=\"contract\"><br>新建一个todolist文件夹，将上面写好的todolist.cpp放进去    </li>\n<li><p><img src=\"/images/contract2.png\" alt=\"contract\"><br>打开终端，进入文件夹，输入   </p>\n<pre><code>eosio-cpp -o todolist.wasm todolist.cpp --abigen\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><img src=\"/images/contract3.png\" alt=\"contract\"><br>成功后会在当前文件夹目录下生成 todolist.wasm 和 todolist.abi</li>\n</ol>\n<h4 id=\"eos智能合约开发-部署智能合约\"><a href=\"#eos智能合约开发-部署智能合约\" class=\"headerlink\" title=\"eos智能合约开发 部署智能合约\"></a>eos智能合约开发 部署智能合约</h4><blockquote>\n<p>这里部署智能合约我暂时只找到使用 命令行的方式部署，如果哪位同学知道其他的方式部署，请告诉我，谢谢</p>\n</blockquote>\n<blockquote>\n<p>合约的部署又得创建钱包导入账户，和我们在scatter的方式一样，只不过这次是在命令行上操作了，那接下来继续走</p>\n</blockquote>\n<ul>\n<li><p><img src=\"/images/contract4.png\" alt=\"contract\">   </p>\n<pre><code>//显示当前的钱包，如果是按照教程来，应该如图显示\ncleos wallet list \n</code></pre></li>\n<li><p><img src=\"/images/contract5.png\" alt=\"contract\">  </p>\n<pre><code>// 创建钱包，记住将返回的钱包密匙保存起来\ncleos wallet create —-to-console \n// 显示钱包\ncleos wallet list \n</code></pre></li>\n<li><p><img src=\"/images/contract6.png\" alt=\"contract\">  </p>\n<pre><code>// 导入我们之前的导入scatter的密匙对的私钥\n// 执行后粘贴 私钥就好\ncleos wallet import\n</code></pre></li>\n<li><p><img src=\"/images/contract6.png\" alt=\"contract\">  </p>\n<pre><code>// 导入我们之前的导入scatter的密匙对的私钥\n// 执行后粘贴 私钥就好\ncleos wallet import\n</code></pre></li>\n<li><p><img src=\"/images/contract7.png\" alt=\"contract\">  </p>\n<pre><code>// 部署合约 eee,注意看提示内容，RAM不够了，怎么办？去买\n// 参数解释\n// -u 指定部署合约的网络\n// set contract  部署合约的命令\n// shaokun11113  部署到哪个账户上，注意 这里这个账户的私钥必须被导入钱包且已在 -u指定网络上进行注册\n// /Users/shaokun/Documents/todolist  abi 和 wasm的 绝对路径 ，建议不要使用相对路径\n//-p 指定权限\ncleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n</code></pre></li>\n<li><p><img src=\"/images/contract8.png\" alt=\"contract\">  </p>\n<pre><code>// 购买RAM\n// -u 去哪里买\n// system buyram  购买ram的命令\n// shaokun11113  谁去买，谁付钱\n// shaokun11113  谁受益 买来的ram 给谁\n// -k 买多少 kbytes \ncleos -u http://jungle.cryptolions.io:18888 system buyram shaokun11113 shaokun11113 -k 1024\n</code></pre></li>\n<li><p><img src=\"/images/contract9.png\" alt=\"contract\"><br>  有时候你也许会遇到这种情况 ，那就需要之前创建钱包时的密匙进行解锁钱包</p>\n</li>\n<li><p><img src=\"/images/contract10.png\" alt=\"contract\">  </p>\n<pre><code>// 解锁默认钱包，输入钱包秘钥就好， 可以使用-n 指定解锁的钱包名字\ncleos unlock wallet\n</code></pre></li>\n<li><p><img src=\"/images/contract11.png\" alt=\"contract\">  </p>\n<pre><code>// 再次部署合约，可以看到结果eosio::setcode eosio::sebabi说明部署成功\ncleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n</code></pre></li>\n</ul>\n<h4 id=\"eos智能合约开发-使用scatter-js进行交互\"><a href=\"#eos智能合约开发-使用scatter-js进行交互\" class=\"headerlink\" title=\"eos智能合约开发 使用scatter.js进行交互\"></a>eos智能合约开发 使用scatter.js进行交互</h4><blockquote>\n<p>这里使用 create-react-app 脚手架创建项目，删除无用的文件，启动项目。这里有疑问的请百度</p>\n</blockquote>\n<ul>\n<li><img src=\"/images/contract12.png\" alt=\"contract\"> <img src=\"/images/contract13.png\" alt=\"contract\"> </li>\n</ul>\n<p>创建react项目,打开项目，删除无用的文件</p>\n<ul>\n<li><img src=\"/images/contract14.png\" alt=\"contract\"> </li>\n</ul>\n<p>启动项目，保证项目的正确性</p>\n<ul>\n<li><p><img src=\"/images/contract15.png\" alt=\"contract\"> </p>\n<pre><code>// 安装scatter sdk\n// 这里使用的是eosjs1,尝试了多种方式，未找到eosjs2的使用方式，如有知道的同学，还请告知\nnpm i -S scatterjs-core  scatterjs-plugin-eosjs\n</code></pre></li>\n<li><p><img src=\"/images/contract16.png\" alt=\"contract\"></p>\n</li>\n</ul>\n<p>改造项目的布局</p>\n<pre><code>render() {\n    return (\n        &lt;div&gt;\n\n            &lt;div&gt;\n                &lt;button onClick={() =&gt; this.createTodo()}&gt;create todo&lt;/button&gt;\n                &lt;button onClick={() =&gt; this.deleteTodo()}&gt;delete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        deleteId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n\n                &lt;button onClick={() =&gt; this.completeTodo()}&gt;complete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        competedId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n                &lt;button onClick={() =&gt; this.showTodo()}&gt;show todo&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;p&gt;below is data&lt;/p&gt;\n                &lt;ul&gt;\n                    {\n                        this.state.rows.map((todo, index) =&gt; {\n                            return &lt;li key={index}&gt;\n                                &lt;p&gt;id : {todo.id}&lt;/p&gt;\n                                &lt;p&gt;description : {todo.description}&lt;/p&gt;\n                                &lt;p&gt;completed : {todo.completed}&lt;/p&gt;\n                            &lt;/li&gt;\n                        })\n                    }\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre><ul>\n<li><p>引入scatter sdk </p>\n<pre><code>import React, {Component} from &apos;react&apos;;\nimport ScatterJS from &apos;scatterjs-core&apos;;\nimport ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;\nimport Eos from &apos;eosjs&apos;;\n\nScatterJS.plugins(new ScatterEOS());\n\nconst network = {\nblockchain: &apos;eos&apos;,\nprotocol: &apos;http&apos;,\nhost: &apos;jungle.cryptolions.io&apos;,\nport: 18888,\nchainId:         &apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;\n}\n</code></pre></li>\n</ul>\n<ul>\n<li>初始化</li>\n</ul>\n<pre><code>componentDidMount() {\n    setTimeout(() =&gt; {\n        this.init()\n    }, 2000)\n}\n\ninit() {\nScatterJS.scatter.connect(&apos;eos&apos;).then(connected =&gt; {\n    if (!connected) return false;\n    const scatter = ScatterJS.scatter;\n\n    this.setState({\n        scatter\n    });\n    alert(&quot;scatter load success&quot;)\n});\n}    \n</code></pre><ul>\n<li><p><img src=\"/images/contract17.png\" alt=\"contract\">    </p>\n<p>  增加 曾 删 改 查的功能</p>\n<pre><code>createTodo() {\nthis.state.scatter.getIdentity(requiredFields).then(() =&gt; {\n    const account = this.state.scatter.identity.accounts.find(x =&gt; x.blockchain === &apos;eos&apos;);\n    const eos = this.state.scatter.eos(network, Eos);\n    const transactionPermission = {authorization: [`${account.name}@${account.authority}`]};\n    const num = Math.floor(Math.random() * 100000);\n    eos.contract(account.name).then(ins =&gt; {\n        ins.create(account.name, num, &quot;this is &quot; + num, transactionPermission).then(res =&gt; {\n            console.log(res)\n        })\n    })\n\n}).catch(error =&gt; {\n    console.error(error);\n});\n}\n</code></pre></li>\n<li><p><img src=\"/images/eos11.gif\" alt=\"contract\">    </p>\n</li>\n</ul>\n<p>启动项目，看看演示效果。可以看见与eos网络的交互还是很流畅，速度也很快。到此，基于eos网络开发dapp的流程应该算结束了，谢谢你的阅读。</p>\n<h4 id=\"eos智能合约开发-总结\"><a href=\"#eos智能合约开发-总结\" class=\"headerlink\" title=\"eos智能合约开发 总结\"></a>eos智能合约开发 总结</h4><blockquote>\n<p>本打算下周更新此篇文章，恰好今天原来的计划取消了，那就不拖了，下周有下周的事情呢<br>这里有几点需要大家注意：</p>\n</blockquote>\n<ul>\n<li>一定要有梯子，不然根本无从谈起</li>\n<li>eos要求硬件比较高，这个需要自己准备了</li>\n<li>一定要先理解eos中的相关概念，和以太坊还是有很大的区别的</li>\n<li>一定要先跟着官网的hello走一遍</li>\n<li>如果哪一步遇到问题了，可以反复翻看这两篇文章，你一定能够成功的</li>\n</ul>\n<h4 id=\"eos智能合约开发-源码\"><a href=\"#eos智能合约开发-源码\" class=\"headerlink\" title=\"eos智能合约开发 源码\"></a>eos智能合约开发 源码</h4><p>2018-11-15 22:18:58更新<br>[源码送上…]<br>(<a href=\"https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD\" target=\"_blank\" rel=\"noopener\">https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD</a>)</p>\n<h4 id=\"接下来的计划\"><a href=\"#接下来的计划\" class=\"headerlink\" title=\"接下来的计划\"></a>接下来的计划</h4><ul>\n<li>继续分享智能合约的知识，主要是基于eos,tron,eth三个平台，希望能够帮助到大家</li>\n<li>分享一些编程语言知识，eth 和 tron 是用solidity写合约，eos是用c++写，前端展示页面是用react写的 </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"eos智能合约开发-c-合约编写\"><a href=\"#eos智能合约开发-c-合约编写\" class=\"headerlink\" title=\"eos智能合约开发 c++合约编写\"></a>eos智能合约开发 c++合约编写</h4><blockquote>\n<p>这里需要说明的一下，这个例子和官网提供的hello没有多大的区别,仅仅是带你多了解一下如何编写。其中遇到有些概念难以理解，建议还是参考官网的hello 从头看起</p>\n</blockquote>\n<pre><code>#include &lt;eosiolib/eosio.hpp&gt;  \n#include &lt;eosiolib/print.hpp&gt;\n#include&lt;string&gt;\n\nusing namespace eosio;\nusing std::string;\n\nclass todolist : public contract {  //继承 contract\n\n  public:\n  using contract::contract;           \n\n  todolist(account_name self):contract(self){}   //构造函数\n    // account_name 是eoslib中定义的一种类型\n\n  [[eosio::action]]   // 以前的版本使用的 ///abi action ，eoscdt使用这种方式标识，更加的优雅，也就是你要对外开放的方法都加上才会生成在abi中\n  void create(account_name author, const uint32_t id, const std::string &amp;description)\n  {\n  // 记住，这些action方法的返回值只能是void，不然会报错，只有实际做过的人才会知道 ，那你要问我如何读取区块链的内容呢？ 这个问题也困扰了我蛮久，继续看下面\n    todo_index todos(_self, _self);\n    // 实例化多索引列表，第一个参数是这张表是谁的 code ,即谁有权限去读写它\n    // 第二个参数scope，相当于缩小范围去找到这张表\n    // _self 是构造函数中的self\n    // todo_index 是Multi_index的一个具体的类型，在下面定义的\n\n    todos.emplace(author, [&amp;](auto &amp;new_todo) {\n        new_todo.id = id;\n        new_todo.description = description;\n        new_todo.completed = 0;\n    });\n    // 使用todos这个表的实例，去添加一条todo\n    // 第一个参数表示为这条内容的写入付费的account，第二个参数是一个lambda方法，拿到的参数是这个表中的一行的实例，然后赋值对应的数据即可\n\n    print(&quot;todo#&quot;, id, &quot; created&quot;);\n    // 这里，如果你使用命令行方式 执行，执行成功后会打印这个方法，但是如果是dapp开发，这是看不到的，又有一个疑问，那我们怎么知道执行成功了呢？\n  }\n\n  [[eosio::action]]\n  void complete(account_name author,const uint32_t id)\n  {  \n  // 更改todo的状态为完成\n  todo_index todos(_self, _self);\n\n      auto todo_look = todos.find(id);\n      // 是否用find()方法，去查找这条方法对应的实例\n      eosio_assert(todo_look != todos.end(), &quot;todo does not exit&quot;);\n    // 这里 如果找不到，todos.end() 会返回 null\n      todos.modify(todo_look,author,[&amp;](auto &amp;t) {\n          t.completed = 1;\n      });\n\n      print(&quot;todo #&quot; ,id ,&quot;marked as complted&quot;);\n  }\n\n  [[eosio::action]]\n  void destroy(account_name author, const uint32_t id)\n  {    \n        require_auth(author);\n        // 权限验证，只能够删除自己的todo\n\n        todo_index todos(_self, author);\n      auto todo_look = todos.find(id);\n      todos.erase(todo_look);\n      print(&quot;todo#&quot;, id, &quot; destroyed&quot;);\n  }\n  private:\n    // 在eoscdt中 注意加上[[eosio::table]] ，否则abi中不会生成这个table\n  struct [[eosio::table]] todo {\n      uint64_t id;\n      string description;\n      uint64_t completed;\n\n      uint64_t primary_key() const {\n      // 这个方法是必须存在的，上面方法能够查找就是因为这个方法的存在，  \n      // 所以说查找只用传入 id即可，  \n      // 如果要使用其他的查找方式，得多定义几个查找的方法，最多可以定义16个  \n      // 如何定义看官网，这里不演示了  \n          return id;\n      }\n\n      EOSLIB_SERIALIZE(todo,(id)(description)(completed));\n  };\n\n  typedef eosio::multi_index&lt;N(todo),todo&gt; todo_index;\n  // 这里定义了多索引列表的具体实现，N(todo)是将你的account 转换为 uint64_t 类型，第二个参数传入表名字， 定义的具体的类型是todo_index\n\n};\n\nEOSIO_ABI(todolist, (create)(complete)(destroy))\n</code></pre><h4 id=\"eos智能合约开发-编译智能合约\"><a href=\"#eos智能合约开发-编译智能合约\" class=\"headerlink\" title=\"eos智能合约开发  编译智能合约\"></a>eos智能合约开发  编译智能合约</h4><blockquote>\n<p>经过以上的步骤，我们编写好了智能合约，这个合约是一个todolist，可以增加todo,可以将todo变为完成的状态，还可以删除todo,只能删除自己的todo</p>\n</blockquote>\n<p>这里编译智能合约，需要下载好eoscdt,如果没有下载好，建议完整安装好eoscdt再继续往下走了  </p>\n<ol>\n<li><img src=\"/images/contract1.png\" alt=\"contract\"><br>新建一个todolist文件夹，将上面写好的todolist.cpp放进去    </li>\n<li><p><img src=\"/images/contract2.png\" alt=\"contract\"><br>打开终端，进入文件夹，输入   </p>\n<pre><code>eosio-cpp -o todolist.wasm todolist.cpp --abigen\n</code></pre></li>\n</ol>\n<ol start=\"3\">\n<li><img src=\"/images/contract3.png\" alt=\"contract\"><br>成功后会在当前文件夹目录下生成 todolist.wasm 和 todolist.abi</li>\n</ol>\n<h4 id=\"eos智能合约开发-部署智能合约\"><a href=\"#eos智能合约开发-部署智能合约\" class=\"headerlink\" title=\"eos智能合约开发 部署智能合约\"></a>eos智能合约开发 部署智能合约</h4><blockquote>\n<p>这里部署智能合约我暂时只找到使用 命令行的方式部署，如果哪位同学知道其他的方式部署，请告诉我，谢谢</p>\n</blockquote>\n<blockquote>\n<p>合约的部署又得创建钱包导入账户，和我们在scatter的方式一样，只不过这次是在命令行上操作了，那接下来继续走</p>\n</blockquote>\n<ul>\n<li><p><img src=\"/images/contract4.png\" alt=\"contract\">   </p>\n<pre><code>//显示当前的钱包，如果是按照教程来，应该如图显示\ncleos wallet list \n</code></pre></li>\n<li><p><img src=\"/images/contract5.png\" alt=\"contract\">  </p>\n<pre><code>// 创建钱包，记住将返回的钱包密匙保存起来\ncleos wallet create —-to-console \n// 显示钱包\ncleos wallet list \n</code></pre></li>\n<li><p><img src=\"/images/contract6.png\" alt=\"contract\">  </p>\n<pre><code>// 导入我们之前的导入scatter的密匙对的私钥\n// 执行后粘贴 私钥就好\ncleos wallet import\n</code></pre></li>\n<li><p><img src=\"/images/contract6.png\" alt=\"contract\">  </p>\n<pre><code>// 导入我们之前的导入scatter的密匙对的私钥\n// 执行后粘贴 私钥就好\ncleos wallet import\n</code></pre></li>\n<li><p><img src=\"/images/contract7.png\" alt=\"contract\">  </p>\n<pre><code>// 部署合约 eee,注意看提示内容，RAM不够了，怎么办？去买\n// 参数解释\n// -u 指定部署合约的网络\n// set contract  部署合约的命令\n// shaokun11113  部署到哪个账户上，注意 这里这个账户的私钥必须被导入钱包且已在 -u指定网络上进行注册\n// /Users/shaokun/Documents/todolist  abi 和 wasm的 绝对路径 ，建议不要使用相对路径\n//-p 指定权限\ncleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n</code></pre></li>\n<li><p><img src=\"/images/contract8.png\" alt=\"contract\">  </p>\n<pre><code>// 购买RAM\n// -u 去哪里买\n// system buyram  购买ram的命令\n// shaokun11113  谁去买，谁付钱\n// shaokun11113  谁受益 买来的ram 给谁\n// -k 买多少 kbytes \ncleos -u http://jungle.cryptolions.io:18888 system buyram shaokun11113 shaokun11113 -k 1024\n</code></pre></li>\n<li><p><img src=\"/images/contract9.png\" alt=\"contract\"><br>  有时候你也许会遇到这种情况 ，那就需要之前创建钱包时的密匙进行解锁钱包</p>\n</li>\n<li><p><img src=\"/images/contract10.png\" alt=\"contract\">  </p>\n<pre><code>// 解锁默认钱包，输入钱包秘钥就好， 可以使用-n 指定解锁的钱包名字\ncleos unlock wallet\n</code></pre></li>\n<li><p><img src=\"/images/contract11.png\" alt=\"contract\">  </p>\n<pre><code>// 再次部署合约，可以看到结果eosio::setcode eosio::sebabi说明部署成功\ncleos -u http://jungle.cryptolions.io:18888 set contract shaokun11113 /Users/shaokun/Documents/todolist -p shaokun11113@active\n</code></pre></li>\n</ul>\n<h4 id=\"eos智能合约开发-使用scatter-js进行交互\"><a href=\"#eos智能合约开发-使用scatter-js进行交互\" class=\"headerlink\" title=\"eos智能合约开发 使用scatter.js进行交互\"></a>eos智能合约开发 使用scatter.js进行交互</h4><blockquote>\n<p>这里使用 create-react-app 脚手架创建项目，删除无用的文件，启动项目。这里有疑问的请百度</p>\n</blockquote>\n<ul>\n<li><img src=\"/images/contract12.png\" alt=\"contract\"> <img src=\"/images/contract13.png\" alt=\"contract\"> </li>\n</ul>\n<p>创建react项目,打开项目，删除无用的文件</p>\n<ul>\n<li><img src=\"/images/contract14.png\" alt=\"contract\"> </li>\n</ul>\n<p>启动项目，保证项目的正确性</p>\n<ul>\n<li><p><img src=\"/images/contract15.png\" alt=\"contract\"> </p>\n<pre><code>// 安装scatter sdk\n// 这里使用的是eosjs1,尝试了多种方式，未找到eosjs2的使用方式，如有知道的同学，还请告知\nnpm i -S scatterjs-core  scatterjs-plugin-eosjs\n</code></pre></li>\n<li><p><img src=\"/images/contract16.png\" alt=\"contract\"></p>\n</li>\n</ul>\n<p>改造项目的布局</p>\n<pre><code>render() {\n    return (\n        &lt;div&gt;\n\n            &lt;div&gt;\n                &lt;button onClick={() =&gt; this.createTodo()}&gt;create todo&lt;/button&gt;\n                &lt;button onClick={() =&gt; this.deleteTodo()}&gt;delete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        deleteId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n\n                &lt;button onClick={() =&gt; this.completeTodo()}&gt;complete todo&lt;/button&gt;\n                &lt;input type=&quot;text&quot; onChange={e =&gt; {\n                    this.setState({\n                        competedId: Number.parseInt(e.target.value)\n                    })\n                }}/&gt;\n                &lt;button onClick={() =&gt; this.showTodo()}&gt;show todo&lt;/button&gt;\n            &lt;/div&gt;\n            &lt;div&gt;\n                &lt;p&gt;below is data&lt;/p&gt;\n                &lt;ul&gt;\n                    {\n                        this.state.rows.map((todo, index) =&gt; {\n                            return &lt;li key={index}&gt;\n                                &lt;p&gt;id : {todo.id}&lt;/p&gt;\n                                &lt;p&gt;description : {todo.description}&lt;/p&gt;\n                                &lt;p&gt;completed : {todo.completed}&lt;/p&gt;\n                            &lt;/li&gt;\n                        })\n                    }\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    );\n}\n</code></pre><ul>\n<li><p>引入scatter sdk </p>\n<pre><code>import React, {Component} from &apos;react&apos;;\nimport ScatterJS from &apos;scatterjs-core&apos;;\nimport ScatterEOS from &apos;scatterjs-plugin-eosjs&apos;;\nimport Eos from &apos;eosjs&apos;;\n\nScatterJS.plugins(new ScatterEOS());\n\nconst network = {\nblockchain: &apos;eos&apos;,\nprotocol: &apos;http&apos;,\nhost: &apos;jungle.cryptolions.io&apos;,\nport: 18888,\nchainId:         &apos;038f4b0fc8ff18a4f0842a8f0564611f6e96e8535901dd45e43ac8691a1c4dca&apos;\n}\n</code></pre></li>\n</ul>\n<ul>\n<li>初始化</li>\n</ul>\n<pre><code>componentDidMount() {\n    setTimeout(() =&gt; {\n        this.init()\n    }, 2000)\n}\n\ninit() {\nScatterJS.scatter.connect(&apos;eos&apos;).then(connected =&gt; {\n    if (!connected) return false;\n    const scatter = ScatterJS.scatter;\n\n    this.setState({\n        scatter\n    });\n    alert(&quot;scatter load success&quot;)\n});\n}    \n</code></pre><ul>\n<li><p><img src=\"/images/contract17.png\" alt=\"contract\">    </p>\n<p>  增加 曾 删 改 查的功能</p>\n<pre><code>createTodo() {\nthis.state.scatter.getIdentity(requiredFields).then(() =&gt; {\n    const account = this.state.scatter.identity.accounts.find(x =&gt; x.blockchain === &apos;eos&apos;);\n    const eos = this.state.scatter.eos(network, Eos);\n    const transactionPermission = {authorization: [`${account.name}@${account.authority}`]};\n    const num = Math.floor(Math.random() * 100000);\n    eos.contract(account.name).then(ins =&gt; {\n        ins.create(account.name, num, &quot;this is &quot; + num, transactionPermission).then(res =&gt; {\n            console.log(res)\n        })\n    })\n\n}).catch(error =&gt; {\n    console.error(error);\n});\n}\n</code></pre></li>\n<li><p><img src=\"/images/eos11.gif\" alt=\"contract\">    </p>\n</li>\n</ul>\n<p>启动项目，看看演示效果。可以看见与eos网络的交互还是很流畅，速度也很快。到此，基于eos网络开发dapp的流程应该算结束了，谢谢你的阅读。</p>\n<h4 id=\"eos智能合约开发-总结\"><a href=\"#eos智能合约开发-总结\" class=\"headerlink\" title=\"eos智能合约开发 总结\"></a>eos智能合约开发 总结</h4><blockquote>\n<p>本打算下周更新此篇文章，恰好今天原来的计划取消了，那就不拖了，下周有下周的事情呢<br>这里有几点需要大家注意：</p>\n</blockquote>\n<ul>\n<li>一定要有梯子，不然根本无从谈起</li>\n<li>eos要求硬件比较高，这个需要自己准备了</li>\n<li>一定要先理解eos中的相关概念，和以太坊还是有很大的区别的</li>\n<li>一定要先跟着官网的hello走一遍</li>\n<li>如果哪一步遇到问题了，可以反复翻看这两篇文章，你一定能够成功的</li>\n</ul>\n<h4 id=\"eos智能合约开发-源码\"><a href=\"#eos智能合约开发-源码\" class=\"headerlink\" title=\"eos智能合约开发 源码\"></a>eos智能合约开发 源码</h4><p>2018-11-15 22:18:58更新<br>[源码送上…]<br>(<a href=\"https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD\" target=\"_blank\" rel=\"noopener\">https://shaokun11.github.io/2018/11/15/%E5%9F%BA%E4%BA%8Eeos%E8%BF%9E%E6%8E%A5scatter%E5%BC%80%E5%8F%91dapp(%E4%B8%8B)%20%E7%BB%AD</a>)</p>\n<h4 id=\"接下来的计划\"><a href=\"#接下来的计划\" class=\"headerlink\" title=\"接下来的计划\"></a>接下来的计划</h4><ul>\n<li>继续分享智能合约的知识，主要是基于eos,tron,eth三个平台，希望能够帮助到大家</li>\n<li>分享一些编程语言知识，eth 和 tron 是用solidity写合约，eos是用c++写，前端展示页面是用react写的 </li>\n</ul>\n<p><strong>文章允许转载，但请注明出处，谢谢</strong></p>\n<h4 id=\"关于我\"><a href=\"#关于我\" class=\"headerlink\" title=\"关于我\"></a>关于我</h4><p>区块链技术痴迷的程序猿一枚，如果你喜欢我的文章，可以加上微信共同学习，共同进步。<br>（加好友时，请备注 区块链，谢谢）<br><img src=\"/common/wx.png\" alt=\"jungle\"> </p>\n<p>当然也可以通过以下方式联系我<br>email_1: <a href=\"mailto:&#115;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#104;&#97;&#111;&#x6b;&#x75;&#110;&#x69;&#x6e;&#103;&#x40;&#x67;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#111;&#109;</a><br>email_2: <a href=\"mailto:&#115;&#107;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;\" target=\"_blank\" rel=\"noopener\">&#115;&#107;&#x75;&#x6e;&#x6e;&#121;&#64;&#x31;&#x36;&#51;&#x2e;&#99;&#x6f;&#109;</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}